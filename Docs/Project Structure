Project Structure

Node


VarDecl
	sourceInformation
	name
	Decl type

Decl
	quals
-------------------
	TypeDecl
		Def

	ArrayDecl
		ConstantNumber size
		Decl type

	PointerDecl
		Decl type

	RefDecl
		Decl type

	FunctionDecl
		Decl args
		Decl type

	ConstantDecl
		Number
		String
---------------------

DeclManager
	Decl for type... etc
	Decl's don't have a single parent
	Decl pointers can be compared with == for direct equality
	Decl can be compared for more information with Decl.Compare Decl.Convert etc
VarDecl
	holds all source information for a specific Decl
	.annotate to get corresponding TypeDecl etc

Def
	Structure
	Enum
	Function

Structured

	If

	For

	BinaryOper

	UnaryOper

	Return

	Cast

	Block


Vistitors

	Annotate
		Type Checks all nodes

	CodeGen
		Generates all c code


Compiler stages
	Lexer - tokenizes
	Parser - generates ast

	Annotate - type check all nodes and and high level operations fill in all gaps and declarations with concrete types

	CodeGen
		first pass - dependencies structures, and globals
		second pass - spit out all code

			predeclarations
			structures
			function stubs
			function definitions


modules

module dl {
	dl.library
}

spits out .ast file


buildSystem
@build {
	flags
	external linked libs etc
}

@load{
	.ast files work as well
	files
}


ListDec
	type - Specific Structure
	(string name, Dec dec)[]

ListExpr
	type - Specific Structure
	Expr[]

Dec : Expr
VarDec
	name
	next
PtrDec
	pointed
AnyDec
	next

RemoveSugar(){
	if VarDec
		return type.RemoveSugar()
	if AnyDec
		return type.RemoveSugar()
}

StructDef - type
EnumDef - type


Declarations
------------
(Dec,...) name - VarDef of type ListDec
Dec name - VarDef of type Dec
fn name() - VarDef of type FnDec


Expressions
------------------------
//(expr,...) - ListExpr, can include Decs. Decs are just variables of type type.{TypeName} they do not take any space however they forward operations to the types typeinfo structure thus they do have a unique address which can be taken.
//
//expr - Expr
//Types do not actually take any space but symantically they are implemented like the following.

struct Type {
	TypeInfo typeinfo
	use typeinfo
}

Functions
------------------------
//Takes an ExprList as an argument argument is defined by a ListDec which can be either a Dec or a Type.{Dec}
//
//
//
//
Dynamic memory with new
------------------------
//new is an expression which is syntatic sugar for copying a value into dynamic memory. 
//It is not supposed to be the most performant method of initializing memory but in most cases code can be optimized to remove the redudant value initialization and copy straight into dynamic memory
//
//new is essentially two functions one taking an expression and the other a type
//
fn new(T? value) T^ {
	T^ r = Alloc(T, 1)
	^r = value
	return r
}

fn new(type T?) T^ {
	return ZeroAlloc(T, 1)
}

new {Dec}
new {Expression}













