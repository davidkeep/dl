
TO DO LIST

NEW MUTABLITY/REFERENCE RULES
	-Variables are mutable on creation unless global
	-Types are immutable unless mut is speicified values are mutable ALWAYS end of story
	-You cant create refernces to variables except by passing to a function or returning from a function
	(Library can have a ToReference function)


	fn ToReference(T! r) T?!{
		return r
	}
	-------EXAMPLE--------

	Vec3 a = --- (assignable val type)
	mut Vec3 b = Function() //b is a mutable refernece to a Function must return mut Vec3
	Vec3 c = Function() //const ref or const val type unless val was explicitly specified in the return then it returns a mut val type


	-Types are pass by reference unless type is specified as a value type

		-ref, val and mut qualifiers
		-ref or mut forces a type to be a reference even if it isn't
		-val forces a type to be a value type even if it isn't
		-specifing ref and val qualifiers are probably not used very often but are still nessesary. For instance returning a local variable of a type that is a pass by references must be a val type. Math types are usually return by value but often passed by reference.

		-Should returning local variables requre the val qualifier even on types that are specified as a value type (this would mean that one could change a type from ref to val and never require any code changes)

		-should returning a local variable automatically turn the return type to val. Could be masking a lot of potential bugs or causing bad performance? probably not

	-Return values and references
		Returning a local variable requires either the type to be pass by value or the return to be explicity return by value

BUGS
	Multiple operators crash compiler
	r.x = = axis.x * sinf(angle/2)

	should unnessesary ';' be a parse error? currently is
	move ';' handling to be the same as \n solves all problems and unifies cases
	r.x = axis.x * sinf(angle/2);;

	global variable dependecies don't work

	returning nothing crashes compiler

	else if == GLFW_RELEASE crash

TODO complain about obvious unexpected symbols in non ambigous cases
	structure declaration
	function declarationa arguments


type check if statements. Must be implicitly convertable to bool
	float intergers and pointers implicity covert to bool
	bool implicity coverts to any number type 

generic redeclaration doesn't throw errror
fn Test(T?)
fn Test(T?)
fn Test(T?)
fn Test(T?)
fn Test(T?)

no error

function parameters and locals aren't in the same scope
fn a(int b){
	int b // <<< Should be redeclaration error
}

BUG: local function definitions have access to the scope its defined in should be just global scope

remove extensions .dl implicit?
@load block or expression
@load {
}

Build flags in code?
@build
{
	"linkFlags" = "-"

}
@link vs
@extern 

tips
	did you mean 'blah' instead of 'bleh'
https://en.wikipedia.org/wiki/Levenshtein_distance
Spell checking for undeclared variable function and type names



//literal pointer and references
//Using compound literals to get pointer C99 compat
void asdf(const int *i)
{
}
asdf((const int[]){1});

inline (how to deal with r values?)
don't generate code for unreferenced nodes

Code isn't referenced if
	Variables/Function - always inlined and address never taken
	Structures - never used


rewrite how generics are handled
rank matches to find best?
