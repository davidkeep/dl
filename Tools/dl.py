#-----------------------------------------------------------------
# pycparser: func_defs.py
#
# Using pycparser for printing out all the functions defined in a
# C file.
#
# This is a simple example of traversing the AST generated by
# pycparser. Call it from the root directory of pycparser.
#
# Copyright (C) 2008-2015, Eli Bendersky
# License: BSD
#-----------------------------------------------------------------
from __future__ import print_function
import sys

# This is not required if you've installed pycparser into
# your site-packages/ with setup.py
sys.path.extend(['.', '..'])

from pycparser import c_parser, c_ast, parse_file


# A simple visitor for FuncDef nodes that prints the names and
# locations of function definitions.
def typeString(t, val = True):
    string = ""
    if type(t) is c_ast.PtrDecl:
        #Function pointers aren't pointers in dl
        if type(t.type) is c_ast.FuncDecl:
            string = typeString(t.type, False)
        else:
            string = typeString(t.type, False) + "^"
    elif type(t) is c_ast.IdentifierType:
        string = t.names[0] + string ###Decl/PtrDecl/TypeDecl/IdentifierType
    elif type(t) is c_ast.ArrayDecl:
        string = typeString(t.type,val) + "[" + t.dim.value + "]"
    elif type(t) is c_ast.TypeDecl:
        string = typeString(t.type,val) + string ###Decl/PtrDecl/TypeDecl/IdentifierType
    elif type(t) is c_ast.Struct:
        string = t.name
    elif type(t) is c_ast.FuncDecl:
        string = 'fn('
        for i, n in enumerate(t.args.params):
                if i < len(t.args.params) - 1:
                    string += n.name + ' ' +  typeString(n.type)+", "
                else:
                    string += n.name +  ' ' + typeString(n.type)
        string += ') ' + typeString(t.type) 

    if val and string == "void":
    	return ""

    if string == "int":
        return "i32"
    if string == "short":
        return "i16"
    if string == "unsigned":
        return "u16"
    if string == "float":
        return "f32"
    if string == "char":
        return "i8"
    if string == "void^":
        return "voidptr"
    return string


class FuncDefVisitor(c_ast.NodeVisitor):
    #def visit_Decl(self, node):
    #    print(node.name)
    #node.decl.type.args.params
        #if node.name:
           # print( "fn", node.name + "(", end="")
        # if node.decl.type.args:
        #     for params in (node.decl.type.args.params): ###FuncDef/Decl/FuncDecl/ParamList
        #         # Assign parameter name
        #         print(typeString(params.type) + " " + params.name, end="")

        # print(')', typeString(node.decl.type.type))
    def visit_Typedef(self, node):
        print('using', node.name, 'as', typeString(node.type))
    def visit_TypeDecl(self, node):
        for c_name, c in node.children():
            if type(c) is c_ast.Enum:
                self.print_Enum(c, node.declname)
            elif type(c) is c_ast.Struct:
                self.print_Struct(c, node.declname)

            elif type(c) is c_ast.TypeDecl:
                print("fn")

    def visit_Decl(self, node):
        for c_name, c in node.children():
            if type(c) is c_ast.FuncDecl:
                print(node.name + " fn(", end="")
                if c.args:
                    for i, n in enumerate(c.args.params):
                        if i < len(c.args.params) - 1:
                            print(n.name, typeString(n.type)+", ", end ="")
                        else:
                            print( n.name, typeString(n.type), end ="")

                print(")", end = "") 
                print(typeString(c.type))

            if type(c) is c_ast.Struct:
                self.print_Struct(c, c.name)



    def print_Enum(self, node, name):
        print(name, "enum {")
        for v in node.values.enumerators:
            if v.value:
                print("\t"+v.name, "=", v.value.value)
            else:
                print("\t"+v.name)

        print("}")

    def print_TypeDecl(self, node):
        print(node.name, typeString(node.type))

    def print_Struct(self, node, name):
        if node.decls == None:
            print(name, "struct ")
            return

        print(name, "struct {")
        
        for c_name, c in node.children():
            print("\t", end="") 
            self.print_TypeDecl(c)

        print("}")

if __name__ == "__main__":
    if len(sys.argv) > 1:
        filename  = sys.argv[1]
    else:
        filename = 'examples/c_files/memmgr.c'
    print(filename)

    cpp_path='clang'
    args=['-E', r'-I/Users/Davie/Desktop/dl/Tools/fake_libc_include']

    for it in range(2,len(sys.argv)):
        args.append(sys.argv[it])

    print(args)
    # Note that cpp is used. Provide a path to your own cpp or
    # make sure one exists in PATH.
    ast = parse_file(filename, use_cpp=True, cpp_path = cpp_path, cpp_args= args)
    v = FuncDefVisitor()
    v.visit(ast)


