//
//  Quaternion.dl
//  Created by David on 6/24/16.
//
@import {
    'Vec.dl'
}
Quaternion struct
{            
    w f32
    x f32
    y f32
    z f32
}
    
GetRotationMatrix fn(q Quaternion) Mat4
{
    r Mat4
    r[0][0] = 1 - 2*q.y*q.y - 2*q.z*q.z
    r[0][1] = 2*q.x*q.y + 2*q.w*q.z
    r[0][2] = 2*q.x*q.z - 2*q.w*q.y
    r[0][3] = 0
    
    r[1][0] = 2*q.x*q.y - 2*q.w*q.z
    r[1][1] = 1 - 2*q.x*q.x-2*q.z*q.x
    r[1][2] = 2*q.y*q.z+2*q.w*q.x
    r[1][3] = 0

    r[2][0] = 2*q.x*q.z + 2*q.w*q.y
    r[2][1] = 2*q.y*q.z - 2*q.w*q.x
    r[2][2] = 1 - 2*q.x*q.x - 2*q.y*q.y
    r[2][3] = 0
    
    r[3][0] = 0
    r[3][1] = 0
    r[3][2] = 0
    r[3][3] = 1
    
    return r
}

CreateQuaternion fn(axis Vec3, angle f32) Quaternion
{
    r Quaternion
    r.w = cos(angle/2)
    r.x = axis.x * sin(angle/2)
    r.y = axis.y * sin(angle/2)
    r.z = axis.z * sin(angle/2)
    return r
}

CreateQuaternion fn() Quaternion
{
    r Quaternion
    r.w = 1.0
    r.x = 0
    r.y = 0
    r.z = 0
    return r
}

normalize fn(v ref Quaternion)
{
    magnitude f32 = sqrt(v.w*v.w + v.x*v.x + v.y*v.y + v.z*v.z)
    v.w = v.w / magnitude
    v.x = v.x / magnitude
    v.y = v.y / magnitude
    v.z = v.z / magnitude
}

mul fn(lhs Quaternion, rhs Quaternion) Quaternion
{
    r Quaternion
    r.w = (lhs.w * rhs.w - lhs.x * rhs.x - lhs.y * rhs.y - lhs.z * rhs.z)
    r.x = (lhs.w * rhs.x + lhs.x * rhs.w + lhs.y * rhs.z - lhs.z * rhs.y)
    r.y = (lhs.w * rhs.y - lhs.x * rhs.z + lhs.y * rhs.w + lhs.z * rhs.x)
    r.z = (lhs.w * rhs.z + lhs.x * rhs.y - lhs.y * rhs.x + lhs.z * rhs.w)
    return r
}
