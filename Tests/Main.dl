

@import {
	'dl/Array.dl',
	'dl/String.dl',
	'glfw.dl',
	'gl.dl',
	'Vec.dl',
	'World.dl',
	'Renderer.dl',
	'Archive.dl',
}

@build {
	link = (		
		'-framework OpenGL',
		'-framework Cocoa',
		'-framework IOKit',
		'-framework CoreVideo',
		'libchipmunk.a', 
		'libglfw3.a', 
		'libspine.a', 
		'libstb.a',
	)
}
@extern {
	abort fn()
}


Load fn(file str, scene ref Scene)
{    
    archive Archive = Unarchive(file)
   	Println('Size:' + String(archive.array.length))

    for i64(0) .. archive.array.length {

        entity Entity = CreateEntity()
        //Editable(entity)
        
        Println('Entity ' + String(entity.id))

        if true {
            arch Archive = archive.array[it]['Sprite']
            if arch.Type != ArchiveNone {
                s Sprite^ = Sprite(entity, ^(scene.renderer), arch['Texture'].string)
                s.material.shader = Shader(^(scene.renderer), arch['Vertex'].string, arch['Fragment'].string)
                Load(arch['Color'], s.color)
                Color(^s, s.color)
                Println('Sprite')
                Println(String(s.color))
                Println(s.material.shader.vs)
                Println(s.material.shader.fs)
                Println(s.material.texture.file)
            }
        }
        if true {
            arch Archive = archive.array[it]['Transform']
            if arch.Type != ArchiveNone {
                t Transform^ = Transform(entity)
                Load(arch['Position'], t.position)
                Load(arch['Scale'], t.scale)  
                Println('Transform')
                Println(String(t.position))
                Println(String(t.scale))
                Recalculate(^t)
            }       
        }
    }
}

Scene struct {
    renderer Renderer^
    window Window^
    camera Camera^
}

Test fn(t i32) {
    Println(String(t) + 'OOH a func ptr')
}

Main fn() i32 {

    call Callback(i32)
    call.func = Test

	glfwInit()
	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3)
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3)
    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, 1)
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE)

	glfwwindow GLFWwindow^ = glfwCreateWindow(800, 400, 'Min'.chars, cast(GLFWmonitor^,0), cast(GLFWwindow^, 0))
    glfwMakeContextCurrent(glfwwindow)

	if chdir('/Users/Davie/Desktop/Resources'.chars) != 0 {
        Error('Couldnt change directory')
    }

    Init(world)

  	window Window
    window.size = Vec2(800, 400)

    renderer Renderer = Renderer()
    camera Camera = Camera()

    theScene Scene
    theScene.window= &window
    theScene.renderer = &renderer
    theScene.camera = &camera

	scene Texture = Texture(window.size * 2.0)
    occlusion Texture = Texture(window.size * 2.0)

    pass ShadingPass = ShadingPass()
    pass.clear = 1
    Push(pass.out, &scene)
    Push(pass.out, &occlusion)
    Refresh(pass)
    Push(renderer.passes, pass)

    if true {   
        post Shader = Shader(renderer, 'PostProcess.vs', 'Red.fs')

        sprite Sprite = Sprite(renderer, 'images/GrassSmall.png')
        sprite.material.texture = scene
        sprite.material.shader = post

        pass ShadingPass = PostProcess(sprite)
        pass.clear = 1
        Refresh(pass)
        Push(renderer.passes, pass)
    } 
    if true {   
        post Shader = Shader(renderer, 'PostProcess.vs', 'Lighting.fs')
        sprite Sprite = Sprite(renderer, 'images/GrassSmall.png')
        sprite.material.texture = occlusion
        sprite.material.shader = post
        pass ShadingPass = PostProcess(sprite)
        Push(pass.in, &scene)
        Push(pass.in, &occlusion)
        Refresh(pass)
        Push(renderer.passes, pass)
    }

   	Load('data', theScene)


    if true {
        entity Entity = CreateEntity()

        sprite Sprite^ = Sprite(entity, renderer, 'images/GrassSmall.png')
        sprite.material.shader = Shader(renderer, 'Position.vs', 'Shader.fs')

        t Transform^ = Transform(entity)
        Scale(^t, Vec3(50.0))
        Position(^t, Vec3(1, 40.0, 0))
    }

    glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA)
    glBlendFuncSeparatei(1, GL_ONE, GL_ONE, GL_ONE, GL_ONE_MINUS_SRC_ALPHA)
    glEnable(GL_BLEND)

    for !glfwWindowShouldClose(glfwwindow)
    {
        glClear(GL_COLOR_BUFFER_BIT)
        glClearColor(0, 0, 0, 0)

        theScene.camera.projection = Perspective(theScene.camera.fieldOfView, theScene.window.size.x/theScene.window.size.y, theScene.camera.near, theScene.camera.far)
        theScene.camera.viewProjection = theScene.camera.projection * theScene.camera.view
        Render(renderer, world, camera, window)
    
        glfwSwapBuffers(glfwwindow)
        glfwPollEvents()
    }
	return 5
}

// Control fn() {
// 	// if true
// 	// {

// 	// }
// 	// else if false
// 	// {

// 	// }
// 	// else {

// 	// }


// 	// for 0 .. 5 {

// 	// }

// 	// for false {

// 	// }

// 	// for (1, 2, 3) {

// 	// }
// }