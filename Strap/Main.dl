

@import {
	'dl/Array.dl',
	'dl/String.dl',
    'Lexer.dl',
    'Ast.dl',
    'Print.dl',
    'Semantic.dl',
    'Intrinsic.dl',
    'Generate.dl',
}

Error struct {
    message str
    at Position
}

errors DynamicArray(Error)

ParseBasicBlock fn(lexer ref Lexer) Block^ {
    lexer.Expect(kBracketOpen)
    block Block^ = Block()
    for true
    {
        expr Expr^
        if !expr {
            expr = &lexer.ParseVariable().super
        }
        if !expr {
            expr = lexer.ParseExpression()
        }

        if !expr
        {
            lexer.Expect(kBracketClose)
            return block
        }
        block.Add(expr)
    }
}

ParseFunction fn (lexer ref Lexer) Function^
{
    if lexer.At(1) == kFunction && (
            lexer.At(0) == kIdentifier ||
            lexer.At(0) == kMultiply ||
            lexer.At(0) == kPlus
        )
    {
        self Function^ = Function()
        if lexer.At(0) == kIdentifier {
            self.ident = lexer.At(0).value
        }
        else {
            self.ident = TokenString(lexer.At(0).Type)
        }
        lexer.Eat(2)

        lexer.Expect(kParenOpen)
        for lexer.At(0) != kParenClose {

            expr Expr^ = &lexer.ParseVariable().super
            Assert(expr, 'Expected variable ' + TokenString(lexer.At(0).Type) + TokenString(lexer.At(1).Type))
            self.params.Add(expr)
            if lexer.At(0) != kParenClose 
            {
                lexer.Expect(kComma)
            }
        }
        lexer.Expect(kParenClose)
        if lexer.At(0) != kBracketOpen {
            self.result = lexer.ParseType()
        }
        self.block = lexer.ParseBasicBlock()
        return self
    }
    return cast(Function^, 0)
}

ParseStructure fn (lexer ref Lexer) Structure^
{
    if lexer.At(1) == kStruct && lexer.At(0) == kIdentifier
    {
        structure Structure^ = Structure()
        structure.ident = lexer.At(0).value
        lexer.Eat(2)

        if lexer.At(0) == kSemicolon || lexer.At(0) == kEndLine {
            lexer.Eat(1)
            structure.incomplete = true
            return structure
        }

        lexer.Expect(kBracketOpen)

        for lexer.At(0) != kBracketClose {
            field Variable^ = lexer.ParseField()
            structure.Add(field)
        }

        lexer.Expect(kBracketClose)

        return structure
    }

    return cast(Structure^, 0)
}

ParsePointers fn(lexer ref Lexer, typ ref Type) Type^{

    ret Type^ = &typ

    for lexer.At(0) == kCaret {
        typ TypePointer^ = New(TypePointer)
        typ.pointed = ret
        ret = &typ.super
        lexer.Eat(1)
    }
    return ret
}

ParseType fn(lexer ref Lexer) Type^ {

    if lexer.At(0) == kIdentifier {
        typ TypeIdentifier^ = TypeIdentifier()
        typ.ident = lexer.At(0).value
        lexer.Eat(1)
        
        //if lexer.At(0) == kParenOpen {
        //    generic TypeGeneric^ = New(TypeGeneric)
        //    generic.ident = typ
        //    lexer.Eat(1) // eat (

        //    for true
        //    {
        //        generic.constraints.Push(lexer.ParseType())
        //        if lexer.At(0) == kComma {
        //            lexer.Eat(1)
        //        }
        //        else
        //        {
        //            lexer.Expect(kParenClose)
        //            return &generic.super
        //        }
        //    }
        //}
        return lexer.ParsePointers(typ.super)
    }
    if lexer.At(0) == kDollar {
        lexer.Eat(1)
        if lexer.At(0) != kIdentifier {
            Error('Expected identifier after $', lexer.At(0).at)
        }
        typ TypeIdentifier^ = TypeIdentifier()
        typ.ident = lexer.At(0).value
        lexer.Eat(1)

        return lexer.ParsePointers(typ.super)
    }
   
    return cast(Type^, 0)
}

ParseField fn(lexer ref Lexer) Variable^ {
    
    field Variable^ = Variable()
    field.ident = lexer.At(0).value
    lexer.Eat(1)

    field.super.typ = lexer.ParseType()
    Assert(cast(i64, field.super.typ) != 0, 'nil type Field is: ' + field.ident)
    lexer.ExpectEndStatement()
    return field
}

ParseVariable fn(lexer ref Lexer) Variable^ {
    
    if lexer.At(0) == kIdentifier && lexer.At(1) == kIdentifier
    {
        variable Variable^ = Variable()
        variable.ident = lexer.At(0).value
        lexer.Eat(1)

        variable.super.typ = lexer.ParseType()
        lexer.ExpectEndStatement()
        return variable
    }
    return cast(Variable^, 0)
}
ParseOperand fn(lexer ref Lexer, precedence i32) Expr^
{
    if lexer.At(0) == kIdentifier {
        operand Identifier^ = Identifier()
        operand.ident = lexer.At(0).value
        lexer.Eat(1)
        return &operand.super
    }
    return cast(Expr^, 0)
}

IsOperator fn(token Token) i8 {
    return token == kPlus || token == kMinus || token == kMultiply || token == kDivide 
}
Precedence fn(token Token) i32 {
    //if token == kOrOr {
    //    return 1
    //}
    //if token == kAndAnd {
    //    return 2
    //}

    //if token == kEqual || token == kLess  || token == kLessEq  || token == kGreater  || token == kNotEqual 
    //{
    //    return 3
    //}

    if token == kPlus || token == kMinus //  || token == kAnd  || token == kOr 
    {
        return 4
    }

    if token == kMultiply || token == kDivide//  || token == kMod 
    {
        return 5
    }

    Assert(0, 'Uknown precedence for token, ' +  TokenString(token.Type))
    return 0
}
ParseExpression fn(lexer ref Lexer, precedence i32) Expr^
{
    left Expr^ = ParseOperand(lexer, precedence)

    for left
    {
        if lexer.At(0).IsOperator() {

            nextPrecedence i32 = lexer.At(0).Precedence()

            if (nextPrecedence < precedence) 
            {
                return left
            }

            op Call^ = Call()
            identifier Identifier^ = Identifier()
            identifier.ident = TokenString(lexer.At(0).Type)
            op.operand = &identifier.super
            lexer.Eat(1)
        
            right Expr^ = ParseExpression(lexer, nextPrecedence + 1)
            Assert(left, 'Expected left')
            Assert(right, 'Expected right')

            op.params.Add(left)
            op.params.Add(right)
            left = &op.super
        }
        else {
            return left
        }
    }
    return left
}
ParseExpression fn(lexer ref Lexer) Expr^
{
    expr Expr^ = ParseExpression(lexer, 0)
    if expr {
        lexer.ExpectEndStatement()
    }
    return expr
}


Error fn(message str, at Position)
{
    error Error
    error.message = message
    error.at = at
    errors.Push(error)
    if errors.length == 1
    {
        Println(errors[0].message)
    }
}

Expect fn(lexer ref Lexer, token i32) Position
{
    at Position = lexer.At(0).at

    if lexer.At(0) != token
    {
        Error('Expected ' + TokenString(token) + ', found ' + TokenString(lexer.At(0).Type), lexer.At(0).at)
    }
    lexer.Eat(1)
    return at
}

ExpectEndStatement fn(lexer ref Lexer)
{
    if lexer.At(0) == kComma  || lexer.At(0) == kParenClose || lexer.At(0) == kBracketClose {
        return
    }
    if lexer.At(0) != kSemicolon && lexer.At(0) != kEndLine
    {
        Error('Expected ; found ' + TokenString(lexer.At(0).Type), lexer.At(0).at)
    }
    lexer.Eat(1)
}

Parse fn(file str) Block^
{
    lexer Lexer = Lexer(file)
    block Block^ = Block()
    for true 
    {
        expr Expr^
        if !expr {
           expr = &ParseStructure(lexer).super
        }
        if !expr {
           expr = &ParseFunction(lexer).super
        }
        if !expr 
        {
            if lexer.At(0) != kEnd
            {
                Error('Expected end of file, found ' + lexer.At(0).value, lexer.At(0).at)
            }
            return block
        }

        block.Add(expr)
    }
    return cast(Block^, 0)
}

Main fn() i32 {

    block Block^ = Parse('Test.dl')
    
    visit PrintVisitor
    block.super.Visit(visit)

    semantic Semantic
    semantic.Init(^block)

    generate Generate
    generate.Init(semantic, ^block)

    if errors.length
    {
        Println(errors[0].message)
    }
    Println('Finished compiling Test.dl')
    return 0
}

