
@import {
	'Expr.dl',
    '../Semantic.dl',
}

Structure struct 
{
    super Expr
    ident str
    incomplete i8
    
    block Block

    fields DynamicArray(Variable^)
    constraints DynamicArray(Type^)

    specializations DynamicArray(StructureSpec^)
}

Init fn(self ref Structure)
{
    self.super.kind = Id(Structure)
    self.block.Init()
}

Structure fn() Structure^
{
    self Structure^ = new(Structure)
    self.Init()
    return self
}

Add fn(structure ref Structure, field Variable^) {
    structure.fields.Push(field)
}
Lookup fn(structure ref Structure, ident str) Variable^ {
    for i64(0) .. structure.fields.length {
        if Equal(structure.fields[it].ident, ident) {
            return structure.fields[it]
        }
    }
    return cast(Variable^, 0)
}
StructureSpec struct {
    super Expr
    structure Structure^
    constraints DynamicArray(Type^)
}

Init fn(self ref StructureSpec) {
    self.constraints.Init()
    self.super.kind = Id(StructureSpec)
}

Specialize fn(self ref Structure, constraints ref DynamicArray(Type^)) StructureSpec^ {

    for i64(0) .. self.specializations.length {
        if Equal(self.specializations[it].constraints, constraints) {
            spec StructureSpec^ = self.specializations[it]
            Println('Specializing: ' + self.ident)
            PrintTabs(1)
            Print('found')
            PrintTabs(1)
            Print(self.ident)
            Print('(')
            Print(constraints)
            Println(')\n')
            return spec
        }
    }
    Println('Specializing : ' + self.ident)
    PrintTabs(1)
    Print(self.ident)
    Print('(')
    Print(constraints)
    Println(')\n')
    spec StructureSpec^ = New(StructureSpec)
    spec.structure = &self
    spec.constraints = constraints
    self.specializations.Push(spec)
    return spec
}
