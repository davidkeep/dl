
@import {
	'Expr.dl',
    '../Print.dl',
    '../Semantic.dl',
    'Incomplete.dl',
}

gNextFnIndex i32
gSpecializations DynamicArray(FunctionSpec^)

Function struct 
{
    super Expr

    ident str

    block Block^

    params ExpressionList
    result Type^ 

    //Generic functions only
    spec FunctionSpec^
    any DynamicArray(TypeAny^)
    specializations DynamicArray(FunctionSpec^)
}

Init fn(self ref Function)
{
    self.super.kind = Id(Function)
    self.params.Init()
    self.any.Init()
    //self.incompleteCalls.Init()
    //self.incCalls.Init()
}

Function fn() Function^
{
    self Function^ = new(Function)
    self.Init()
    return self
}

FunctionSpec struct {
    super Expr
    function Function^
    types TypeList

    index i64
    incomplete i8     // Incomplete must be specialized once parent function is resolved
    any DynamicArray(Type^)
    known DynamicArray(TypeAnyResolved)
}


AddAny fn(self ref Function, any TypeAny^) {
    self.any.Push(any)
    if self.block {
        as TypeAs^ = New(TypeAs)
        as.super.typ = &any.super
        as.ident = any.ident
        self.block.Declare(as.super)
    }
}

Specialize fn (self ref Function, call Call^, parent Function^, known ref Known) FunctionSpec^
{
   return Specialize(self, call, parent, known, 1)
}

Specialize fn (self ref Function, call Call^, parent Function^, known ref Known, level i32) FunctionSpec^
{
    verbose i8
    spec FunctionSpec^ = New(FunctionSpec)
    self.specializations.Push(spec)
    gSpecializations.Push(spec)

    spec.function = &self
    spec.index = self.specializations.length

    for i64(0) .. known.known.length {
        t TypeAnyResolved = known.known[it]
        if t.typ.Resolved().Is(TypeAny) {
            if verbose {
                Print('Call must be specialized')
            }
            spec.incomplete = true
        }
        spec.types.list.Push(t.typ.Resolved())
    }

    

    if verbose {
        if level == 1 {
            Print('Specializing: in ')
            Println(parent.ident)
        }
        PrintTabs(level)
        Print(self.ident)
        Print(' fn')
        Print(self.params.super)
        PrintTabs(1)
    }


    for i64(0) .. known.known.length {
        t TypeAnyResolved = known.known[it]
        for i64(0) .. self.any.length {
            any TypeAny^ = self.any[it]
            if any == t.any {
                if verbose {
                    Print(any.super)
                    Print(' = ')
                    Print(^t.typ)
                    Print(' ')
                }
               // any.reference = t.typ
                tt TypeAnyResolved
                tt.any = any
                tt.typ = t.typ
                spec.any.Push(t.typ)
                spec.known.Push(t)
            }
        }
    }
    //spec.Apply()
    return spec
}

Init fn(self ref FunctionSpec)
{
    self.super.kind = Id(FunctionSpec)
    self.types.Init()
    self.any.Init()
}

Apply fn(self ref FunctionSpec) {
    self.function.spec = &self
    //Assert(self.function.any.length == self.any.length, 'any mismatch')
    for i64(0) .. self.known.length {
        t TypeAnyResolved = self.known[it]
        t.any.reference = t.typ
    }
}

Clear fn(self ref FunctionSpec) {
    self.function.spec = cast(FunctionSpec^, 0)
    for i64(0) .. self.known.length {
        t TypeAnyResolved = self.known[it]
        t.any.reference = cast(Type^, 0)
    }
}

Known struct {
    known DynamicArray(TypeAnyResolved)
}
Add fn(self ref Known, any TypeAny^, typ Type^) i8 {
    t TypeAnyResolved
    t.any = any
    t.typ = typ
    for i64(0) .. self.known.length {
        if cast(i64, self.known[it].any) == cast(i64, any)
        {
            if !Equal(self.known[it].typ, typ) {
                return false
            }
        }
    }
    self.known.Push(t)
    return true
}

TypeAnyResolved struct {
    any TypeAny^
    typ Type^
}
