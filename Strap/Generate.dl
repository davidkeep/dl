@import {
	'Semantic.dl',
}


Generate struct {
	semantic Semantic^

	header File^
	impl File^
	indent i32
	remapped Table(str, str)
}
Indent fn(self ref Generate) {
	for i32(0) .. self.indent {
		self.impl.Write('\t')
	}
}

Mangle fn(self Type^) str {
	t Type ^ = self.Resolved()
	if t.Is(TypeType) {
		return '_typeof' + Mangle(t.As(TypeType).reference)
	}
	if t.Is(TypeIdentifier) {
		return '_' + t.As(TypeIdentifier).spec.As(Structure).Name()
	}
	return ''
}

Name fn(self ref Structure) str {
	out str = self.ident
	for i64(0) .. self.constraints.length {
		out = out + Mangle(self.constraints[it])
	}
	return out
}

Name fn(self ref Function) str {
	out str = self.ident
	if self.block {
		for i64(0) .. self.params.list.length {
			out = out + Mangle(self.params.list[it].typ)
		}
	}
	return out
}

Init fn(generate ref Generate, semantic ref Semantic, ast ref Block) {
	
	generate.semantic = &semantic
	generate.header = FileOpen('build/strap.h'.chars, 'w'.chars)
	generate.impl = FileOpen('build/strap.c'.chars, 'w'.chars)
	Assert(cast(i64, generate.header) != 0, 'Bad file')
	Assert(cast(i64, generate.header) != 0, 'Bad file')

	generate.remapped.Init()
	generate.remapped['*'] = '_mul_'
	generate.remapped['+'] = '_add_'
	generate.remapped['Main'] = 'main'


	generate.impl.Write('#include "strap.h"\n')
	generate.header.Write('#include "../dl/header.h"\n')

	for i64(0) .. ast.expressions.length {
		expr Expr^ = ast.expressions[it]
		generate.Visit(^expr)
	}

	for i64(0) .. gSpecializations.length {
		spec FunctionSpec^ = gSpecializations[it]
		if !spec.incomplete 
		{
			spec.Apply()
			generate.semantic.Visit(spec.function.super)
			generate.Visit(spec.function.super)
		}
	}
	FileClose(generate.header)
	FileClose(generate.impl)
}

Write fn(file ref File, s str) {
	FilePut(&file, s.chars)
}

Visit fn(file ref File, t ref Type) {
	typ Type^ = t.Resolved()

	if typ.Is(TypeOption) {
		self TypeOption^ = typ.As(TypeOption)
		if self.reference.Is(TypeRef) {
			file.Visit(^self.reference)
		}
		else {
			file.Write('OPTION')
		}
	
		return
	}
	if typ.Is(TypeRef) {
		self TypeRef^ = typ.As(TypeRef)
		file.Visit(^self.reference)
		file.Write('*')
		return
	}
	if typ.Is(TypeIdentifier) {
		self TypeIdentifier^ = typ.As(TypeIdentifier)

		file.Write(self.spec.As(Structure).Name())
		return
	}
	if typ.Is(TypeGeneric) {
		self TypeGeneric^ = typ.As(TypeGeneric)
		file.Write(self.ident.ident)
		file.Write('_')
		for i64(0) .. self.constraints.length {
			file.Visit(^self.constraints[it])
		}
		return
	}
	file.Write('unknown type - ' + String(typ.kind))
} 


Visit fn(generate ref Generate, expr ref Expr) 
{
	if expr.Is(Block) {
		generate.Indent()
		generate.impl.Write('{\n')
		self Block^ = expr.As(Block)
		generate.indent = generate.indent + 1
		for i64(0) .. self.expressions.length {
			expr Expr^ = self.expressions[it]
			generate.Indent()
			generate.Visit(^expr)
			generate.impl.Write(';\n')
		}
		generate.indent = generate.indent - 1
		generate.Indent()
		generate.impl.Write('}')

		return
	}
	if expr.Is(Structure) {
		self Structure^ = expr.As(Structure)
		ident str = generate.remapped[self.ident]
		if ident.length == 0 {
			ident = self.ident
		}

		if !self.constraints.length {
			generate.header.Write('typedef struct ')
			generate.header.Write(' {\n')

			for i64(0) .. self.fields.length {
				generate.header.Visit(^self.fields[it].super.typ)
				generate.header.Write(' ')
				generate.header.Write(self.fields[it].ident)
				generate.header.Write(';\n')
			}
			generate.header.Write('} ')
			generate.header.Write(ident)
			generate.header.Write(';\n')
		}
		for i64(0) .. self.specializations.length {
			spec StructureSpec^ = self.specializations[it]

			if !spec.incomplete
			{
				self.Apply(^spec)
				//generate.semantic.Visit(self.super)
				generate.header.Write('typedef struct ')
				generate.header.Write(' {\n')

				for i64(0) .. self.fields.length {
					generate.header.Visit(^self.fields[it].super.typ)
					generate.header.Write(' ')
					generate.header.Write(self.fields[it].ident)
					generate.header.Write(';\n')
				}
				generate.header.Write('} ')
				generate.header.Visit(^self.super.typ.As(TypeType).reference)
				generate.header.Write(';\n')
			}
		}
		return
	}
	if expr.Is(Function) {
		self Function^ = expr.As(Function)
		if generate.semantic.intrinsic.IsIntrinsic(self) 
		{
			return
		}
		
		ident str = generate.remapped[self.ident]
		if ident.length == 0 {
			ident = self.Name()
		}

		if self.any.length == 0 || cast(i64, self.spec) != 0 {

			if self.result {
				generate.header.Visit(^self.result)
				generate.header.Write(' ')
			}
			else {
				generate.header.Write('void ')
			}		
			generate.header.Write(ident)
			if self.spec {
				generate.header.Write(String(self.spec.index))
			}
			generate.header.Write('(')
			last i64 = self.params.list.length-1
			for last > 0 && self.params.list[last].typ.Is(TypeType)
			{
				last = last - 1
			}

			for i64(0) .. self.params.list.length {
				if !self.params.list[it].typ.Is(TypeType) 
				{
					generate.header.Visit(^self.params.list[it].typ)
					generate.header.Write(' ')
					generate.header.Write(self.params.list[it].As(Variable).ident)

					if it != last {
						generate.header.Write(', ')
					}
				}
			}
			generate.header.Write(');\n')
			if self.block {
				if self.result {
					generate.impl.Visit(^self.result)
					generate.impl.Write(' ')
				}
				else {
					generate.impl.Write('void ')
				}
				generate.impl.Write(ident)
				if self.spec {
					generate.impl.Write(String(self.spec.index))
				}
				generate.impl.Write('(')
				for i64(0) .. self.params.list.length {
					if !self.params.list[it].typ.Is(TypeType) 
					{
						generate.impl.Visit(^self.params.list[it].typ)
						generate.impl.Write(' ')
						generate.impl.Write(self.params.list[it].As(Variable).ident)

						if it != last {
							generate.impl.Write(', ')
						}
					}
				}
				generate.impl.Write(')')
				generate.Visit(self.block.super)
				generate.impl.Write('\n')
			}
		}
		return
	}
	if expr.Is(Call) 
	{
		self Call^ = expr.As(Call)
		//for i64(0) .. self.params.list.length {
		//		generate.impl.Visit(^self.params.list[it].typ)
		//		if it != self.params.list.length-1 {
		//			generate.impl.Write(',')
		//		}
		//	}
		//	generate.impl.Write('\n')

		last i64 = self.params.list.length-1
		for last > 0 && self.params.list[last].typ.Is(TypeType)
		{
			last = last - 1
		}
		if self.func.Is(Function) 
		{
			function Function^ = self.func.As(Function)
			if generate.semantic.intrinsic.IsIntrinsic(function) 
			{
				generate.GenerateIntrinsic(function, &self.params)
			}
			else 
			{
				name str = generate.remapped[function.ident]
				if name.length == 0 {
					name = function.Name()
				}

				generate.impl.Write(name)
				generate.impl.Write('(')
				for i64(0) .. self.params.list.length 
				{
					if !self.params.list[last].typ.Is(TypeType) 
					{
						generate.Visit(^self.params.list[it])
						if it != last 
						{
							generate.impl.Write(',')
						}
					}
				}
				generate.impl.Write(')')
			}
		}
		else if self.func.Is(FunctionSpec) 
		{
			spec FunctionSpec^ = self.func.As(FunctionSpec)
			function Function^ = spec.function
			if generate.semantic.intrinsic.IsIntrinsic(function) 
			{
				generate.GenerateIntrinsic(function, &self.params)
			}
			else 
			{
				name str = generate.remapped[function.ident]
				if name.length == 0 {
					name = function.Name()
				}

				generate.impl.Write(name)
				generate.impl.Write(String(spec.index))
				generate.impl.Write('(')
				for i64(0) .. self.params.list.length 
				{
					if !self.params.list[last].typ.Is(TypeType) 
					{
						generate.Visit(^self.params.list[it])
						if it != last 
						{
							generate.impl.Write(',')
						}
					}
				}
				generate.impl.Write(')')
			}
		}
		else {
			Assert(0, 'Expected fn or fn spec ' + String(self.operand.kind))
		}
		return
	}
	if expr.Is(Variable) {
		self Variable^ = expr.As(Variable)
		if !self.super.typ.Is(TypeType) 
		{
			generate.impl.Visit(^self.super.typ)
			generate.impl.Write(' ')
			generate.impl.Write(self.ident)
			if self.assign {
				generate.impl.Write('=')
				generate.Visit(^self.assign)
			}
			else {
				generate.impl.Write('={0}')
			}
		}
		return
	}
	if expr.Is(ForList) {
		self ForList^ = expr.As(ForList)

		for i64(0) .. self.list.list.length {
			generate.semantic.SetIt(^self, self.list.list[it])
			generate.impl.Write('/*ForList ' + String(it) + '*/')
			self.it.assign = self.list.list[it]
			self.it.super.typ = self.list.list[it].typ
			Assert(self.it.super.typ)
			//generate.Visit(self.it.super)
			generate.Visit(self.block.super)
		}
		//generate.impl.Write(' ')
		//generate.impl.Write(self.ident)
		return
	}
	if expr.Is(For) {
		self For^ = expr.As(For)

		if self.to {
			generate.impl.Write('for(')
			self.it.assign = self.from
			generate.Visit(self.it.super)
			generate.impl.Write('; it < ')
			generate.Visit(^self.to)
			generate.impl.Write('; it++)')
		}
		else {
			generate.impl.Write('while(')
			generate.Visit(^self.from)
			generate.impl.Write(')')
		}
		

		generate.Visit(self.block.super)
		//generate.impl.Write(' ')
		//generate.impl.Write(self.ident)
		return
	}
	if expr.Is(Identifier) {
		self Identifier^ = expr.As(Identifier)
		generate.impl.Write(self.ident)
		return
	}
	if expr.Is(Access) {
		self Access^ = expr.As(Access)
		generate.Visit(^self.operand)
		generate.impl.Write('.')
		generate.Visit(^self.field)
		return
	}
	if expr.Is(Assign) {
		self Assign^ = expr.As(Assign)
		for i32(0) .. self.drefCount {
			generate.impl.Write('*')
		}
		generate.Visit(^self.left)
		generate.impl.Write('=')
		generate.Visit(^self.right)
		return
	}
	if expr.Is(Trait) {
		self Trait^ = expr.As(Trait)
		return
	}
	if expr.Is(NumberConstant) {
		self NumberConstant^ = expr.As(NumberConstant)
		generate.impl.Write(self.value)
		return
	}
	if expr.Is(StringConstant) {
		self StringConstant^ = expr.As(StringConstant)
		generate.impl.Write('((i8*)"')
		generate.impl.Write(self.value)
		generate.impl.Write('")')
		return
	}
	generate.impl.Write('---- unhandled node ' + String(expr.kind) + '---- \n')
}

GenerateIntrinsic fn(generate ref Generate, function Function^, args ExpressionList^) {
	if 	cast(i64, &generate.semantic.intrinsic.reference) == cast(i64, function)
	{
		generate.impl.Write('(&')
		generate.Visit(^args.list[0])
		generate.impl.Write(')')
		return
	}
	if 	cast(i64, &generate.semantic.intrinsic.dereference) == cast(i64, function)
	{
		generate.impl.Write('(*')
		generate.Visit(^args.list[0])
		generate.impl.Write(')')
		return
	}

	if 	cast(i64, &generate.semantic.intrinsic.castOp) == cast(i64, function)
	{
		generate.impl.Write('(')
		generate.Visit(^args.list[0])
		generate.impl.Write(')')
		generate.Visit(^args.list[1])
		return
	}

	generate.impl.Write('(')
	generate.Visit(^args.list[0])
	generate.impl.Write(function.ident)
	generate.Visit(^args.list[1])
	generate.impl.Write(')')
	return

	//generate.impl.Write('----unhandled intrinsic-----')
}
