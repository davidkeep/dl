@import {
	'Ast.dl',
	'Intrinsic.dl',
	'Print.dl',
}

Semantic struct {
	intrinsic Intrinsics
	scopes DynamicArray(Block^)
}

Init fn(semantic ref Semantic, ast ref Block)
{
	semantic.scopes.Push(&ast)

    semantic.intrinsic.Init(semantic, ast)

	for i64(0) .. ast.expressions.length {
		expr Expr^ = ast.expressions[it]
		semantic.Declare(^expr)
	}

	semantic.Visit(ast.super)
	semantic.scopes.Pop()
}

FindPrivate fn(semantic ref Semantic, ident str) Expr^ {
	for i64(0) .. semantic.scopes.length {
		scope Block^ = semantic.scopes[semantic.scopes.length - it - 1]
		expr Expr^ = scope.Lookup(ident)
		if expr {
			return expr
		}
	}
	return cast(Expr^, 0)
}

FindType fn(semantic ref Semantic, ident str) Expr^ {
	expr Expr^ = semantic.FindPrivate(ident)
	Assert(expr, 'No known type named ' + ident)
	return expr
}
FindVariable fn(semantic ref Semantic, ident str) Expr^ {
	expr Expr^ = semantic.FindPrivate(ident)
	Assert(expr, 'No known variable named ' + ident)
	return expr
}
FindMatch fn(semantic ref Semantic, ident str, args ref ExpressionList) TypeFunctions^ 
{
	for i64(0) .. semantic.scopes.length 
	{
		scope Block^ = semantic.scopes[semantic.scopes.length - it - 1]
		expr TypeFunctions^ = scope.LookupFns(ident)
		if expr 
		{
			return expr
		}
	}
	Assert(0, 'No known function named ' + ident)
	return cast(TypeFunctions^, 0)
}

Declare fn(semantic ref Semantic, expr ref Expr) {
	if expr.Is(Structure) {
		self Structure^ = expr.As(Structure)
		semantic.scopes.Last().Insert(self.ident, &expr)
	}
	else if expr.Is(Function) {
		self Function^ = expr.As(Function)
		semantic.scopes.Last().InsertFn(self.ident, self)
	}
	else if expr.Is(Variable) {
		self Variable^ = expr.As(Variable)
		semantic.scopes.Last().Insert(self.ident, &expr)
	}
    else if expr.Is(Trait) {
        self Trait^ = expr.As(Trait)
        semantic.scopes.Last().Insert(self.ident, &expr)
    }
	else {
 		Assert(0, 'Expected Structure, Function, Trait, or Variable')
	}
}

Visit fn(semantic ref Semantic, expr ref Expr)
{
	if expr.Is(Block) {
		self Block^ = expr.As(Block)
		semantic.scopes.Push(self)

		for i64(0) .. self.expressions.length {
			expr Expr^ = self.expressions[it]
			semantic.Visit(^expr)
		}
		semantic.scopes.Pop()
		return
	}
	if expr.Is(Structure) {
		self Structure^ = expr.As(Structure)
		return
	}
	if expr.Is(Function) {
		self Function^ = expr.As(Function)
		semantic.Visit(self.block.super)
		semantic.Visit(self.params.super)
		return
	}
	if expr.Is(Variable) {
		self Variable^ = expr.As(Variable)
		semantic.Declare(self.super)
		semantic.Annotate(^self.super.typ)
		return
	}
	if expr.Is(Identifier) {
		self Identifier^ = expr.As(Identifier)
		typ Expr^ = semantic.FindVariable(self.ident)
		self.super.typ = typ.typ
		Assert(self.super.typ, 'Expect type to be non nil')
		return
	}
	if expr.Is(Call) {
		self Call^ = expr.As(Call)
		if self.operand.Is(Identifier) 
		{
			semantic.Visit(self.params.super)

			funcs TypeFunctions^ = semantic.FindMatch(self.operand.As(Identifier).ident, self.params)
			found Function^
			for i64(0) .. funcs.functions.length {
				f Function^ = funcs.functions[it]
				if f.params.list.length != self.params.list.length {

				}
				else {

					matched i8 = 1
					for i64(0) .. f.params.list.length {
						if !Equal(f.params.list[it].typ, self.params.list[it].typ)
						{
							matched = 0
						}
					}
					if matched {
						found = f
					}
				}	
			}
			if !found {
				Print(self.operand.As(Identifier).ident)
				Print('(')
				for i64(0) .. self.params.list.length {
					Print(^self.params.list[it].typ)
					if(it != self.params.list.length - 1) {
						Print(', ')
					}
				}
				Println(')')
				Assert(0, 'No match for function: ' + self.operand.As(Identifier).ident)
			}
			self.operand = &found.super
			self.super.typ = found.result
		}
		else
		{
			Assert(0, 'Call without identifier as operand')
		}
		return
	}

	if expr.Is(ExpressionList) {
		self ExpressionList^ = expr.As(ExpressionList)
		Assert(self, 'nil')
		for i64(0) .. self.list.length {
			Assert(self.list[it], 'nil item in list')

			semantic.Visit(^self.list[it])
			Assert(self.list[it].typ, 'Type should be non nil')
		}
		return
	}
    if expr.Is(Trait) {
        self Trait^ = expr.As(Trait)
        return
    }
	Println('Unhandled visit ' + String(expr.kind))
}

Annotate fn(semantic ref Semantic, typ ref Type)
{
	if typ.Is(TypePointer) {
		self TypePointer^ = typ.As(TypePointer)
		semantic.Annotate(^self.pointed)
		return
	}
	if typ.Is(TypeIdentifier) {
		self TypeIdentifier^ = typ.As(TypeIdentifier)
		self.spec = semantic.FindType(self.ident)
		return
	}
	Assert(0, 'Can only annotate a type')
}

// Strips of typedefs etc to get to the true underlying type
Resolved fn(typ ref Type) Type^ {
	return &typ
}
Apply fn(argument Type^, parameter Type^) i8 {
	arg Type^ = argument.Resolved()
	param Type^ = parameter.Resolved()
	return false
}

Equal fn(from Type^, to Type^) i8 {

	f Type^ = from.Resolved()
	t Type^ = to.Resolved()

	if f.kind != t.kind {
		return false
	}

	if f.Is(TypePointer) {
		fPtr TypePointer^ = f.As(TypePointer)
		tPtr TypePointer^ = t.As(TypePointer)
		return Equal(fPtr.pointed, tPtr.pointed)
	}

	if f.Is(TypeIdentifier) {
		fIdent TypeIdentifier^ = f.As(TypeIdentifier)
		tIdent TypeIdentifier^ = t.As(TypeIdentifier)
		Assert(fIdent.spec, 'f spec nil')
		Assert(tIdent.spec, 't spec nil')
		return cast(i64, fIdent.spec) == cast(i64, tIdent.spec)
	}

	Assert(0, 'Unhandled type in Equal')
	return false
}
