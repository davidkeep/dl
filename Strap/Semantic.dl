@import {
	'Ast.dl',
	'Intrinsic.dl',
	'Print.dl',
}

Semantic struct {
	intrinsic Intrinsics
	scopes DynamicArray(Block^)
}

Init fn(semantic ref Semantic, ast ref Block)
{
	semantic.scopes.Push(&ast)

    semantic.intrinsic.Init(semantic, ast)

	for i64(0) .. ast.expressions.length {
		expr Expr^ = ast.expressions[it]
		semantic.Declare(^expr)
	}

	semantic.Visit(ast.super)
	semantic.scopes.Pop()
}

FindPrivate fn(semantic ref Semantic, ident str) Expr^ {
	for i64(0) .. semantic.scopes.length {
		scope Block^ = semantic.scopes[semantic.scopes.length - it - 1]
		expr Expr^ = scope.Lookup(ident)
		if expr {
			return expr
		}
	}
	return cast(Expr^, 0)
}

FindType fn(semantic ref Semantic, ident str) Expr^ {
	expr Expr^ = semantic.FindPrivate(ident)
	Assert(expr, 'No known type named ' + ident)
	return expr
}
FindVariable fn(semantic ref Semantic, ident str) Expr^ {
	expr Expr^ = semantic.FindPrivate(ident)
	Assert(expr, 'No known variable named ' + ident)
	return expr
}
FindMatch fn(semantic ref Semantic, ident str, args ref ExpressionList) TypeFunctions^ 
{
	for i64(0) .. semantic.scopes.length 
	{
		scope Block^ = semantic.scopes[semantic.scopes.length - it - 1]
		expr TypeFunctions^ = scope.LookupFns(ident)
		if expr 
		{
			return expr
		}
	}
	Assert(0, 'No known function named ' + ident)
	return cast(TypeFunctions^, 0)
}

Declare fn(semantic ref Semantic, expr ref Expr) {
	if expr.Is(Structure) {
		self Structure^ = expr.As(Structure)
		semantic.scopes.Last().Insert(self.ident, &expr)
	}
	else if expr.Is(Function) {
		self Function^ = expr.As(Function)
		semantic.scopes.Last().InsertFn(self.ident, self)
	}
	else if expr.Is(Variable) {
		self Variable^ = expr.As(Variable)
		semantic.scopes.Last().Insert(self.ident, &expr)
	}
    else if expr.Is(Trait) {
        self Trait^ = expr.As(Trait)
        semantic.scopes.Last().Insert(self.ident, &expr)
    }
    else if expr.Is(TypeAs) {
        self TypeAs^ = expr.As(TypeAs)
        semantic.scopes.Last().Insert(self.ident, &expr)
    }
    else if expr.Is(Require) {
    }
	else {
 		Assert(0, 'Expected Structure, Function, Trait, or Variable')
	}
}

Visit fn(semantic ref Semantic, expr ref Expr)
{
	if expr.Is(Block) {
		self Block^ = expr.As(Block)
		semantic.scopes.Push(self)

		for i64(0) .. self.expressions.length {
			expr Expr^ = self.expressions[it]
			semantic.Visit(^expr)
		}
		semantic.scopes.Pop()
		return
	}
	if expr.Is(Structure) {
		self Structure^ = expr.As(Structure)
		semantic.scopes.Push(self.block)
		for i64(0) .. self.constraints.length {
			variable Variable^ = self.fields[it]
			semantic.Declare(variable.super)
			semantic.AnnotateGeneric(^variable.super.typ, ^self)
		}		
		for i64(0) .. self.fields.length {
        	semantic.Annotate(^self.fields[it].super.typ)
 		}
 		semantic.scopes.Pop()
		return
	}
	if expr.Is(Function) {
		self Function^ = expr.As(Function)
		self.block.parent = self
		semantic.scopes.Push(self.block)
		for i64(0) .. self.params.list.length {
			variable Variable^ = self.params.list[it].As(Variable)
			semantic.Declare(variable.super)
			semantic.AnnotateGeneric(^variable.super.typ, ^self)
		}
		semantic.scopes.Pop()
		semantic.Visit(self.block.super)
		return
	}
	if expr.Is(Variable) {
		self Variable^ = expr.As(Variable)
		semantic.Declare(self.super)
		semantic.Annotate(^self.super.typ)
		return
	}
	if expr.Is(Identifier) {
		self Identifier^ = expr.As(Identifier)
		typ Expr^ = semantic.FindVariable(self.ident)
		self.super.typ = typ.typ
		Assert(self.super.typ, 'Expect type to be non nil')
		return
	}
	if expr.Is(Access) {
		self Access^ = expr.As(Access)
		semantic.Visit(^self.operand)
		if self.operand.typ.Resolved().Is(Structure) {
			structure Structure^ = self.operand.typ.Resolved().As(Structure)
			variable Variable^ = structure.Lookup(self.field.As(Identifier).ident)
			if !variable {
				Assert(0, 'Could not find field named ' + self.field.As(Identifier).ident)
			}
			self.super.typ = variable.super.typ
		}
		Println('Access')
		//self.super.typ = typ.typ
		Assert(self.super.typ, 'Access expect type to be non nil')
		return
	}
	if expr.Is(Call) {
		self Call^ = expr.As(Call)
		if self.operand.Is(Identifier) 
		{
			semantic.Visit(self.params.super)

			funcs TypeFunctions^ = semantic.FindMatch(self.operand.As(Identifier).ident, self.params)
			found Function^
			foundKnown Known

			for i64(0) .. funcs.functions.length {
				f Function^ = funcs.functions[it]
				if f.params.list.length == self.params.list.length 
				{
					matched i8 = 1
					known Known
					for i64(0) .. f.params.list.length {
						if !Apply(self.params.list[it].typ, f.params.list[it].typ, known)
						{
							matched = 0
						}
					}
					if matched {
						found = f
						foundKnown = known
					}
				}	
			}
			if !found {
				Print(self.operand.As(Identifier).ident)
				Print('(')
				for i64(0) .. self.params.list.length {
					Print(^self.params.list[it].typ)
					if(it != self.params.list.length - 1) {
						Print(', ')
					}
				}
				Println(')')
				Assert(0, 'No match for function: ' + self.operand.As(Identifier).ident)
			}

			if foundKnown.known.length 
			{
				//Specialize also sets the typ of Call^ 
				//If not we would need to call Apply() to figure out the functions return type
				spec FunctionSpec^ = found.Specialize(self, semantic.scopes.Last().parent, foundKnown)
				Assert(spec)
				self.operand = &spec.super
			}
			else 
			{
				self.operand = &found.super
				self.super.typ = found.result
			}
		}
		else
		{
			Assert(0, 'Call without identifier as operand')
		}
		return
	}

	if expr.Is(ExpressionList) {
		self ExpressionList^ = expr.As(ExpressionList)
		Assert(self, 'nil')
		for i64(0) .. self.list.length {
			Assert(self.list[it], 'nil item in list')

			semantic.Visit(^self.list[it])
			Assert(self.list[it].typ, 'Type should be non nil')
		}
		return
	}
    if expr.Is(Trait) {
        self Trait^ = expr.As(Trait)
        return
    }
	Println('Unhandled visit ' + String(expr.kind))
}

AnnotateGeneric fn(semantic ref Semantic, typ ref Type, spec ref Function)
{
	if typ.Is(TypeAny) {
		self TypeAny^ = typ.As(TypeAny)
		spec.AddAny(self)
		return
	}
	if typ.Is(TypePointer) {
		self TypePointer^ = typ.As(TypePointer)
		semantic.AnnotateGeneric(^self.pointed, spec)
		return
	}
	if typ.Is(TypeIdentifier) {
		self TypeIdentifier^ = typ.As(TypeIdentifier)
		self.spec = semantic.FindType(self.ident)
		return
	}
	if typ.Is(TypeGeneric) {
		self TypeGeneric^ = typ.As(TypeGeneric)
		semantic.AnnotateGeneric(self.ident.super, spec)
		for i64(0) .. self.constraints.length {
			semantic.AnnotateGeneric(^self.constraints[it], spec)
		}
		return
	}
	Assert(0, 'No visitor for type ' + String(typ.kind))
}

Annotate fn(semantic ref Semantic, typ ref Type)
{
	if typ.Is(TypePointer) {
		self TypePointer^ = typ.As(TypePointer)
		semantic.Annotate(^self.pointed)
		return
	}
	if typ.Is(TypeIdentifier) {
		self TypeIdentifier^ = typ.As(TypeIdentifier)
		self.spec = semantic.FindType(self.ident)
		return
	}
	if typ.Is(TypeGeneric) {
		self TypeGeneric^ = typ.As(TypeGeneric)
		semantic.Annotate(self.ident.super)
		for i64(0) .. self.constraints.length {
			semantic.Annotate(^self.constraints[it])
		}
		return
	}
	Assert(0, 'No visitor for type ' + String(typ.kind))
}

// Strips of typedefs etc to get to the true underlying type
Resolved fn(typ ref Type) Type^ {
	if typ.Is(TypeAny) { 
		any TypeAny^ = typ.As(TypeAny)
		if any.reference {
			return any.reference
		}
	}
	return &typ
}

Apply fn(argument Type^, parameter Type^, known ref Known) i8 {
	arg Type^ = argument.Resolved()
	param Type^ = parameter.Resolved()

	if arg.kind == param.kind {

		if arg.Is(TypePointer) 
		{
			argPtr TypePointer^ = arg.As(TypePointer)
			paramPtr TypePointer^ = param.As(TypePointer)

			return Apply(argPtr.pointed, paramPtr.pointed, known)
		}
		if arg.Is(TypeIdentifier) 
		{
			argIdent TypeIdentifier^ = arg.As(TypeIdentifier)
			paramIdent TypeIdentifier^ = param.As(TypeIdentifier)
			return cast(i64, argIdent.spec) == cast(i64, paramIdent.spec)
		}
		if arg.Is(TypeGeneric) 
		{
			argGen TypeGeneric^ = arg.As(TypeGeneric)
			paramGen TypeGeneric^ = param.As(TypeGeneric)
			if !Equal(&argGen.ident.super, &paramGen.ident.super) {
				Println('Failed in type gen spec')
				return false
			}
			if argGen.constraints.length != paramGen.constraints.length {
				return false
			}

			for i64(0) .. argGen.constraints.length {
				if !Apply(argGen.constraints[it], paramGen.constraints[it], known) {
					return false
				}
			}
			return true
		}
	}

	if param.Is(TypeAny) {
		Print('Resolved type is: ') 
		Print(^arg)
		Println('')
		return known.Add(param.As(TypeAny), arg)
		return true
	}

	Println('Failed a bottom apply :')
	return false
}

Equal fn(left DynamicArray(Type^), right DynamicArray(Type^)) i8 {
	if left.length != right.length {
		return false
	}

	for i64(0) .. left.length {
		if !Equal(left[it], right[it]) {
			return false
		}
	}
	return true
}

Equal fn(from Type^, to Type^) i8 {

	f Type^ = from.Resolved()
	t Type^ = to.Resolved()

	if f.kind != t.kind {
		return false
	}

	if f.Is(TypePointer) {
		fPtr TypePointer^ = f.As(TypePointer)
		tPtr TypePointer^ = t.As(TypePointer)
		return Equal(fPtr.pointed, tPtr.pointed)
	}

	if f.Is(TypeIdentifier) {
		fIdent TypeIdentifier^ = f.As(TypeIdentifier)
		tIdent TypeIdentifier^ = t.As(TypeIdentifier)
		Assert(fIdent.spec, 'f spec nil')
		Assert(tIdent.spec, 't spec nil')
		return cast(i64, fIdent.spec) == cast(i64, tIdent.spec)
	}

	Assert(0, 'Unhandled type in Equal')
	return false
}
