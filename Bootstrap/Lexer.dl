@import {
	'dl/String.dl',
	'dl/c.dl'
}

Position struct {
    line i32
    column i16
    file i16
}

Token struct
{
	Type i32
	value str
	at Position
}

Lexer struct {
	file File^
	nextCharacter i32
	tokens DynamicArray(Token)
	at i64

	currentLine i64
	currentColumn i64
	currentFile i64
}



kParenOpen i32 = Char('(')
kParenClose i32 = Char(')')

kBracketOpen i32 = Char('{')
kBracketClose i32 = Char('}')

kPlus i32 = Char('+')
kMinus i32 = Char('-')
kDivide i32 = Char('/')
kMultiply i32 = Char('*')

kEqual i32 = Char('=')

kEnd i32 = 0
kSemicolon i32 = -25
kEndLine i32 = -26


kKeywordsBegin i32 = -100 //Keywords end

kStruct i32 = kKeywordsBegin + 1	// stuct
kFunction i32 = kKeywordsBegin + 2	// fn

kKeywordsEnd i32 = kFunction


kIdentifier i32 = -20
kString i32 = -21
kNumber i32 = -22

TokenString fn(token i32) str {
	if token == kNumber {
		return 'number'
	}
	if token == kStruct {
		return 'struct'
	}
	if token == kIdentifier {
		return 'identifier'
	}
	if token == kString {
		return 'string'
	}
	if token == kBracketOpen {
		return '{'
	}
	if token == kBracketClose {
		return '}'
	}
	if token == kSemicolon {
		return ';'
	}
	if token == kMinus {
		return '-'
	}
	if token == kPlus {
		return '+'
	}
	if token == kDivide {
		return '/'
	}
	if token == kMultiply {
		return '*'
	}
	if token == kEndLine {
		return 'end of line'
	}
	return 'No name for token type ' + String(token)
}

equal fn(token Token, kind i64) i8 {
	return token.Type == kind
}
notEqual fn(token Token, kind i64) i8 {
	return token.Type != kind
}

Char fn(char str) i32 {
	Assert(char.length == 1, 'Exepcted str of length 1')
	return ^(char.chars)
}
Lexer fn(file str) Lexer
{
	self Lexer
	self.file = FileOpen(file.chars, 'r'.chars)
	if !self.file {
		Print('Failed to open file \'' + file + '\'')
		return self
	}
	Get(self)

	token Token = self.Next() 
	for token.Type != 0
	{
		self.tokens.Push(token)
		token = self.Next() 
	}

	none Token
	self.tokens.Push(none)
	self.tokens.Push(none)
	self.tokens.Push(none)
	
	return self
}

Peek fn(self ref Lexer) i32
{
	return self.nextCharacter
}
Get fn(self ref Lexer) i32
{
	character i32 = self.nextCharacter
	self.nextCharacter = FileGetChar(self.file)
	if self.nextCharacter == -1 {
		self.nextCharacter = 0
	}
	return character
}

@extern
{
	isspace fn(v i32)i32
	isalpha fn(v i32)i32
	isalnum fn(v i32)i32
	isdigit fn(v i32)i32
}

At fn(self ref Lexer, i i64) Token
{
	return self.tokens[self.at + i]
}
Eat fn(self ref Lexer) {
	self.at = self.at + 1
}
Eat fn(self ref Lexer, count i64) {
	self.at = self.at + count
}

Next fn(self ref Lexer) Token
{
	for isspace(Peek(self))
	{
		if Peek(self) == Char('\n')
		{
			self.currentLine = self.currentLine + 1
		}
		if (Get(self) == Char('\n')) && self.tokens.length && Peek(self) != Char('{')
		{
			t i32 = self.tokens[self.tokens.length-1].Type
			if  t == kIdentifier || t == kNumber || t == kString || (t >= kKeywordsBegin && t < kKeywordsEnd)
			{
				token Token
				token.Type = kEndLine
				token.at.line = self.currentLine.i32()
				self.tokens.Push(token)
			}
		}
	}

	if (isalpha(Peek(self)) || Peek(self) == Char('_'))
	{
		data DynamicArray(i8)
		Init(data)
		for isalnum(Peek(self)){
			Push(data, i8(Get(self)))
		}
		Push(data, 0)

	 	t Token
		t.Type = kIdentifier
		t.value.chars = data.elements
		t.value.length = data.length - 1
		t.at.line = self.currentLine.i32()

		if Equal(t.value, 'struct')
		{
			t.Type = kStruct
		}
		else if Equal(t.value, 'fn')
		{
			t.Type = kFunction
		}
		return t
	}

	if Peek(self) == Char('.') || isdigit(Peek(self))
	{
		num f64 = (0)
		m f64 = (10)

		data DynamicArray(i8)
		Init(data)

		for isdigit(Peek(self)) 
		{
			Push(data, i8(Get(self)))
		}
		if Peek(self) == Char('.')
		{
			Push(data, i8(Get(self)))
		}
		for isdigit(Peek(self)) {
			Push(data, i8(Get(self)))
		}
		Push(data, 0)

		t Token
		t.Type = kNumber
		t.value.chars = data.elements
		t.value.length = data.length - 1
		t.at.line = self.currentLine.i32()
		return t
	}
	if Peek(self) == Char('\'')
	{
		Get(self)//Consume '

		data DynamicArray(i8)
		Init(data)

		for Peek(self) != Char('\'') {
			Push(data, i8(Get(self)))
		}

		Push(data, 0)
		Get(self)//Consume '

		t Token
		t.Type = kString
		t.value.chars = data.elements
		t.value.length = data.length - 1
		t.at.line = self.currentLine.i32()
		return t
	}
	t Token
	t.Type = (Get(self))

	chars i8^ = Alloc(i8, 2)
	^(chars + 0) = t.Type.i8()
	^(chars + 1) = 0
	t.value = String(chars)
	t.at.line = self.currentLine.i32()
	return t
}
