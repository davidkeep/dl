
@import { 
	'dl/String.dl'
}

Type struct
{
    kind i32
}

TypeIdentifier struct {
    super Type
    ident str
    spec Expr^
}

TypeIdentifier fn() TypeIdentifier^
{
    self TypeIdentifier^ = new(TypeIdentifier)
    self.super.kind = Id(TypeIdentifier)
    return self
}

TypeFunctions struct {
    super Type
    functions DynamicArray(Function^)
}

TypeFunctions fn() TypeFunctions^
{
    self TypeFunctions^ = new(TypeFunctions)
    self.super.kind = Id(TypeFunctions)
    return self
}

TypePointer struct {
    super Type
    pointed Type^
}

TypeGeneric struct {
    super Type
    spec Expr^
    specGeneric Expr^
    constraints ExpressionList
}

Expr struct {
    kind i64
    typ Type^
}

Block struct {
    super Expr
    expressions DynamicArray(Expr^)
    variables Table(str, Expr^)
    functions Table(str, TypeFunctions^)
}

Block fn() Block^ {
    self Block^ = new(Block)
    self.super.kind = Id(Block)
    self.expressions.Init()
    self.variables.Init()
    self.functions.Init()
    return self
}

Lookup fn(self ref Block, ident str) Expr^
{
	return self.variables[ident]
}

LookupFns fn(self ref Block, ident str) TypeFunctions^
{
    return self.functions[ident]
}

InsertFn fn(self ref Block, ident str, function Function^) 
{
    fns TypeFunctions^^ = &self.functions[ident]
    funcs TypeFunctions^ = ^fns
    if !funcs 
    {
        funcs = new(TypeFunctions)
        ^fns = funcs
    }
    funcs.functions.Push(function)
}

Insert fn(self ref Block, ident str, expr Expr^) 
{
	self.variables[ident] = expr
}

Add fn(self ref Block, expr Expr^) 
{
	self.expressions.Push(expr)
}

//Definitions
Function struct 
{
    super Expr
    ident str
    block Block^
    params ExpressionList
}
Init fn(self ref Function)
{
    self.super.kind = Id(Function)
}
Function fn() Function^
{
    self Function^ = new(Function)
    self.Init()
    return self
}

Identifier struct
{
    super Expr
    ident str
    reference Expr^
}

Identifier fn() Identifier^
{
    self Identifier^ = new(Identifier)
    self.super.kind = Id(Identifier)
    return self
}

Structure struct 
{
    super Expr
    ident str
    incomplete i8
    fields DynamicArray(Variable^)
}
Init fn(self ref Structure)
{
    self.super.kind = Id(Structure)
}
Structure fn() Structure^
{
    self Structure^ = new(Structure)
    self.Init()
    return self
}
Add fn(structure ref Structure, field Variable^) {
    structure.fields.Push(field)
}

Variable struct
{
    super Expr
    ident str
}
Variable fn() Variable^
{
    self Variable^ = new(Variable)
    self.super.kind = Id(Variable)
    return self
}

ExpressionList struct
{
    super Expr
    list DynamicArray(Expr^)
}
Add fn(list ref ExpressionList, expr Expr^) {
    list.list.Push(expr)
}
Call struct
{
    super Expr
    operand Expr^
    params ExpressionList
}

Call fn() Call^
{
    self Call^ = new(Call)
    self.super.kind = Id(Call)
    self.params.list.Init()
    self.params.super.kind = Id(ExpressionList)
    return self
}

If struct 
{
    super Expr
    condition Expr^
    trueBranch Block^
    falseBranch Block^
}
If fn() If^
{
    self If^ = new(If)
    self.super.kind = Id(If)
    return self
}

For struct 
{
    super Expr
    from Expr^
    to Expr^
}
For fn() For^
{
    self For^ = new(For)
    self.super.kind = Id(For)
    return self
}


As fn(expr ref Expr, type T?) T^ {
    Assert(expr.kind == Id(T), 'Type mismatch') 
    return cast(T^, &expr)
}

Is fn(expr ref Expr, type T?) i8 {
    return expr.kind == Id(T)
}
As fn(typ ref Type, type T?) T^ {
    Assert(typ.kind == Id(T), 'Type mismatch') 
    return cast(T^, &typ)
}

Is fn(typ ref Type, type T?) i8 {
    return typ.kind == Id(T)
}

Id fn(type Function) i32 {
    return 1
}
Id fn(type Structure) i32 {
    return 2
}
Id fn(type Variable) i32 {
    return 3
}
Id fn(type Block) i32 {
    return 4
}
Id fn(type Identifier) i32 {
    return 5
}
Id fn(type Call) i32 {
    return 7
}
Id fn(type ExpressionList) i32 {
    return 8
}
Id fn(type If) i32 {
    return 9
}
Id fn(type For) i32 {
    return 10
}


Id fn(type TypePointer) i32 {
    return 1
}
Id fn(type TypeIdentifier) i32 {
    return 2
}
Id fn(type TypeFunctions) i32 {
    return 3
}
