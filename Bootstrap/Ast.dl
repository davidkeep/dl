
@import { 
	'dl/String.dl'
}

TypePointer struct {
    super Expr
    pointed Expr^
}

TypeGeneric struct {
    super Expr
    typ Expr^
    typGeneric Expr^
    constraints ExpressionList
}

Expr struct {
    kind i64
    typ Expr^
}

Block struct {
    super Expr
    expressions DynamicArray(Expr^)
    variables Table(str, Expr^)
}

Block fn() Block^ {
    self Block^ = new(Block)
    self.super.kind = Id(Block)
    self.expressions.Init()
    self.variables.Init()
    return self
}

Lookup fn(self ref Block, ident str) Expr^
{
	return self.variables[ident]
}

Insert fn(self ref Block, ident str, expr Expr^) 
{
	self.variables[ident] = expr
}

Add fn(self ref Block, expr Expr^) 
{
	self.expressions.Push(expr)
}

//Definitions
Function struct 
{
    super Expr
    ident str
    block Block^
}
Function fn() Function^
{
    self Function^ = new(Function)
    self.super.kind = Id(Function)
    return self
}

Identifier struct
{
    super Expr
    ident str
    reference Expr^
}

Identifier fn() Identifier^
{
    self Identifier^ = new(Identifier)
    self.super.kind = Id(Identifier)
    return self
}

Structure struct 
{
    super Expr
    ident str
    incomplete i8
}
Structure fn() Structure^
{
    self Structure^ = new(Structure)
    self.super.kind = Id(Structure)
    return self
}
Variable struct
{
    super Expr
    ident str
}
Variable fn() Variable^
{
    self Variable^ = new(Variable)
    self.super.kind = Id(Variable)
    return self
}

ExpressionList struct
{
    super Expr
    list DynamicArray(Expr^)
}

Call struct
{
    super Expr
    operand Expr^
    params ExpressionList
}

Call fn() Call^
{
    self Call^ = new(Call)
    self.super.kind = Id(Call)
    self.params.list.Init()
    self.params.super.kind = Id(ExpressionList)
    return self
}

If struct 
{
    super Expr
    condition Expr^
    trueBranch Block^
    falseBranch Block^
}
If fn() If^
{
    self If^ = new(If)
    self.super.kind = Id(If)
    return self
}

For struct 
{
    super Expr
    from Expr^
    to Expr^
}
For fn() For^
{
    self For^ = new(For)
    self.super.kind = Id(For)
    return self
}


As fn(expr ref Expr, type T?) T^
{
    Assert(expr.kind == Id(T), 'Type mismatch') 
    return cast(T^, &expr)
}

Is fn(expr ref Expr, type T?) i8
{
    return expr.kind == Id(T)
}

Id fn(type Function) i32 {
    return 1
}
Id fn(type Structure) i32 {
    return 2
}
Id fn(type Variable) i32 {
    return 3
}
Id fn(type Block) i32 {
    return 4
}
Id fn(type Identifier) i32 {
    return 5
}
Id fn(type Call) i32 {
    return 7
}
Id fn(type ExpressionList) i32 {
    return 8
}
Id fn(type If) i32 {
    return 9
}
Id fn(type For) i32 {
    return 10
}
Id fn(type TypePointer) i32 {
    return 21
}
