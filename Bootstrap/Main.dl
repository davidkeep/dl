

@import {
	'dl/Array.dl',
	'dl/String.dl',
    'Lexer.dl',
    'Ast.dl',
    'Print.dl',
}

Error struct {
    message str
    at Position
}

errors DynamicArray(Error)


ParseFunction fn (lexer ref Lexer) Function^
{
    if lexer.At(1) == kFunction && lexer.At(0) == kIdentifier
    {
        self Function^ = Function()
        self.ident = lexer.At(0).value
        lexer.Eat(2)

        lexer.Expect(kParenOpen)
        lexer.Expect(kParenClose)

        lexer.Expect(kBracketOpen)
        lexer.Expect(kBracketClose)

        return self
    }

    return cast(Function^, 0)
}

ParseStructure fn (lexer ref Lexer) Structure^
{
    if lexer.At(1) == kStruct && lexer.At(0) == kIdentifier
    {
        structure Structure^ = Structure()
        structure.ident = lexer.At(0).value
        lexer.Eat(2)

        if lexer.At(0) == kSemicolon {
            lexer.Eat(1)
            structure.incomplete = true
            return structure
        }

        lexer.Expect(kBracketOpen)
        lexer.Expect(kBracketClose)

        return structure
    }

    return cast(Structure^, 0)
}
ParseType fn(lexer ref Lexer) Expr^ {
    if lexer.At(0) == kIdentifier {
        typ Type^ = TypeIdentifier()
    }
}

ParseVariable fn(lexer ref Lexer) Variable^ {
    
    if lexer.At(0) == kIdentifier && lexer.At(1) == kIdentifier
    {
        variable Variable^ = Variable()
        variable.ident = lexer.At(0).value
        lexer.Eat(1)

        variable.super.typ = ParseType()

        return variable
    }
    return cast(Expr^, 0)
}
ParseOperand fn(lexer ref Lexer, precedence i32) Expr^
{
    if lexer.At(0) == kIdentifier {
        operand Identifier^ = Identifier()
        return &operand.super
    }
    return cast(Expr^, 0)
}

ParseExpression fn(lexer ref Lexer, precedence i32) Expr^
{
    operand Expr^ = ParseOperand(lexer, precedence)

    for operand
    {
        return operand
    }
    return operand
}


Error fn(message str, at Position)
{
    error Error
    error.message = message
    error.at = at
    errors.Push(error)
}

Expect fn(lexer ref Lexer, token i32) Position
{
    at Position = lexer.At(0).at

    if lexer.At(0) != token
    {
        Error('Expected ' + TokenString(token) + ', found ' + TokenString(lexer.At(0).Type), lexer.At(0).at)
    }
    lexer.Eat(1)
    return at
}

Parse fn(file str) Block^
{
    lexer Lexer = Lexer(file)
    block Block^ = Block()
    for true 
    {
        expr Expr^
        if !expr {
           expr = &ParseStructure(lexer).super
        }
        if !expr {
           expr = &ParseFunction(lexer).super
        }
        if !expr 
        {
            if lexer.At(0) != kEnd
            {
                Error('Expected end of file, found ' + lexer.At(0).value, lexer.At(0).at)
            }
            return block
        }

        block.Add(expr)
    }
    return cast(Block^, 0)
}

Main fn() i32 {

    if chdir('/Users/David/Desktop/dl/Bootstrap'.chars) != 0 {
        Assert(0, 'Couldnt set resource directory')
    }

    block Block^ = Parse('Test.dl')
    
    visit PrintVisitor
    block.super.Visit(visit)

    if errors.length
    {
        Println(errors[0].message)
    }
    Println('Finished compiling Test.dl')
    return 0
}

