@import {
	'Ast.dl',
	'Intrinsic.dl',
}

Semantic struct {
	intrinsic Intrinsics
	scopes DynamicArray(Block^)
}

Init fn(semantic ref Semantic, ast ref Block)
{
	semantic.scopes.Push(&ast)

    semantic.intrinsic.Init(semantic, ast)

	for i64(0) .. ast.expressions.length {
		expr Expr^ = ast.expressions[it]
		semantic.Declare(^expr)
	}

	semantic.Visit(ast.super)
	semantic.scopes.Pop()
}

Find fn(semantic ref Semantic, ident str) Expr^ {
	for i64(0) .. semantic.scopes.length {
		scope Block^ = semantic.scopes[semantic.scopes.length - it - 1]
		expr Expr^ = scope.Lookup(ident)
		if expr {
			return expr
		}
	}
	Assert(0, 'No known type named ' + ident)
	return cast(Expr^, 0)
}

FindMatch fn(semantic ref Semantic, ident str, args ref ExpressionList) TypeFunctions^ 
{
	for i64(0) .. semantic.scopes.length 
	{
		scope Block^ = semantic.scopes[semantic.scopes.length - it - 1]
		expr TypeFunctions^ = scope.LookupFns(ident)
		if expr 
		{
			return expr
		}
	}
	Assert(0, 'No known function named ' + ident)
	return cast(TypeFunctions^, 0)
}

Declare fn(semantic ref Semantic, expr ref Expr) {
	if expr.Is(Structure) {
		self Structure^ = expr.As(Structure)
		semantic.scopes.Last().Insert(self.ident, &expr)
	}
	else if expr.Is(Function) {
		self Function^ = expr.As(Function)
		semantic.scopes.Last().InsertFn(self.ident, self)
	}
	else if expr.Is(Variable) {
		self Variable^ = expr.As(Variable)
		semantic.scopes.Last().Insert(self.ident, &expr)
	}
	else {
 		Assert(0, 'Expected Structure, Function or Variable')
	}
}

Visit fn(semantic ref Semantic, expr ref Expr)
{
	if expr.Is(Block) {
		self Block^ = expr.As(Block)
		semantic.scopes.Push(self)

		for i64(0) .. self.expressions.length {
			expr Expr^ = self.expressions[it]
			semantic.Visit(^expr)
		}
		semantic.scopes.Pop()
		return
	}
	if expr.Is(Structure) {
		self Structure^ = expr.As(Structure)
		return
	}
	if expr.Is(Function) {
		self Function^ = expr.As(Function)
		semantic.Visit(self.block.super)
		return
	}
	if expr.Is(Variable) {
		self Variable^ = expr.As(Variable)
		semantic.Annotate(^self.super.typ)
		return
	}
	if expr.Is(Identifier) {
		self Identifier^ = expr.As(Identifier)
		return
	}
	if expr.Is(Call) {
		self Call^ = expr.As(Call)
		semantic.Visit(^self.operand)
		semantic.Visit(self.params.super)

		if self.operand.Is(Identifier) 
		{
			funcs TypeFunctions^ = semantic.FindMatch(self.operand.As(Identifier).ident, self.params)
			found Function^
			for i64(0) .. funcs.functions.length {
				f Function^ = funcs.functions[it]
				if f.params.list.length != self.params.list.length {

				}
				else {
					found = f
				}	
			}
			if !found {
				Assert(0, 'No match for function: ' + self.operand.As(Identifier).ident)
			}
			self.operand = &funcs.functions.Last().super
		}
		else
		{
			Assert(0, 'Call without identifier as operand')
		}
		return
	}
	if expr.Is(ExpressionList) {
		self ExpressionList^ = expr.As(ExpressionList)
		return
	}
	Println('Unhandled visit')
}

Annotate fn(semantic ref Semantic, typ ref Type)
{
	if typ.Is(TypePointer) {
		self TypePointer^ = typ.As(TypePointer)
		semantic.Annotate(^self.pointed)
		return
	}
	if typ.Is(TypeIdentifier) {
		self TypeIdentifier^ = typ.As(TypeIdentifier)
		self.spec = semantic.Find(self.ident)
		return
	}
	Assert(0, 'Can only annotate a type')
}

// Strips of typedefs etc to get to the true underlying type
Resolved fn(typ ref Type) Type^ {
	return &typ
}
Apply fn(argument Type^, parameter Type^) i8 {
	arg Type^ = argument.Resolved()
	param Type^ = parameter.Resolved()


	return false
}

Equal fn(from Type^, to Type^) i8 {

	f Type^ = from.Resolved()
	t Type^ = to.Resolved()

	if f.kind != t.kind {
		return false
	}

	if f.Is(TypePointer) {
		fPtr TypePointer^ = f.As(TypePointer)
		tPtr TypePointer^ = t.As(TypePointer)
		return Equal(fPtr.pointed, tPtr.pointed)
	}

	if f.Is(TypeIdentifier) {
		fIdent TypeIdentifier^ = f.As(TypeIdentifier)
		tIdent TypeIdentifier^ = t.As(TypeIdentifier)
		return cast(i64, fIdent) == cast(i64, tIdent)
	}

	Assert(0, 'Unhandled type in Equal')
	return false
}
