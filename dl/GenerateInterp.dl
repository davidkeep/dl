@import {
	'Semantic.dl',
	'Generate.dl',
	'Interp.dl',
}



AddLabel fn(self ref GenerateInterp, name str) {
	self.interp.labels[name] = self.interp.instructionsSize
	Println('label: ' + name + ' at ' + String(self.interp.instructionsSize))
}

GetLabel fn(self ref GenerateInterp, name str) i64 {
	r i64 = self.interp.labels[name]
	Assert(r != 0, 'Label not found ' + name)
	return r
}

Size fn(t Type^) i64 {
	typ Type^ = t.Resolved()
	if typ.Is(TypeRef) {
		return 8
	}
	else if typ.Is(TypeIdentifier) {
		spec Expr^ = typ.As(TypeIdentifier).spec
		structure Structure^ = spec.As(Structure)
		if structure.ident == 'i8' {
			return 1
		}
		if structure.ident == 'i16' {
			return 2
		}
		if structure.ident == 'i32' {
			return 4
		}
		if structure.ident == 'i64' {
			return 8
		}

		size i64

		for i64(0) .. structure.fields.length {
			size = size + Size(structure.fields[it].super.typ)
		}
		return size
	}

	Println('unhandled type for Size')
	return 0
}
Size fn(expressions ref ExpressionList) i64
{
	size i64
	for i64(0) .. expressions.list.length {
		size = size + Size(expressions.list[it].typ)
	}
	return size
}

AddVariable fn(self ref GenerateInterp, variable Variable^) {

	local DebugLocal^ = new(DebugLocal)
	local.Init(variable, self.frameOffset)
	local.instr = self.interp.instructionsSize
	self.currentFrame.locals.Push(local)

	size i64 = Size(variable.super.typ)
	self.interp.AddValue(LoadConst)
	self.interp.AddValue(i64(size))

	// Zero out this mem
	for i64(0) .. size {
		self.interp.AddValue(i8(0))
	}
	PrintTabs(1)
	Println('variable: ' + variable.ident + ' size:' + String(size) + '		frame:' + String(self.frameOffset))
	self.offsets[&variable.super] = self.frameOffset
	self.FrameOffset(size)
}

LoadConst fn(self ref GenerateInterp, value T?) {
	self.interp.AddLoadConstInstr(value)
	self.FrameOffset(i64(T.size))
}

PushFrame fn(self ref GenerateInterp, t Type^) {
	self.frameOffset = self.frameOffset + 4
}
PopFrame fn(self ref GenerateInterp, t Type^) {
	self.frameOffset = self.frameOffset - 4
}

FrameOffset fn(self ref GenerateInterp, offset i64) {
	self.frameOffset = self.frameOffset + offset
}

PushParameter fn(self ref GenerateInterp, variable Variable^) 
{

	size i64 = i64(i32.size)
	self.interp.AddValue(LoadConst)
	self.interp.AddValue(i64(size))
	self.interp.AddValue(i32(0))
	PrintTabs(1)
	Println('param: ' + variable.ident + ' size:' + String(size) + '		frame:' + String(self.frameOffset))
}

ReserveResult fn(self ref GenerateInterp, typ Type^) {



	size i64 = Size(typ)
	self.interp.AddValue(LoadConst)
	self.interp.AddValue(i64(size))

	// Zero out this mem
	for i64(0) .. size {
		self.interp.AddValue(i8(0))
	}
	PrintTabs(1)
	Println('result:  size:' + String(size) + '		frame:' + String(self.frameOffset))
	self.FrameOffset(size)
}

LoadAddressInstr fn(self ref GenerateInterp, size i64) {
	self.interp.AddValue(LoadAddressInstr)
	self.interp.AddValue(cast(i64, size))
	PrintTabs(1)
	Println('load: ' + String(size))
}

LoadOffsetInstr fn(self ref GenerateInterp, offset i64, size i64) {

	self.interp.AddValue(LoadOffsetInstr)
	self.interp.AddValue(cast(i64, size))
	self.interp.AddValue(cast(i64, offset))
	self.frameOffset = self.frameOffset + size

	PrintTabs(1)
	Println('load: ' + String(size) + ' offset: ' + String(offset) + '     frame:' + String(self.frameOffset))
}

//StoreOffsetInstr fn(self ref Interp, offset i64, size i64) {
//	self.AddValue(StoreOffsetInstr)
//	self.AddValue(cast(i64, size))
//	self.AddValue(cast(i64, offset))
//	PrintTabs(1)
//	Println('store: ' + String(size) + ' offset: ' + String(offset))
//}


//AddCall fn(self ref Interp, name str) 
//{
//	PrintTabs(1)
//	Println('call: ' + name)
//	self.AddLoadConstInstr(self.GetLabel(name))
//	self.AddValue(CallInstr)
//}

//AddCallExtern fn(self ref Interp, name str) {
//	func voidptr = dlsym(self.dlhandle, name.chars)
//	self.AddValue(CallExtern)
//	self.AddValue(cast(i64, func))
//	PrintTabs(1)
//	Println('call extern: ' + name)
//}


//AddExternCallLabel fn(self ref Interp, name str) {
//	func voidptr = dlsym(self.dlhandle, name.chars)
//	self.labels[name] = cast(i64, func)
//	PrintTabs(1)
//	Println('label extern:  ' + name)
//}


GenerateInterp struct {
	semantic Semantic^
	interp Interp^
	frameOffset i64
	offsets Table(Expr^, i64)
	currentFrame DebugFrame^
}

Init fn(generate ref GenerateInterp, semantic ref Semantic, ast ref Block, interp ref Interp) {
	
	generate.interp = &interp
	generate.semantic = &semantic
	generate.offsets.Init()

	for i64(0) .. ast.expressions.length {
		expr Expr^ = ast.expressions[it]
		generate.Visit(^expr)
	}

	for i64(0) .. gSpecializations.length {
		spec FunctionSpec^ = gSpecializations[it]
		if !spec.incomplete 
		{
			spec.Apply()
			generate.semantic.Visit(spec.function.super)
			generate.Visit(spec.function.super)
		}
	}
}

Visit fn(generate ref GenerateInterp, expr ref Expr) 
{
	if expr.Is(Block) {
		self Block^ = expr.As(Block)
		for i64(0) .. self.expressions.length {
			expr Expr^ = self.expressions[it]
			generate.Visit(^expr)
		}
		return
	}
	if expr.Is(Structure) {
		self Structure^ = expr.As(Structure)
		return
	}
	if expr.Is(Function) {
		self Function^ = expr.As(Function)
		if generate.semantic.intrinsic.IsIntrinsic(self) 
		{
			return
		}

		ident str = self.Name()


		if self.any.length == 0 || cast(i64, self.spec) != 0 
		{
			generate.currentFrame = new(DebugFrame)
			generate.currentFrame.Init(self)

			if self.block 
			{

				generate.frameOffset = -(Size(self.params) + 16)
				
			
				for i64(0) .. self.params.list.length 
				{
					generate.Visit(^self.params.list[it])
				}
				Assert(generate.frameOffset == -16, 'Expected -16 frame offset, space for return and frame ptr')
				generate.frameOffset = 0
				generate.interp.AddLabel(ident)
		
				generate.currentFrame.startInstr = generate.interp.instructionsSize
				generate.interp.frames[generate.interp.instructionsSize] = generate.currentFrame
				generate.interp.frameArray.Push(generate.currentFrame)

				generate.Visit(self.block.super)
				generate.interp.AddValue(ReturnInstr)
				generate.currentFrame.endInstr = generate.interp.instructionsSize - 1
				Println('')
				Println('')
			}
			else {
				generate.frameOffset = 0 // doesn't really matter here
				generate.interp.AddExternCallLabel(ident)
			}
		}
		return
	}
	if expr.Is(Call) 
	{
		self Call^ = expr.As(Call)
	
		if self.func.Is(Function) 
		{
			function Function^ = self.func.As(Function)
			if generate.semantic.intrinsic.IsIntrinsic(function) 
			{
				generate.GenerateIntrinsic(function, &self.params)
			}
			else 
			{
				ident str = function.Name()
				if function.block {
					for i64(0) .. self.params.list.length 
					{
						generate.Visit(^self.params.list[it])
					}
					if function.result {
						generate.ReserveResult(function.result)
					}
					generate.interp.AddCall(ident)
				}
				else 
				{
					for i64(0) .. self.params.list.length 
					{

						t Type^ = self.params.list[it].typ.Resolved()
						expr Expr^ = self.params.list[it]
						if t.As(TypeIdentifier).spec == &generate.semantic.intrinsic.i32_.super {
							generate.Visit(^self.params.list[it])
							generate.interp.AddValue(ParamExtern_32)
						}
						else {
							Assert(0, 'Parameter is of invalid type in extern call, only support basic types and pointers')
						}
					}
					if function.result {
						generate.ReserveResult(function.result)
					}
					generate.interp.AddCallExtern(ident)
				}
			}
		}
		else if self.func.Is(FunctionSpec) 
		{
			spec FunctionSpec^ = self.func.As(FunctionSpec)
			function Function^ = spec.function
			if generate.semantic.intrinsic.IsIntrinsic(function) 
			{
				generate.GenerateIntrinsic(function, &self.params)
			}
			else 
			{
				ident str = function.Name()
				generate.interp.AddCall(ident)			
			}
		}
		else {
			Assert(0, 'Expected fn or fn spec ' + String(self.operand.kind))
		}
		return
	}
	if expr.Is(Variable) {
		self Variable^ = expr.As(Variable)
		generate.AddVariable(self)

		//if !self.super.typ.Is(TypeType) 
		//{
		//	generate.impl.Visit(^self.super.typ)
		//	generate.impl.Write(' ')
		//	generate.impl.Write(self.ident)
		//	if self.assign {
		//		generate.impl.Write('=')
		//		generate.Visit(^self.assign)
		//	}
		//	else {
		//		generate.impl.Write('={0}')
		//	}
		//}
		return
	}
	if expr.Is(Identifier) {
		self Identifier^ = expr.As(Identifier)
		a i64 = generate.offsets[self.reference]
		generate.LoadOffsetInstr(a, Size(self.reference.typ))
		//generate.impl.Write(self.ident)
		return
	}
	if expr.Is(ForList) {
		self ForList^ = expr.As(ForList)

		//Println('Jump: offset: ' + String(generate.frameOffset))
		//generate.interp.AddValue(JumpInstr)
		//generate.interp.AddValue(generate.frameOffset)

		//for i64(0) .. self.list.list.length {
		//	generate.semantic.SetIt(^self, self.list.list[it])
		//	generate.impl.Write('/*ForList ' + String(it) + '*/')
		//	self.it.assign = self.list.list[it]
		//	self.it.super.typ = self.list.list[it].typ
		//	Assert(self.it.super.typ)
		//	//generate.Visit(self.it.super)
		//	generate.Visit(self.block.super)
		//}
		//generate.impl.Write(' ')
		//generate.impl.Write(self.ident)
		return
	}
	if expr.Is(For) {
		self For^ = expr.As(For)


		


		//self.it.assign = self.from
		if self.to {
			generate.Visit(self.it.super)
			generate.Visit(^self.it.assign) //Push right on the stack
			generate.interp.StoreOffsetInstr(generate.offsets[&self.it.super], 4)	// Pop and store
		}
		//generate.Visit(^self.left)

		//if self.to {
		//	//generate.Visit(self.it)
		//	//generate.impl.Write('for(')
		//	//self.it.assign = self.from


		//	//generate.impl.Write('; it < ')
		//	//generate.Visit(^self.to)
		//	//generate.impl.Write('; it++)')
		//}
		//else {
		//	//generate.impl.Write('while(')
		//	Println('from: offset: ' + String(generate.frameOffset))

		//	generate.Visit(^self.from)
		//	//generate.impl.Write(')')
		//}


		start i64 = generate.interp.instructionsSize
		Println('start:')

		if self.to {
			generate.Visit(self.test.super)
		}
		else {
			generate.Visit(^self.from)
		}

		generate.FrameOffset(-1)

		PrintTabs(1)
		Println('Jump: end ')
		generate.interp.AddValue(JumpInstr)
		at i64^ = generate.interp.AddValue(i64(0))

		generate.Visit(self.block.super)
		
		if self.to {
			generate.Visit(^self.inc)
		}
		generate.interp.AddLoadConstInstr(i8(0))
		generate.interp.AddValue(JumpInstr)
		generate.interp.AddValue(i64(start))
		PrintTabs(1)
		Println('Jump: start')
		Println('end:')

		^at = generate.interp.instructionsSize

		//generate.impl.Write(' ')
		//generate.impl.Write(self.ident)
		return
	}
	
	if expr.Is(If) {
		self If^ = expr.As(If)


		generate.Visit(^self.condition)
		PrintTabs(1)
		Println('Jump: end ')
		generate.interp.AddValue(JumpInstr)
		at i64^ = generate.interp.AddValue(i64(0))
		generate.Visit(self.trueBranch.super)
		^at = generate.interp.instructionsSize
		Println('end:')
		return
	}

	if expr.Is(Access) {
		self Access^ = expr.As(Access)
		//generate.Visit(^self.operand)
		//generate.impl.Write('.')
		//generate.Visit(^self.field)
		return
	}
	if expr.Is(Assign) {
		self Assign^ = expr.As(Assign)
		//for i32(0) .. self.drefCount {
		//	generate.impl.Write('*')
		//}

		a i64 = generate.offsets[self.left.As(Identifier).reference]

		//Push value on the stack
		generate.Visit(^self.right)

		leftSize i64 = Size(self.left.typ)
		rightSize i64 = Size(self.right.typ)
		Assert(leftSize == rightSize, 'Internal: Expected same size arguments for assign')

		//store pushed value
		generate.interp.StoreOffsetInstr(a, rightSize)	// Pop and store

		//generate.FrameOffset(-4)
		//generate.Visit(^self.left)
	//	generate.impl.Write('=')
		return
	}
	if expr.Is(Trait) {
		self Trait^ = expr.As(Trait)
		return
	}
	if expr.Is(NumberConstant) {
		self NumberConstant^ = expr.As(NumberConstant)
		generate.LoadConst(i32FromString(self.value))
		//generate.impl.Write(self.value)
		return
	}
	if expr.Is(StringConstant) {
		self StringConstant^ = expr.As(StringConstant)
		generate.LoadConst(cast(i64, self.value.chars))
		return
	}
	//generate.impl.Write('---- unhandled node ' + String(expr.kind) + '---- \n')
}


GenerateIntrinsic fn(generate ref GenerateInterp, function Function^, args ExpressionList^) {


	for i64(0) .. args.list.length {
		generate.Visit(^args.list[it])
	}

 	// Theses all push two values on the stack and pop one thus 1 - 2 = -1 thus 1 pop
	if function.ident == '+' {
		if function == &generate.semantic.intrinsic.ptr_add {
			generate.interp.AddValue(AddInstr_i64)
			generate.PopFrame(generate.semantic.intrinsic.i64_.typeIdent)
		}
		else {
			generate.interp.AddValue(AddInstr_i32)
			generate.PopFrame(generate.semantic.intrinsic.i32_.typeIdent)
		}
	}
	else if function.ident == '*' {
		generate.interp.AddValue(MulInstr_i32)
		generate.PopFrame(generate.semantic.intrinsic.i32_.typeIdent)
	}
	else if function.ident == '==' {
		PrintTabs(1) Println('Comp: == i32')
		generate.interp.AddValue(CompareInstr_i32)
		generate.FrameOffset(-8)
		generate.FrameOffset(1)
		generate.interp.AddValue(TestEqInstr) // pop i8 then push i8 net 0
	}
	else if function.ident == '!=' {
		PrintTabs(1) Println('Comp: != i32')
		generate.interp.AddValue(CompareInstr_i32)
		generate.FrameOffset(-8)
		generate.FrameOffset(1)
		generate.interp.AddValue(TestNotEqInstr) // pop i8 then push i8 net 0
	}
	else if function.ident == '<' {
		PrintTabs(1) Println('Comp: < i32')
		generate.interp.AddValue(CompareInstr_i32)
		generate.FrameOffset(-8)
		generate.FrameOffset(1)
		generate.interp.AddValue(TestLessInstr) // pop i8 then push i8 net 0
	}
	else if function.ident == 'dref' {
		generate.LoadAddressInstr(Size(args.list[0].typ.Resolved().As(TypeRef).reference))
		generate.FrameOffset(-8 + Size(args.list[0].typ.Resolved().As(TypeRef).reference))
	}
	else if function.ident == 'i32' {
		if function == &generate.semantic.intrinsic.i8_to_i32 {
			generate.interp.AddValue(CastInstr_i8_i32)
			//generate.FrameOffset(-3)
		}
		if function == &generate.semantic.intrinsic.i16_to_i32 {
			generate.interp.AddValue(CastInstr_i16_i32)
		}
		if function == &generate.semantic.intrinsic.i64_to_i32 {
			generate.interp.AddValue(CastInstr_i64_i32)
		}
		if function == &generate.semantic.intrinsic.f32_to_i32 {
			generate.interp.AddValue(CastInstr_f32_i32)
		}
		if function == &generate.semantic.intrinsic.f64_to_i32 {
			generate.interp.AddValue(CastInstr_f64_i32)
		}
	}
	else if function.ident == 'i64' {
		if function == &generate.semantic.intrinsic.i8_to_i64 {
			generate.interp.AddValue(CastInstr_i8_i64)
		}
		if function == &generate.semantic.intrinsic.i16_to_i64 {
			generate.interp.AddValue(CastInstr_i16_i64)
		}
		if function == &generate.semantic.intrinsic.i32_to_i64 {
			generate.interp.AddValue(CastInstr_i32_i64)
		}
		if function == &generate.semantic.intrinsic.f32_to_i64 {
			generate.interp.AddValue(CastInstr_f32_i64)
		}
		if function == &generate.semantic.intrinsic.f64_to_i64 {
			generate.interp.AddValue(CastInstr_f64_i64)
		}
	}
	else
	{
		Println('----unhandled intrinsic interp -----')
		Assert(0)
	}
}
