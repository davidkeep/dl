

@import {
	'Semantic.dl',
	'Generate.dl',
	'Interp.dl',
}

Size fn(t Type^) i64 {
	typ Type^ = t.Resolved()
	if typ.Is(TypeRef) {
		return 8
	}
	else if typ.Is(TypeIdentifier) {
		spec Expr^ = typ.As(TypeIdentifier).spec
		structure Structure^ = spec.As(Structure)
		if structure.ident == 'i8' {
			return 1
		}
		if structure.ident == 'i16' {
			return 2
		}
		if structure.ident == 'i32' {
			return 4
		}
		if structure.ident == 'i64' {
			return 8
		}
		if structure.ident == 'u64' {
			return 8
		}
		if structure.ident == 'voidptr' {
			return 8
		}


		size i64

		for i64(0) .. structure.fields.length {
			size = size + Size(structure.fields[it].super.typ)
		}
		return size
	}
	if typ.Is(TypeGeneric) {
		self TypeGeneric^ = typ.As(TypeGeneric)
		spec StructureSpec^ spec = self.spec.As(StructureSpec)
		spec.structure.Apply(^spec)
		return Size(spec.structure.typeIdent)
	}
	if typ.Is(TypeType) {
		return 0
	}

	Println('unhandled type for Size : ' + String(t.kind))
	Assert(0)
	return 0
}
Size fn(expressions ref ExpressionList) i64
{
	size i64
	for i64(0) .. expressions.list.length {
		size = size + Size(expressions.list[it].typ)
	}
	return size
}
Size fn(t Expr^) i64 {
	if t.Is(TypeAs) {
		return 0
	}
	return Size(t.typ)
}

OffsetOfMemeber fn (self ref Structure, field str) i64 
{
	offset i64

	for i64(0) .. self.fields.length {
		fieldVar Variable^ = self.fields[it]

		// The offset is calculated at the top thus the first field has an offset of 0
		if fieldVar.ident == field {
			//Println('offset ' + fieldVar.ident + ' ' + String(offset))
			return offset
		}
		offset = offset + Size(fieldVar.super.typ)
	}

	Assert(0, 'No field named ' + field + ' on structure ' + self.ident)
	return 0
}

AddVariable fn(self ref GenerateInterp, variable Variable^) {

	size i64 = Size(variable.super.typ)
	self.FrameOffset(size)

	local DebugLocal^ = new(DebugLocal)
	local.Init(variable, self.frameOffset)
	local.instr = self.interp.instructionsSize
	self.currentFrame.locals.Push(local)

	if variable.assign {
		Assert(size == Size(variable.assign.typ))
		self.PushContext(ContextLoad)
		self.Visit(^variable.assign)
		self.PopContext()
	}
	else {
		self.interp.AddValue(LoadConst)
		self.interp.AddValue(i64(size))
		// Zero out this mem
		for i64(0) .. size {
			self.interp.AddSpace(i8(0))
		}
	}
	PrintTabs(1)
	Println('variable: ' + variable.ident + ' size:' + String(size) + '		frame:' + String(self.frameOffset))
	self.offsets[&variable.super] = self.frameOffset

}

LoadConst fn(self ref GenerateInterp, value T?) {
	self.interp.AddLoadConstInstr(value)
}


FrameOffset fn(self ref GenerateInterp, offset i64) {
	self.frameOffset = self.frameOffset + offset
}

ReserveResult fn(self ref GenerateInterp, typ Type^) {

	size i64 = Size(typ)
	self.interp.AddValue(LoadConst)
	self.interp.AddValue(i64(size))

	// Zero out this mem
	for i64(0) .. size {
		self.interp.AddValue(i8(0))
	}
	PrintTabs(1)
	Println('result:  size:' + String(size) + '		frame:' + String(self.frameOffset))
	//self.FrameOffset(size)
}

LoadAddressInstr fn(self ref GenerateInterp, size i64) {
	self.interp.AddValue(LoadAddressInstr)
	self.interp.AddValue(cast(i64, size))

	PrintTabs(1)
	Println('load address size: ' + String(size))
}

Discard fn(self ref GenerateInterp, size i64) {
	self.interp.AddValue(DiscardInstr)
	self.interp.AddValue(cast(i64, size))

	PrintTabs(1)
	Println('discard size: ' + String(size))
}

LoadAddressFromOffset fn(self ref GenerateInterp, offset i64) {
	self.interp.AddValue(LoadAddressFromOffsetInstr)
	self.interp.AddValue(offset)

	PrintTabs(1)
	Println('load address from offset: ' + String(offset))
}

LoadOffsetInstr fn(self ref GenerateInterp, offset i64, size i64) {

	self.interp.AddValue(LoadOffsetInstr)
	self.interp.AddValue(cast(i64, size))
	self.interp.AddValue(cast(i64, offset))
	//self.frameOffset = self.frameOffset + size

	PrintTabs(1)
	Println('load: ' + String(size) + ' offset: ' + String(offset) + '     frame:' + String(self.frameOffset))
}

Store fn(self ref GenerateInterp, size i64, offset i64) {
	self.interp.AddValue(StoreInstr)
	self.interp.AddValue(cast(i64, size))
	self.interp.AddValue(cast(i64, offset))
	PrintTabs(1)
	Println('store: ' + String(size) + ' offset: ' + String(offset))
}

AddOffsetToAddress fn(self ref GenerateInterp, offset i64) {
	self.interp.AddValue(AddOffsetToAddressInstr)
	self.interp.AddValue(cast(i64, offset))
	PrintTabs(1)
	Println('add offset: ' + String(offset))
}

//AddCall fn(self ref Interp, name str) 
//{
//	PrintTabs(1)
//	Println('call: ' + name)
//	self.AddLoadConstInstr(self.GetLabel(name))
//	self.AddValue(CallInstr)
//}

//AddCallExtern fn(self ref Interp, name str) {
//	func voidptr = dlsym(self.dlhandle, name.chars)
//	self.AddValue(CallExtern)
//	self.AddValue(cast(i64, func))
//	PrintTabs(1)
//	Println('call extern: ' + name)
//}


//AddExternCallLabel fn(self ref Interp, name str) {
//	func voidptr = dlsym(self.dlhandle, name.chars)
//	self.labels[name] = cast(i64, func)
//	PrintTabs(1)
//	Println('label extern:  ' + name)
//}


GenerateInterp struct {
	semantic Semantic^
	interp Interp^
	frameOffset i64
	retOffset i64
	retDiscardSize i64

	offsets Table(Expr^, i64)
	currentFrame DebugFrame^
    addressContext i32
    context DynamicArray(i32)
}


ContextStore	i32 = 1
ContextLoad		i32 = 2
ContextDiscard	i32 = 3


Context fn(self ref GenerateInterp) i32 
{
	return self.context.Last()
}
PushContext fn(self ref GenerateInterp, context i32) 
{
	self.context.Push(context)
}
PopContext fn(self ref GenerateInterp) 
{
	self.context.Pop()
}

Init fn(generate ref GenerateInterp, semantic ref Semantic, ast ref Block, interp ref Interp) {
	
	generate.interp = &interp
	generate.semantic = &semantic
	generate.offsets.Init()
	generate.context.Init()
	generate.PushContext(ContextLoad)

	for i64(0) .. ast.expressions.length {
		expr Expr^ = ast.expressions[it]
		generate.Visit(^expr)
	}

	for i64(0) .. gSpecializations.length {
		spec FunctionSpec^ = gSpecializations[it]
		if !spec.incomplete 
		{
			spec.Apply()
			generate.semantic.Visit(spec.function.super)
			generate.Visit(spec.function.super)
            spec.Clear()

		}
	}
}
StructureFromType fn(typ ref Type) Structure^ {
    resolved Type^ = typ.Resolved()
    if resolved.Is(TypeIdentifier) {
    	return resolved.As(TypeIdentifier).spec.As(Structure)
    }
    else if resolved.Is(TypeGeneric) {
        
        self TypeGeneric^ = resolved.As(TypeGeneric)
        spec StructureSpec^ = self.spec.As(StructureSpec)
        spec.structure.Apply(^spec)
        return spec.structure
    }
   
   Assert(0, 'Cannot resolve type to a structure')
   return cast(Structure^, 0)
}
Visit fn(generate ref GenerateInterp, expr ref Expr) 
{
    
	if expr.Is(Block) {
		self Block^ = expr.As(Block)
		generate.PushContext(ContextDiscard)
		for i64(0) .. self.expressions.length {
			expr Expr^ = self.expressions[it]
			generate.Visit(^expr)
		}
		generate.PopContext()
		return
	}
	if expr.Is(Structure) {
		self Structure^ = expr.As(Structure)
		return
	}
	if expr.Is(Function) {
		self Function^ = expr.As(Function)
		if generate.semantic.intrinsic.IsIntrinsic(self) 
		{
			return
		}

		if self.any.length == 0 || cast(i64, self.spec) != 0 
		{
            ident str = self.Name()

			generate.currentFrame = new(DebugFrame)
			generate.currentFrame.Init(self)

			if self.block 
			{

				resultSize i64
				if self.result {
					resultSize = Size(self.result)
				}


				generate.frameOffset = -(Size(self.params) + 16)
				generate.retOffset = generate.frameOffset
			//	generate.frameOffset = generate.frameOffset + resultSize
				for i64(0) .. self.params.list.length 
				{
					Print('Param -- ')
					generate.Visit(^self.params.list[it])
				}

				Assert(generate.frameOffset == -16, 'Expected -16 frame offset, space for return and frame ptr')
				generate.frameOffset = 0
				generate.interp.AddLabel(ident)
		
				generate.currentFrame.startInstr = generate.interp.instructionsSize
				generate.interp.frames[generate.interp.instructionsSize] = generate.currentFrame
				generate.interp.frameArray.Push(generate.currentFrame)

				generate.Visit(self.block.super)
				generate.interp.AddValue(ReturnInstr)
				generate.currentFrame.endInstr = generate.interp.instructionsSize - 1
				Println('')
				Println('')
			}
			else {

				generate.retOffset = 0
				generate.frameOffset = 0 // doesn't really matter here
				generate.interp.AddExternCallLabel(ident)
			}
		}
		return
	}
	if expr.Is(Call) 
	{
		self Call^ = expr.As(Call)
		if self.func.Is(Function) 
		{
			function Function^ = self.func.As(Function)
			if generate.semantic.intrinsic.IsIntrinsic(function) 
			{
				generate.GenerateIntrinsic(function, &self.params)
			}
			else 
			{
				ident str = function.Name()
				if function.block {
					generate.PushContext(ContextLoad)
					if function.result {
						generate.ReserveResult(function.result)
					}
					for i64(0) .. self.params.list.length 
					{
						generate.PerformVisitAutoReference(^self.params.list[it], i64(self.drefCount[it]))

					}
					generate.interp.AddCall(ident)
					generate.Discard(Size(function.params))
					generate.PopContext()
				}
				else 
				{
					generate.PushContext(ContextLoad)
					for i64(0) .. self.params.list.length 
					{
						i i64 = self.params.list.length - it - 1
						generate.Visit(^self.params.list[i])
					}
					generate.PopContext()

					for i64(0) .. self.params.list.length 
					{
						t Type^ = self.params.list[it].typ.Resolved()
						// These go in reverse order since we will be popping these values from the stack but the instructions go in forward order!
                        if t.Is(TypeRef) {
                            generate.interp.AddValue(ParamExtern_Ptr)
                        }
						else if t.As(TypeIdentifier).spec == &generate.semantic.intrinsic.i32_.super {
							generate.interp.AddValue(ParamExtern_32)
						}
						else if t.As(TypeIdentifier).spec == &generate.semantic.intrinsic.i64_.super {
							generate.interp.AddValue(ParamExtern_64)
						}
						else if t.As(TypeIdentifier).spec == &generate.semantic.intrinsic.u64_.super {
							generate.interp.AddValue(ParamExtern_64)
						}
						else {
							Assert(0, 'Parameter is of invalid type in @extern call, we only support basic types and pointers')
						}
					}
					if !function.result {
						generate.interp.AddCallExternVoid(ident)
					}
					else if function.result.Resolved().Is(TypeRef) {
						generate.interp.AddCallExternPtr(ident)
					}
					else if function.result.Resolved().As(TypeIdentifier).spec == &generate.semantic.intrinsic.i32_.super ||
							function.result.Resolved().As(TypeIdentifier).spec == &generate.semantic.intrinsic.u32_.super
					{
						generate.interp.AddCallExtern32(ident)
					}
					else if function.result.Resolved().As(TypeIdentifier).spec == &generate.semantic.intrinsic.u64_.super ||
							function.result.Resolved().As(TypeIdentifier).spec == &generate.semantic.intrinsic.i64_.super
					{
						generate.interp.AddCallExtern64(ident)
					}
					else {
						Assert(0, 'Return is of invalid type in @extern call, we only support basic types and pointers')
	
					}
				}
			}
			if function.result {
				if generate.Context() == ContextDiscard {
					generate.Discard(Size(function.result))
				}
			}
		}
		else if self.func.Is(FunctionSpec) 
		{
			spec FunctionSpec^ = self.func.As(FunctionSpec)
			function Function^ = spec.function
            prev FunctionSpec^ = function.spec
            spec.Apply()
			if generate.semantic.intrinsic.IsIntrinsic(function) 
			{
				generate.GenerateIntrinsic(function, &self.params)
			}
			else 
			{
                
                generate.PushContext(ContextLoad)
				ident str = function.Name()

				if function.block {
					if function.result {
						generate.ReserveResult(function.result)
					}
					for i64(0) .. self.params.list.length 
					{
						generate.PerformVisitAutoReference(^self.params.list[it], i64(self.drefCount[it]))
					}
					
					generate.interp.AddCall(ident)
					generate.Discard(Size(function.params))
				}
				generate.PopContext()

				//generate.interp.AddCall(ident)			
			}
			if function.result {
				if generate.Context() == ContextDiscard {
					generate.Discard(Size(function.result))
				}
			}
            if prev {
                prev.Apply()
            }
            else {
                spec.Clear()
            }
		}
		else {
			Assert(0, 'Expected fn or fn spec ' + String(self.operand.kind))
		}
		return
	}
	if expr.Is(Variable) {
		self Variable^ = expr.As(Variable)
		generate.AddVariable(self)

		//if !self.super.typ.Is(TypeType) 
		//{
		//	generate.impl.Visit(^self.super.typ)
		//	generate.impl.Write(' ')
		//	generate.impl.Write(self.ident)
		//	if self.assign {
		//		generate.impl.Write('=')
		//		generate.Visit(^self.assign)
		//	}
		//	else {
		//		generate.impl.Write('={0}')
		//	}
		//}
		return
	}
	if expr.Is(Identifier) {
		self Identifier^ = expr.As(Identifier)
		if !self.reference {
			Println('not loading ident: ' + self.ident + ' no referenced object')
			Assert(generate.Context() == ContextLoad, 'Internal: Expected value context why would you take the address of something that doesnt refer to an address')
			return
		}
        if generate.Context() == ContextStore 
        {
            a i64 = generate.offsets[self.reference]
            generate.LoadAddressFromOffset(a)
        }
        else if generate.Context() == ContextLoad 
        {
            a i64 = generate.offsets[self.reference] 
            generate.LoadOffsetInstr(a, Size(self.reference))
		//generate.impl.Write(self.ident)
        }
        else 
        {
        	Println('unused variable ' + self.ident)
        }
		return
	}
	if expr.Is(ForList) {
		self ForList^ = expr.As(ForList)

		//Println('Jump: offset: ' + String(generate.frameOffset))
		//generate.interp.AddValue(JumpInstr)
		//generate.interp.AddValue(generate.frameOffset)

		//for i64(0) .. self.list.list.length {
		//	generate.semantic.SetIt(^self, self.list.list[it])
		//	generate.impl.Write('/*ForList ' + String(it) + '*/')
		//	self.it.assign = self.list.list[it]
		//	self.it.super.typ = self.list.list[it].typ
		//	Assert(self.it.super.typ)
		//	//generate.Visit(self.it.super)
		//	generate.Visit(self.block.super)
		//}
		//generate.impl.Write(' ')
		//generate.impl.Write(self.ident)
		return
	}
	if expr.Is(For) {
		self For^ = expr.As(For)
		generate.PushContext(ContextLoad)

		if self.to {
			generate.Visit(self.it.super)
			generate.Visit(^self.it.assign) //Push right on the stack
			generate.interp.StoreOffsetInstr(generate.offsets[&self.it.super], Size(self.it.assign.typ))	// Pop and store
		}

		start i64 = generate.interp.instructionsSize
		Println('start:')

		if self.to {
			generate.Visit(self.test.super)
		}
		else {
			Assert(Size(self.from) == 1)
			generate.Visit(^self.from)
		}

		//generate.FrameOffset(-1)

		PrintTabs(1)
		Println('Jump: end ')
		generate.interp.AddValue(JumpInstr)
		at i64^ = generate.interp.AddValue(i64(0))
        generate.PopContext()

		generate.Visit(self.block.super)
	
		generate.PushContext(ContextLoad)
		if self.to {
			generate.Visit(^self.inc)
		}
		generate.interp.AddLoadConstInstr(i8(0))
		generate.interp.AddValue(JumpInstr)
		generate.interp.AddValue(i64(start))
		PrintTabs(1)
		Println('Jump: start')
		Println('end:')
		^at = generate.interp.instructionsSize
        generate.PopContext()
		return
	}
	
	if expr.Is(If) {
		self If^ = expr.As(If)
		generate.PushContext(ContextLoad)
		generate.Visit(^self.condition)
		generate.PopContext()

		PrintTabs(1)
		Println('Jump: end ')
		generate.interp.AddValue(JumpInstr)
		at i64^ = generate.interp.AddValue(i64(0))
		generate.Visit(self.trueBranch.super)
		^at = generate.interp.instructionsSize
		Println('end:')
		return
	}

	if expr.Is(Access) {
		self Access^ = expr.As(Access)

		if self.call {
			generate.Visit(self.call.super)
			return
		}

        Println('context address')
		generate.PushContext(ContextStore)
		generate.Visit(^self.operand)
		generate.PopContext()

		structure Structure^ = self.operand.typ.StructureFromType()
		if generate.Context() == ContextStore {
			generate.AddOffsetToAddress(structure.OffsetOfMemeber(self.field))
		}
		else 
		{
			Println('context value')
			generate.AddOffsetToAddress(structure.OffsetOfMemeber(self.field))
			generate.LoadAddressInstr(Size(self.super.typ))
		}
		//generate.Visit(^self.field)
		return
	}
    
	if expr.Is(Assign) {
		self Assign^ = expr.As(Assign)
		if self.drefCount > 0{

			generate.PushContext(ContextStore)
			generate.Visit(^self.right)
			generate.PopContext()

			generate.PushContext(ContextStore)
			generate.Visit(^self.left) // Calculate the address to store
			generate.PopContext()

			leftSize i64 = Size(self.left.typ)
			generate.Store(leftSize, 0)	// Pop adddress and store
			return
		}
		else if self.drefCount < 0 {

			//Load this reference into an address to store to
			generate.PushContext(ContextLoad)
			generate.Visit(^self.right)
			generate.PopContext()

			generate.PushContext(ContextStore)
			generate.Visit(^self.left) // Calculate the address to store
			generate.PopContext()
			// We use the right side size because we are dereferencing the left
			// the other option is get the referenced type on the left
			rightSize i64 = Size(self.right.typ)
			generate.Store(rightSize, 0)	// Pop adddress and store
			return
		}

		generate.PushContext(ContextLoad)
		generate.Visit(^self.right) // Push the value on the stack
		generate.PopContext()

		generate.PushContext(ContextStore)
		generate.Visit(^self.left) // Calculate the address to store
		generate.PopContext()

		leftSize i64 = Size(self.left.typ)
		rightSize i64 = Size(self.right.typ)
		Assert(leftSize == rightSize, 'Internal compiler interp error: Expected same size arguments for assign')

		generate.Store(rightSize, 0)	// Pop adddress and store

		return
	}
	if expr.Is(Return) {
		generate.PushContext(ContextLoad)
		self Return^ = expr.As(Return)
		generate.Visit(^self.expr)
		generate.interp.StoreOffsetInstr(generate.retOffset, Size(self.expr.typ))
		generate.PopContext()
		return
	}
	if expr.Is(Trait) {
		self Trait^ = expr.As(Trait)
		return
	}
	if expr.Is(NumberConstant) {
		self NumberConstant^ = expr.As(NumberConstant)
		generate.LoadConst(i64FromString(self.value))
		//generate.impl.Write(self.value)
		return
	}
	if expr.Is(StringConstant) {
		self StringConstant^ = expr.As(StringConstant)
		generate.LoadConst(cast(i64, self.value.chars))
		return
	}
	//generate.impl.Write('---- unhandled node ' + String(expr.kind) + '---- \n')
}

PerformVisitAutoReference fn(self ref GenerateInterp, expr ref Expr, count i64) { 
	if count < 0 {
		self.PerformReference(expr, -count)
		return
	}
	else if count > 0 {
		self.PerformDereference(expr, count)
		return
	}
	Assert(count == 0, 'Internal: expected count == 0')
	self.Visit(expr)
}
PerformReference fn(self ref GenerateInterp, expr ref Expr, count i64) {
	Assert(count == 1, 'Internal: expected dref count greater than 0')
	Assert(self.Context() == ContextLoad)

	Println('ref')
	self.PushContext(ContextStore)
	self.Visit(expr)
	self.PopContext()
}

PerformDereference fn(self ref GenerateInterp, expr ref Expr, count i64) {
	
	Assert(count > 0, 'Internal: expected dref count greater than 0')
	// load initial reference
	Println('dref')
	self.PushContext(ContextLoad)
	self.Visit(expr)
	self.PopContext()


	currentType Type^ = expr.typ

	for i64(0) .. count {
		Assert(currentType.Is(TypeRef), 'Expected reference to derference')

		currentType = currentType.As(TypeRef).reference
		self.LoadAddressInstr(Size(currentType))

	}

	// This isn't for dref store operations only for loads
	Assert(self.Context() == ContextLoad)
}


GenerateIntrinsic fn(generate ref GenerateInterp, function Function^, args ExpressionList^) {

	if function == &generate.semantic.intrinsic.abortFn {
		generate.interp.AddValue(TrapInstr)
		generate.interp.AddValue(TrapAbort)
		return
	}
	if function.ident == '&' {
		generate.PushContext(ContextStore)
		for i64(0) .. args.list.length {
			generate.Visit(^args.list[it])
		}
		generate.PopContext()
		return
	}

	// Everything inside a dref tag is a value
	else if function.ident == 'dref' {
		generate.PushContext(ContextLoad)
		//Println('context address')
		for i64(0) .. args.list.length {
			generate.Visit(^args.list[it])
		}
		//Println('context end')
		generate.PopContext()
	}
	else 
	{
		generate.PushContext(ContextLoad)
		for i64(0) .. args.list.length {
			generate.Visit(^args.list[it])
		}
		generate.PopContext()
	}

	if function == &generate.semantic.intrinsic.ptr_add {
		generate.interp.AddValue(AddPtrInstr)
		size i64 = Size(args.list[0].typ.As(TypeRef).reference)
		generate.interp.AddValue(size)
		Println('Ptr + ' + String(size))
		return
	}

	if function == &generate.semantic.intrinsic.sizeFn {
		size i64 = Size(args.list[0].typ.As(TypeType).reference)
		generate.LoadConst(cast(i64, size))
		Print('Size() : ' + String(size))
		Print('    ')
		Print(^args.list[0].typ)
		Println('')
		return
	}

	if function == &generate.semantic.intrinsic.castOp {
		Println('Cast +')
		Assert(Size(args.list[0].typ.Resolved().As(TypeType).reference) == Size(args.list[1].typ), 'Cant cast to between differnt sized types')
		return
	}


 	// Theses all push two values on the stack and pop one thus 1 - 2 = -1 thus 1 pop
	if function.ident == '+' {
		generate.interp.AddValue(AddInstr_i64)
	}
	else if function.ident == '-' {
		generate.interp.AddValue(SubInstr_i64)
	}
	else if function.ident == '/' {
		generate.interp.AddValue(DivInstr_i64)
	}
	else if function.ident == '*' {
		generate.interp.AddValue(MulInstr_i64)
	}
	else if function.ident == '%' {
		generate.interp.AddValue(ModInstr_i64)
	}
	else if function.ident == '==' {
		PrintTabs(1) Println('Comp: == i64')
		generate.interp.AddValue(CompareInstr_i64)
		generate.interp.AddValue(TestEqInstr) // pop i8 then push i8 net 0
	}
	else if function.ident == '!=' {
		PrintTabs(1) Println('Comp: != i64')
		generate.interp.AddValue(CompareInstr_i64)
		generate.interp.AddValue(TestNotEqInstr) // pop i8 then push i8 net 0
	}
	else if function.ident == '<' {
		PrintTabs(1) Println('Comp: < i64')
		generate.interp.AddValue(CompareInstr_i64)
		generate.interp.AddValue(TestLessInstr) // pop i8 then push i8 net 0
	}
	else if function.ident == '>' {
		PrintTabs(1) Println('Comp: > i64')
		generate.interp.AddValue(CompareInstr_i64)
		generate.interp.AddValue(TestGreaterInstr) // pop i8 then push i8 net 0
	}
	else if function.ident == '<=' {
		PrintTabs(1) Println('Comp: <= i64')
		generate.interp.AddValue(CompareInstr_i64)
		generate.interp.AddValue(TestLessEqInstr) // pop i8 then push i8 net 0
	}
	else if function.ident == '>=' {
		PrintTabs(1) Println('Comp: >= i64')
		generate.interp.AddValue(CompareInstr_i64)
		generate.interp.AddValue(TestGreaterEqInstr) // pop i8 then push i8 net 0
	}
	else if function.ident == 'dref' {
		if generate.Context() == ContextStore {
			Println('dref: no op context store')
		}
		else {
			Print('dref:')
			generate.LoadAddressInstr(Size(args.list[0].typ.Resolved().As(TypeRef).reference))
		}
	}
	else if function.ident == 'i32' {
		Println('widen')

		if function == &generate.semantic.intrinsic.i64_to_i32 {
			generate.interp.AddValue(ConvertInstr_64_32)
			PrintTabs(1)
			//Println('asdfasdfasndfnasdfbsdfbasdbfbasdfbsdabfbasdbf')
		}

		if function == &generate.semantic.intrinsic.i8_to_i32 {
			generate.interp.AddValue(WidenInstr_8_64)
			PrintTabs(1)
		}
		if function == &generate.semantic.intrinsic.i16_to_i32 {
            generate.interp.AddValue(WidenInstr_16_64)
		}
		if function == &generate.semantic.intrinsic.f32_to_i32 {
			generate.interp.AddValue(CastInstr_f32_i64)
		}
		if function == &generate.semantic.intrinsic.f64_to_i32 {
            generate.interp.AddValue(CastInstr_f64_i64)
        }
	}
	else if function.ident == 'i64' {
        if function == &generate.semantic.intrinsic.i8_to_i64 {
            generate.interp.AddValue(WidenInstr_8_64)
        }
        if function == &generate.semantic.intrinsic.i16_to_i64 {
            generate.interp.AddValue(WidenInstr_16_64)
        }
        if function == &generate.semantic.intrinsic.i32_to_i64 {
            generate.interp.AddValue(WidenInstr_32_64)
        }
        if function == &generate.semantic.intrinsic.f32_to_i64 {
            generate.interp.AddValue(CastInstr_f32_i64)
        }
        if function == &generate.semantic.intrinsic.f64_to_i64 {
            generate.interp.AddValue(CastInstr_f64_i64)
        }
	}
	else if function.ident == 'u64' {
		if function == &generate.semantic.intrinsic.i32_to_u64 {
            generate.interp.AddValue(WidenInstr_32_64)
        }
	}
	else
	{
		Println('----unhandled intrinsic interp -----' + function.ident)
		Assert(0)
	}
}
