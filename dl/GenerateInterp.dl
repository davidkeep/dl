

@import {
	'Semantic.dl',
	'Generate.dl',
	'Interp.dl',
}

Size fn(t Type^) i64 {
	typ Type^ = t.Resolved()
	if typ.Is(TypeRef) {
		return 8
	}
	else if typ.Is(TypeIdentifier) {
		spec Expr^ = typ.As(TypeIdentifier).spec
		structure Structure^ = spec.As(Structure)
		if structure.ident == 'i8' {
			return 1
		}
		if structure.ident == 'i16' {
			return 2
		}
		if structure.ident == 'i32' {
			return 4
		}
		if structure.ident == 'i64' {
			return 8
		}

		size i64

		for i64(0) .. structure.fields.length {
			size = size + Size(structure.fields[it].super.typ)
		}
		return size
	}
	if typ.Is(TypeGeneric) {
		self TypeGeneric^ = typ.As(TypeGeneric)
		spec StructureSpec^ spec = self.spec.As(StructureSpec)
		spec.structure.Apply(^spec)
		return Size(spec.structure.typeIdent)
	}
	Println('unhandled type for Size : ' + String(t.kind))
	Assert(0)
	return 0
}
Size fn(expressions ref ExpressionList) i64
{
	size i64
	for i64(0) .. expressions.list.length {
		size = size + Size(expressions.list[it].typ)
	}
	return size
}

OffsetOfMemeber fn (self ref Structure, field str) i64 
{
	offset i64

	for i64(0) .. self.fields.length {
		fieldVar Variable^ = self.fields[it]

		// The offset is calculated at the top thus the first field has an offset of 0
		if fieldVar.ident == field {
			//Println('offset ' + fieldVar.ident + ' ' + String(offset))
			return offset
		}
		offset = offset + Size(fieldVar.super.typ)
	}

	Assert(0, 'No field named ' + field + ' on structure ' + self.ident)
	return 0
}

AddVariable fn(self ref GenerateInterp, variable Variable^) {

	size i64 = Size(variable.super.typ)
	self.FrameOffset(size)

	local DebugLocal^ = new(DebugLocal)
	local.Init(variable, self.frameOffset)
	local.instr = self.interp.instructionsSize
	self.currentFrame.locals.Push(local)

	self.interp.AddValue(LoadConst)
	self.interp.AddValue(i64(size))

	// Zero out this mem
	for i64(0) .. size {
		self.interp.AddSpace(i8(0))
	}
	PrintTabs(1)
	Println('variable: ' + variable.ident + ' size:' + String(size) + '		frame:' + String(self.frameOffset))
	self.offsets[&variable.super] = self.frameOffset
}

LoadConst fn(self ref GenerateInterp, value T?) {
	self.interp.AddLoadConstInstr(value)
}


FrameOffset fn(self ref GenerateInterp, offset i64) {
	self.frameOffset = self.frameOffset + offset
}

PushParameter fn(self ref GenerateInterp, variable Variable^) 
{

	size i64 = i64(i32.size)
	self.interp.AddValue(LoadConst)
	self.interp.AddValue(i64(size))
	self.interp.AddValue(i32(0))
	PrintTabs(1)
	Println('param: ' + variable.ident + ' size:' + String(size) + '		frame:' + String(self.frameOffset))
}

ReserveResult fn(self ref GenerateInterp, typ Type^) {

	size i64 = Size(typ)
	self.interp.AddValue(LoadConst)
	self.interp.AddValue(i64(size))

	// Zero out this mem
	for i64(0) .. size {
		self.interp.AddValue(i8(0))
	}
	PrintTabs(1)
	Println('result:  size:' + String(size) + '		frame:' + String(self.frameOffset))
	self.FrameOffset(size)
}

LoadAddressInstr fn(self ref GenerateInterp, size i64) {
	self.interp.AddValue(LoadAddressInstr)
	self.interp.AddValue(cast(i64, size))

	PrintTabs(1)
	Println('load address size: ' + String(size))
}

Discard fn(self ref GenerateInterp, size i64) {
	self.interp.AddValue(DiscardInstr)
	self.interp.AddValue(cast(i64, size))

	PrintTabs(1)
	Println('discard size: ' + String(size))
}


LoadAddressFromOffset fn(self ref GenerateInterp, offset i64) {
	self.interp.AddValue(LoadAddressFromOffsetInstr)
	self.interp.AddValue(offset)

	PrintTabs(1)
	Println('load address from offset: ' + String(offset))
}

LoadOffsetInstr fn(self ref GenerateInterp, offset i64, size i64) {

	self.interp.AddValue(LoadOffsetInstr)
	self.interp.AddValue(cast(i64, size))
	self.interp.AddValue(cast(i64, offset))
	//self.frameOffset = self.frameOffset + size

	PrintTabs(1)
	Println('load: ' + String(size) + ' offset: ' + String(offset) + '     frame:' + String(self.frameOffset))
}

Store fn(self ref GenerateInterp, size i64, offset i64) {
	self.interp.AddValue(StoreInstr)
	self.interp.AddValue(cast(i64, size))
	self.interp.AddValue(cast(i64, offset))
	PrintTabs(1)
	Println('store: ' + String(size) + ' offset: ' + String(offset))
}

AddOffsetToAddress fn(self ref GenerateInterp, offset i64) {
	self.interp.AddValue(AddOffsetToAddressInstr)
	self.interp.AddValue(cast(i64, offset))
	PrintTabs(1)
	Println('add offset: ' + String(offset))
}

//AddCall fn(self ref Interp, name str) 
//{
//	PrintTabs(1)
//	Println('call: ' + name)
//	self.AddLoadConstInstr(self.GetLabel(name))
//	self.AddValue(CallInstr)
//}

//AddCallExtern fn(self ref Interp, name str) {
//	func voidptr = dlsym(self.dlhandle, name.chars)
//	self.AddValue(CallExtern)
//	self.AddValue(cast(i64, func))
//	PrintTabs(1)
//	Println('call extern: ' + name)
//}


//AddExternCallLabel fn(self ref Interp, name str) {
//	func voidptr = dlsym(self.dlhandle, name.chars)
//	self.labels[name] = cast(i64, func)
//	PrintTabs(1)
//	Println('label extern:  ' + name)
//}


GenerateInterp struct {
	semantic Semantic^
	interp Interp^
	frameOffset i64
	retOffset i64

	offsets Table(Expr^, i64)
	currentFrame DebugFrame^
    addressContext i32
    context DynamicArray(i32)
}

ContextStore	i32 = 1
ContextLoad		i32 = 2


Context fn(self ref GenerateInterp) i32 {
	return self.context.Last()
}
PushContext fn(self ref GenerateInterp, context i32) {
	self.context.Push(context)
	if self.Context() == ContextLoad {
				Println('load ctx')
	}
	else {
				Println('store ctx')
	}
}
PopContext fn(self ref GenerateInterp) {
	self.context.Pop()
	if self.Context() == ContextLoad {
				Println('load ctx')
	}
	else {
				Println('store ctx')
	}
}

Init fn(generate ref GenerateInterp, semantic ref Semantic, ast ref Block, interp ref Interp) {
	
	generate.interp = &interp
	generate.semantic = &semantic
	generate.offsets.Init()
	generate.context.Init()
	generate.PushContext(ContextLoad)

	for i64(0) .. ast.expressions.length {
		expr Expr^ = ast.expressions[it]
		generate.Visit(^expr)
	}

	for i64(0) .. gSpecializations.length {
		spec FunctionSpec^ = gSpecializations[it]
		if !spec.incomplete 
		{
			spec.Apply()
			generate.semantic.Visit(spec.function.super)
			generate.Visit(spec.function.super)
            spec.Clear()

		}
	}
}
StructureFromType fn(typ ref Type) Structure^ {
    resolved Type^ = typ.Resolved()
    if resolved.Is(TypeIdentifier) {
    	return resolved.As(TypeIdentifier).spec.As(Structure)
    }
    else if resolved.Is(TypeGeneric) {
        
        self TypeGeneric^ = resolved.As(TypeGeneric)
        spec StructureSpec^ = self.spec.As(StructureSpec)
        spec.structure.Apply(^spec)
        return spec.structure
    }
   
   Assert(0, 'Cannot resolve type to a structure')
   return cast(Structure^, 0)
}
Visit fn(generate ref GenerateInterp, expr ref Expr) 
{
    
	if expr.Is(Block) {
		self Block^ = expr.As(Block)
		for i64(0) .. self.expressions.length {
			expr Expr^ = self.expressions[it]
			generate.Visit(^expr)
		}
		return
	}
	if expr.Is(Structure) {
		self Structure^ = expr.As(Structure)
		return
	}
	if expr.Is(Function) {
		self Function^ = expr.As(Function)
		if generate.semantic.intrinsic.IsIntrinsic(self) 
		{
			return
		}

		if self.any.length == 0 || cast(i64, self.spec) != 0 
		{
            ident str = self.Name()

			generate.currentFrame = new(DebugFrame)
			generate.currentFrame.Init(self)

			if self.block 
			{

				resultSize i64
				if self.result {
					resultSize = Size(self.result)
				}


				generate.frameOffset = -(Size(self.params) + 16)
				generate.retOffset = generate.frameOffset
			//	generate.frameOffset = generate.frameOffset + resultSize
				for i64(0) .. self.params.list.length 
				{
					Print('Param -- ')
					generate.Visit(^self.params.list[it])
				}

				Assert(generate.frameOffset == -(16), 'Expected -16 frame offset, space for return and frame ptr')
				generate.frameOffset = 0
				generate.interp.AddLabel(ident)
		
				generate.currentFrame.startInstr = generate.interp.instructionsSize
				generate.interp.frames[generate.interp.instructionsSize] = generate.currentFrame
				generate.interp.frameArray.Push(generate.currentFrame)

				generate.Visit(self.block.super)
				generate.interp.AddValue(ReturnInstr)
				generate.currentFrame.endInstr = generate.interp.instructionsSize - 1
				Println('')
				Println('')
			}
			else {

				generate.retOffset = 0
				generate.frameOffset = 0 // doesn't really matter here
				generate.interp.AddExternCallLabel(ident)
			}
		}
		return
	}
	if expr.Is(Call) 
	{
		self Call^ = expr.As(Call)
		if self.func.Is(Function) 
		{
			function Function^ = self.func.As(Function)
			if generate.semantic.intrinsic.IsIntrinsic(function) 
			{
				generate.GenerateIntrinsic(function, &self.params)
			}
			else 
			{


				ident str = function.Name()
				if function.block {
					generate.PushContext(ContextLoad)
					if function.result {
						generate.ReserveResult(function.result)
					}
					for i64(0) .. self.params.list.length 
					{
						generate.Visit(^self.params.list[it])
					}
					
					generate.interp.AddCall(ident)
					generate.Discard(Size(self.params))
					generate.PopContext()

				}
				else 
				{

					for i64(0) .. self.params.list.length 
					{
						t Type^ = self.params.list[it].typ.Resolved()
						expr Expr^ = self.params.list[it]
						if t.As(TypeIdentifier).spec == &generate.semantic.intrinsic.i32_.super {
							generate.Visit(^self.params.list[it])
							generate.interp.AddValue(ParamExtern_32)
						}
						else {
							Assert(0, 'Parameter is of invalid type in @extern call, we only support basic types and pointers')
						}
					}
					generate.interp.AddCallExtern(ident)
				}
			}
		}
		else if self.func.Is(FunctionSpec) 
		{
			spec FunctionSpec^ = self.func.As(FunctionSpec)
			function Function^ = spec.function
            prev FunctionSpec^ = function.spec
            spec.Apply()
			if generate.semantic.intrinsic.IsIntrinsic(function) 
			{
				generate.GenerateIntrinsic(function, &self.params)
			}
			else 
			{
                
                generate.PushContext(ContextLoad)
				ident str = function.Name()

				if function.block {
					if function.result {
						generate.ReserveResult(function.result)
					}
					for i64(0) .. self.params.list.length 
					{
						generate.Visit(^self.params.list[it])
					}
					
					generate.interp.AddCall(ident)
					generate.Discard(Size(self.params))
				}
				generate.PopContext()

				//generate.interp.AddCall(ident)			
			}
            if prev {
                prev.Apply()
            }
            else {
                spec.Clear()
            }
		}
		else {
			Assert(0, 'Expected fn or fn spec ' + String(self.operand.kind))
		}
		return
	}
	if expr.Is(Variable) {
		self Variable^ = expr.As(Variable)
		generate.AddVariable(self)

		//if !self.super.typ.Is(TypeType) 
		//{
		//	generate.impl.Visit(^self.super.typ)
		//	generate.impl.Write(' ')
		//	generate.impl.Write(self.ident)
		//	if self.assign {
		//		generate.impl.Write('=')
		//		generate.Visit(^self.assign)
		//	}
		//	else {
		//		generate.impl.Write('={0}')
		//	}
		//}
		return
	}
	if expr.Is(Identifier) {
		self Identifier^ = expr.As(Identifier)
        if generate.Context() == ContextStore {
            a i64 = generate.offsets[self.reference]
            generate.LoadAddressFromOffset(a)
        }
        else {
            a i64 = generate.offsets[self.reference] 
            generate.LoadOffsetInstr(a, Size(self.reference.typ))
		//generate.impl.Write(self.ident)
        }
		return
	}
	if expr.Is(ForList) {
		self ForList^ = expr.As(ForList)

		//Println('Jump: offset: ' + String(generate.frameOffset))
		//generate.interp.AddValue(JumpInstr)
		//generate.interp.AddValue(generate.frameOffset)

		//for i64(0) .. self.list.list.length {
		//	generate.semantic.SetIt(^self, self.list.list[it])
		//	generate.impl.Write('/*ForList ' + String(it) + '*/')
		//	self.it.assign = self.list.list[it]
		//	self.it.super.typ = self.list.list[it].typ
		//	Assert(self.it.super.typ)
		//	//generate.Visit(self.it.super)
		//	generate.Visit(self.block.super)
		//}
		//generate.impl.Write(' ')
		//generate.impl.Write(self.ident)
		return
	}
	if expr.Is(For) {
		self For^ = expr.As(For)

		if self.to {
			generate.Visit(self.it.super)
			generate.Visit(^self.it.assign) //Push right on the stack
			generate.interp.StoreOffsetInstr(generate.offsets[&self.it.super], 4)	// Pop and store
		}

		start i64 = generate.interp.instructionsSize
		Println('start:')

		if self.to {
			generate.Visit(self.test.super)
		}
		else {
			generate.Visit(^self.from)
		}

		//generate.FrameOffset(-1)

		PrintTabs(1)
		Println('Jump: end ')
		generate.interp.AddValue(JumpInstr)
		at i64^ = generate.interp.AddValue(i64(0))

		generate.Visit(self.block.super)
		
		if self.to {
			generate.Visit(^self.inc)
		}
		generate.interp.AddLoadConstInstr(i8(0))
		generate.interp.AddValue(JumpInstr)
		generate.interp.AddValue(i64(start))
		PrintTabs(1)
		Println('Jump: start')
		Println('end:')
		^at = generate.interp.instructionsSize
        
		return
	}
	
	if expr.Is(If) {
		self If^ = expr.As(If)


		generate.Visit(^self.condition)
		PrintTabs(1)
		Println('Jump: end ')
		generate.interp.AddValue(JumpInstr)
		at i64^ = generate.interp.AddValue(i64(0))
		generate.Visit(self.trueBranch.super)
		^at = generate.interp.instructionsSize
		Println('end:')
		return
	}

	if expr.Is(Access) {
		self Access^ = expr.As(Access)
        
        Println('context address')
		generate.PushContext(ContextStore)
		generate.Visit(^self.operand)
		generate.PopContext()

		structure Structure^ = self.operand.typ.StructureFromType()
		if generate.Context() == ContextStore {
			generate.AddOffsetToAddress(structure.OffsetOfMemeber(self.field))
		}
		else 
		{
			Println('context value')
			generate.AddOffsetToAddress(structure.OffsetOfMemeber(self.field))
			generate.LoadAddressInstr(Size(self.super.typ))
		}
		//generate.Visit(^self.field)
		return
	}
    
	if expr.Is(Assign) {
		self Assign^ = expr.As(Assign)
		//for i32(0) .. self.drefCount {
		//	generate.impl.Write('*')
		//}

		generate.Visit(^self.right) // Push the value on the stack

		generate.PushContext(ContextStore)
		generate.Visit(^self.left) // Calculate the address to store
		generate.PopContext()

		leftSize i64 = Size(self.left.typ)
		rightSize i64 = Size(self.right.typ)
		Assert(leftSize == rightSize, 'Internal compiler interp error: Expected same size arguments for assign')

		generate.Store(rightSize, 0)	// Pop adddress and store

		return
	}
	if expr.Is(Return) {
		self Return^ = expr.As(Return)
		generate.Visit(^self.expr)

		generate.interp.StoreOffsetInstr(generate.retOffset, Size(self.expr.typ))
		return
	}
	if expr.Is(Trait) {
		self Trait^ = expr.As(Trait)
		return
	}
	if expr.Is(NumberConstant) {
		self NumberConstant^ = expr.As(NumberConstant)
		generate.LoadConst(i32FromString(self.value))
		//generate.impl.Write(self.value)
		return
	}
	if expr.Is(StringConstant) {
		self StringConstant^ = expr.As(StringConstant)
		generate.LoadConst(cast(i64, self.value.chars))
		return
	}
	//generate.impl.Write('---- unhandled node ' + String(expr.kind) + '---- \n')
}


GenerateIntrinsic fn(generate ref GenerateInterp, function Function^, args ExpressionList^) {



	if function.ident == '&' {
		generate.PushContext(ContextStore)
		for i64(0) .. args.list.length {
			generate.Visit(^args.list[it])
		}
		generate.PopContext()
		return
	}

	// Everything inside a dref tag is a value
	else if function.ident == 'dref' {
		generate.PushContext(ContextLoad)
		//Println('context address')
		for i64(0) .. args.list.length {
			generate.Visit(^args.list[it])
		}
		//Println('context end')
		generate.PopContext()
	}
	else 
	{
		generate.PushContext(ContextLoad)
		for i64(0) .. args.list.length {
			generate.Visit(^args.list[it])
		}
		generate.PopContext()
	}

	if function == &generate.semantic.intrinsic.ptr_add {
		generate.interp.AddValue(AddInstr_i64)
		Println('Ptr +')
		return
	}

 	// Theses all push two values on the stack and pop one thus 1 - 2 = -1 thus 1 pop
	if function.ident == '+' {
		if function == &generate.semantic.intrinsic.ptr_add {
			generate.interp.AddValue(AddInstr_i64)
			Println('Ptr +')
		}
		else {
			generate.interp.AddValue(AddInstr_i64)
		}
	}
	else if function.ident == '*' {
		generate.interp.AddValue(MulInstr_i32)
	}
	else if function.ident == '==' {
		PrintTabs(1) Println('Comp: == i64')
		generate.interp.AddValue(CompareInstr_i64)
		generate.interp.AddValue(TestEqInstr) // pop i8 then push i8 net 0
	}
	else if function.ident == '!=' {
		PrintTabs(1) Println('Comp: != i64')
		generate.interp.AddValue(CompareInstr_i64)
		generate.interp.AddValue(TestNotEqInstr) // pop i8 then push i8 net 0
	}
	else if function.ident == '<' {
		PrintTabs(1) Println('Comp: < i64')
		generate.interp.AddValue(CompareInstr_i64)
		generate.interp.AddValue(TestLessInstr) // pop i8 then push i8 net 0
	}
	else if function.ident == 'dref' {
		if generate.Context() == ContextLoad {
			Print('dref:')
			generate.LoadAddressInstr(Size(args.list[0].typ.Resolved().As(TypeRef).reference))
		}
		else {
			Println('dref: no op context store')
		}
	}
	else if function.ident == 'i32' {
		Println('widen')

		if function == &generate.semantic.intrinsic.i64_to_i32 {
			generate.interp.AddValue(ConvertInstr_64_32)
			PrintTabs(1)
			//Println('asdfasdfasndfnasdfbsdfbasdbfbasdfbsdabfbasdbf')
		}

		if function == &generate.semantic.intrinsic.i8_to_i32 {
			generate.interp.AddValue(WidenInstr_8_64)
			PrintTabs(1)
		}
		if function == &generate.semantic.intrinsic.i16_to_i32 {
            generate.interp.AddValue(WidenInstr_16_64)
		}
		if function == &generate.semantic.intrinsic.f32_to_i32 {
			generate.interp.AddValue(CastInstr_f32_i64)
		}
		if function == &generate.semantic.intrinsic.f64_to_i32 {
            generate.interp.AddValue(CastInstr_f64_i64)
        }
	}
	else if function.ident == 'i64' {
        if function == &generate.semantic.intrinsic.i8_to_i64 {
            generate.interp.AddValue(WidenInstr_8_64)
        }
        if function == &generate.semantic.intrinsic.i16_to_i64 {
            generate.interp.AddValue(WidenInstr_16_64)
        }
        if function == &generate.semantic.intrinsic.i32_to_i64 {
            generate.interp.AddValue(WidenInstr_32_64)
        }
        if function == &generate.semantic.intrinsic.f32_to_i64 {
            generate.interp.AddValue(CastInstr_f32_i64)
        }
        if function == &generate.semantic.intrinsic.f64_to_i64 {
            generate.interp.AddValue(CastInstr_f64_i64)
        }
	}
	else
	{
		Println('----unhandled intrinsic interp -----')
		Assert(0)
	}
}
