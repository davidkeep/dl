
@import {
	'dl/Array.dl',
	'Expr/Expr.dl',
}

DCCallVM struct


RTLD_LAZY 	i32 = 1
RTLD_NOW	i32 = 2
RTLD_LOCAL	i32 = 4
RTLD_GLOBAL	i32 = 8

@extern {
	dcNewCallVM 	fn(size u32) DCCallVM^
	dcReset 		fn(vm DCCallVM^)
	dcArgChar   	fn(vm DCCallVM^, value i8)
	dcArgShort  	fn(vm DCCallVM^, value i16)
	dcArgInt    	fn(vm DCCallVM^, value i32)
	dcArgLong   	fn(vm DCCallVM^, value i64)
	dcArgFloat  	fn(vm DCCallVM^, value f32)
	dcArgDouble 	fn(vm DCCallVM^, value f64)
	dcArgPointer	fn(vm DCCallVM^, value voidptr)

	dcCallVoid      fn(vm DCCallVM^, func voidptr)
	dcCallChar      fn(vm DCCallVM^, func voidptr) i8
    dcCallShort     fn(vm DCCallVM^, func voidptr) i16
	dcCallInt       fn(vm DCCallVM^, func voidptr) i32
	dcCallLong      fn(vm DCCallVM^, func voidptr) i64
	dcCallFloat     fn(vm DCCallVM^, func voidptr) f32
	dcCallDouble    fn(vm DCCallVM^, func voidptr) f64
	dcCallPointer   fn(vm DCCallVM^, func voidptr) voidptr

	dlopen			fn(path i8^, mode i32) voidptr
	dlsym			fn(handle voidptr, symbol i8^) voidptr
}

@build {
	link = (		
		'-ldyncall_s', 
	)
}



AddInstr_i32 i8 	= 1		// stack left, right
AddInstr_i64 i8 	= 2		// stack left, right

MulInstr_i32 i8 	= 3		// stack left, right
Muli64 i8 	= 4		// stack left, right

Subi32 i8 	= 5
Loadi32 i8 	= 6		// size, address


CallInstr i8 	= 7	// return value, parameters, return pointer, address of procedure
ReturnInstr i8 	= 8




LoadInstr i8 		= 9
				// i8
				// i64 		size
				// i64 		address in stack


// Pushes value from offset
LoadOffsetInstr i8 		= 11
// i8 instr, i64 size, i64 offset
// >> [data(size)... ]


LoadAddressInstr i8 = 123
// Pops value to store from stack


// Takes the local offset and calculates an actual address
LoadAddressFromOffsetInstr    i8 = 125
// i8 instr
// << i64 offset
// >> i64 frame + offset

StoreOffsetInstr i8 		= 12
				// i8
				// i64 		size
				// i64 		offset in frame


StoreInstr i8 		= 124
// i8 instr, i64 size, i64 offset
// << [address, data ...]


//Immediate instructions
//Theses have their size followed by their data stored following the op code
LoadConst i8 	= 10	//	i8
						//	i64 --- the size in bytes
						//	data follows
						//	...
						//	...

// pushes i8  -1 if less 0 if equal 1 if greater
CompareInstr_i32 i8 = 49	// i8


// pop i8 from stack
TestGreaterInstr i8 = 50		// i8
TestGreaterEqInstr i8 = 51		// i8
TestLessEqInstr i8 = 52		// i8
TestLessInstr i8 = 53			// i8
TestEqInstr i8 = 54			// i8
TestNotEqInstr i8 = 55			// i8

// pops i8 from stack and jumps if set
JumpInstr i8 = 56		// i8
					// i64 offset


CallExtern i8 = 25
// There are for fast parameter loading of external functions
// Otherwise we would need to inspect the Call 
ParamExtern_8 i8 = 27
ParamExtern_16 i8 = 28
ParamExtern_32 i8 = 29
ParamExtern_64 i8 = 30
ParamExtern_Ptr i8 = 31		// For potential non 64 bit platforms

// Cast operations
// That these cast opeartions are lossy and operate on twos comp integers
// We don't support unsigned to float right now

// integers less than 64 bits must first be widened to 64 bits
CastInstr_i64_f64		i8 = 104
CastInstr_i64_f32		i8 = 109

CastInstr_f32_i64		i8 = 108
CastInstr_f64_i64		i8 = 109

// We only support widening to 64 bits atm
WidenInstr_8_64         i8 = 110
WidenInstr_16_64        i8 = 111
WidenInstr_32_64        i8 = 112


Instruction struct {
	op i8
}

Interp struct {
	registers Array(i64)
	instructions Array(i8)
	stack Array(i8)

	iPtr i64	// instruction pointer
	rPtr i64 	// return pointer
	sPtr i8^

	frame i64	//
				// -------	frame pointer -----2
				//	return address
				//	parameters
				// 	return value

	instructionsSize i64
	labels Table(str, i64)


	cvm DCCallVM^
	dlhandle voidptr

	// Debug info
	frames Table(i64, DebugFrame^)
	frameArray DynamicArray(DebugFrame^)
}

InsertAdd fn() {

}
registerCount i32 = 256

Init fn(self ref Interp)
{
	self.registers.Init(registerCount)
	self.stack.Init(1024 * 1024)
	self.instructions.Init(1024 * 1024)
	self.labels.Init()

	self.sPtr = self.stack.elements

	self.iPtr = 1 // Don't start at zero so we can assume it is a bad value
	self.instructionsSize = 1
	self.cvm = dcNewCallVM(1024)
	self.dlhandle = dlopen(cast(i8^, 0), i32(RTLD_NOW|RTLD_GLOBAL))

	self.frames.Init()
	self.frameArray.Init()
}

PrintInstructions fn(self ref Interp) {

	Println('---------------')
	Println('---------------')
}

Push fn(self ref Interp, value T?) {
	^cast(T^, self.sPtr) = value
	self.sPtr = cast(i8^, cast(T^, self.sPtr) + 1)
}

Push fn(self ref Interp, from T?^, size i64) {
	CopyPtr(from, self.sPtr, size)
	self.sPtr = cast(i8^, cast(T^, self.sPtr) + size)
}

Pop fn(self ref Interp, type T?) T
{
	self.sPtr = cast(i8^, cast(T^, self.sPtr) + (-1))
	Assert(cast(i64, self.sPtr) >= cast(i64, self.stack.elements), 'Stack underflow')

	return ^(cast(T^, self.sPtr))
}

At fn(self ref Interp, type T?, at i64) T
{
	return ^(cast(T^, self.sPtr + at))
}

Store fn(self ref Interp, value T?, address i8^) {
	^cast(T^, self.address) = value
}

StorePtr fn(self ref Interp, to i8^, from i8^, size i64) {

	CopyPtr(from, to, size)
}


Retrieve fn(self ref Interp, type T?, address i8^) T {
	return ^cast(T^, self.address)
}

Load fn(self ref Interp, address T?^) {
	self.Push(^address)
}


// INSTRUCTION BUILDING 

AddLabel fn(self ref Interp, name str) {
	self.labels[name] = self.instructionsSize
	Println('label: ' + name + ' at ' + String(self.instructionsSize))
}
GetLabel fn(self ref Interp, name str) i64 {
	r i64 = self.labels[name]
	Assert(r != 0, 'Label not found ' + name)
	return r
}

AddValue fn(self ref Interp, value i8) 
{
	^cast(i8^, (self.instructions.elements + self.instructionsSize)) = value
	self.instructionsSize = self.instructionsSize + i64(i8.size)
	if value == AddInstr_i32 {
		PrintTabs(1)
		Println('add i32')
	}
	if value == MulInstr_i32 {
		PrintTabs(1)
		Println('add i32')
	}
}

AddValue fn(self ref Interp, value T?) T^
{
	r T^= cast(T^, (self.instructions.elements + self.instructionsSize))
	^r = value
	self.instructionsSize = self.instructionsSize + i64(T.size)
	return r
}

AddLoadConstInstr fn(self ref Interp, value T?) {
	self.AddValue(LoadConst)
	self.AddValue(i64(T.size))
	self.AddValue(value)
	PrintTabs(1)
	Println('load: ' + String(i64(T.size)) + ' value')
}

AddLoadInstr fn(self ref Interp, address i64, size i64) {
	self.AddValue(LoadInstr)
	self.AddValue(cast(i64, size))
	self.AddValue(cast(i64, address))

	PrintTabs(1)
	Println('load: ' + String(size) + ' address: ' + String(address))
}
AddLoadOffsetInstr fn(self ref Interp, offset i64, size i64) {
	self.AddValue(LoadOffsetInstr)
	self.AddValue(cast(i64, size))
	self.AddValue(cast(i64, offset))

	PrintTabs(1)
	Println('load: ' + String(size) + ' offset: ' + String(offset))
}

StoreOffsetInstr fn(self ref Interp, offset i64, size i64) {
	self.AddValue(StoreOffsetInstr)
	self.AddValue(cast(i64, size))
	self.AddValue(cast(i64, offset))
	PrintTabs(1)
	Println('store: ' + String(size) + ' offset: ' + String(offset))
}


AddCall fn(self ref Interp, name str) 
{
	PrintTabs(1)
	Println('call: ' + name)
	self.AddLoadConstInstr(self.GetLabel(name))
	self.AddValue(CallInstr)
}

AddCallExtern fn(self ref Interp, name str) {
	func voidptr = dlsym(self.dlhandle, name.chars)
	self.AddValue(CallExtern)
	self.AddValue(cast(i64, func))
	PrintTabs(1)
	Println('call extern: ' + name)
}


AddExternCallLabel fn(self ref Interp, name str) {
	func voidptr = dlsym(self.dlhandle, name.chars)
	Assert(cast(i64, func) != 0 , 'Failed to find external function "' + name + '" you probably need to dynamically link it first')

	self.labels[name] = cast(i64, func)
	PrintTabs(1)
	Println('label extern:  ' + name)
}

DebugLocal struct  {
	variable Variable^
	offset i64
	instr i64
}
Init fn(self ref DebugLocal, variable Variable^, offset i64) {
	self.variable = variable
	self.offset = offset
}

DebugFrame struct {
	function Function^
	locals DynamicArray(DebugLocal^)
	startInstr i64
	endInstr i64
}
Init fn(self ref DebugFrame, function Function^) {
	self.function = function
	self.locals.Init()
}

EnsureStack fn(self ref Interp, type T?, count i32) {
	Assert(cast(i64, self.sPtr) >= (count * cast(i32, T.size)), 'Stack underflow ' + String(cast(i64, self.sPtr)))
}
GetInstr fn(self ref Interp, type T?) T^ {
	t T^ = cast(T^, self.instructions.elements + self.iPtr)
	self.iPtr = self.iPtr + cast(i64, T.size)
	return t
}

GetInstr fn(self ref Interp, size i64) i8^ {
	t i8^ = cast(i8^, self.instructions.elements + self.iPtr)
	self.iPtr = self.iPtr + size
	return t
}


PrintFrame fn(self ref Interp, address i64) {
	Println('----------------------Frame----------------------')

	frame DebugFrame^ = self.frames[address]
	Assert(frame, 'no frame')
	Print('> ')
	Println(frame.function.ident)
	for i64(0) .. frame.locals.length {
		local DebugLocal^ = frame.locals[it]
		PrintTabs(1)
		Print(local.variable.ident)
		Print(' ')
		Print(local.variable.super.typ)
		Print(' -> ')
		value i32 = ^cast(i32^, (self.frame + local.offset))
		Println(String(value))
	}
	Println('-------------------------------------------------')
}

PrintFrame fn(self ref Interp, frame DebugFrame^, current i64, instrPtr i64) {
	Println('----------------------Frame----------------------')

	Assert(frame, 'No frame')
	Print('> ')
	Println(frame.function.ident)
	for i64(0) .. frame.locals.length {
		local DebugLocal^ = frame.locals[it]
		PrintTabs(1)
		Print(local.variable.ident)
		Print(' ')
		Print(local.variable.super.typ)
		Print(' -> ')
		value i32 = ^cast(i32^, (current + local.offset))
		Print(String(value))

		if local.instr >= instrPtr {
			Print('    ----- unreached ----')
		}
		Println('')
	}
	Println('-------------------------------------------------')
}



FrameAt fn(self ref Interp, instr i64) DebugFrame^ {

	Println('Frame at: ' + String(instr))
	for i64(0) .. self.frameArray.length
	{
		if 	(instr >= self.frameArray[it].startInstr) &&
			(instr <= self.frameArray[it].endInstr)  
		{
			return self.frameArray[it]

		}
	}
	Assert(0, 'frame not found')
	return cast(DebugFrame^, 0)
}

AddressFrame fn(self ref Interp, frame i64, instr i64, returnInstr i64) {

	PrintFrame(self, self.FrameAt(instr), frame, instr)

	if cast(i64, frame) <= cast(i64, self.stack.elements) {
		Assert(frame == cast(i64, self.stack.elements), 'Santity check, Expected frame pointer of the top frame to be at the top of the stack')
		return // if the frame pointer is less than the stack we are complete
	}

	prevInstrPtr i64 = frame - 16
	prevFramePtr i64 = frame - 8


	prevFrame i64 = ^cast(i64^, (prevFramePtr))
	prevPreInstr i64 = ^cast(i64^, (prevInstrPtr))

	AddressFrame(self, prevFrame, returnInstr, prevPreInstr)
}
AddressFrame fn(self ref Interp) {

	self.AddressFrame(self.frame, self.iPtr, self.rPtr)

	//if self.frame == cast(i64, self.stack.elements) {
	//	PrintFrame(self, self.labels['Main'])
	//	return
	//}

	//at i64 = self.frame - 20
	//previous i64 = self.frame - 28

	//previousFrame i64 = ^cast(i64^, (previous))

	//Println('at:' + at.String())
	//// we subtract 1 because the address of the label is one above where the return point is set
	//address i64 = ^cast(i64^, (at)) - 1 
	//PrintFrame(self, address)
}

Run fn(self ref Interp)
{
	self.PrintInstructions()


	self.iPtr = self.GetLabel('Main')
	self.frame = cast(i64, self.sPtr)
	Println('Frame :' + String(self.sPtr))

	Println('Running at: ' + String(self.iPtr))
	Println('------------running------------------')

	breakpt i64 = self.GetLabel('Deeper_i32_i32')

	for self.iPtr < self.instructions.length  
	{
		if self.iPtr == breakpt {
			Println('\n-----------------------------------------')
			Println('Breakpoint reached')
			AddressFrame(self)
			breakpt = 10000
		}

		op i8 = ^self.GetInstr(i8)
		if op == LoadConst
		{
			size i64 = ^self.GetInstr(i64)
			data i8^ = self.GetInstr(size)
			self.Push(data, size)
			//Println('Loaded const data of size: ' + String(size))
		}
		else if op == LoadInstr
		{
			size i64 = ^self.GetInstr(i64)
			address i64 = ^self.GetInstr(i64)
			self.Push(cast(i8^, address), size)

			//Println('Loaded data of size: ' + String(size))
		}
		else if op == LoadAddressInstr
		{
			address i64 = self.Pop(i64)
			size i64 = ^self.GetInstr(i64)
			self.Push(cast(i8^, address), size)
		}
		else if op == LoadOffsetInstr 
		{
			size i64 = ^self.GetInstr(i64)
			offset i64 = ^self.GetInstr(i64)


			address i64 = offset + self.frame

			value i32 = ^cast(i32^, (address))
			//Println('value: ' + String(value))

			//Println('Loaded data offset size: ' + String(size) + ' offset: ' + String(offset))

			self.Push(cast(i8^, address), size)
		}
		else if op == LoadAddressFromOffsetInstr 
		{
			offset i64 = ^self.GetInstr(i64)
			address i64 = offset + self.frame
			self.Push(i64(address))
		}
		
		else if op == StoreOffsetInstr 
		{
			size i64 = ^self.GetInstr(i64)
			offset i64 = ^self.GetInstr(i64)
			address i64 = offset + self.frame


			value i32 = ^cast(i32^, (self.sPtr + -size))
			//Println('value: ' + String(value))

			self.StorePtr(cast(i8^, address), (self.sPtr + -size), size)
			//Println('Store size: ' + String(size) + ' offset: ' + String(offset))		
		}
        else if op == StoreInstr
        {
            size i64 = ^self.GetInstr(i64)
            offset i64 = ^self.GetInstr(i64)
            address i64 = self.Pop(i64) + offset
            self.StorePtr(cast(i8^, address), (self.sPtr + -size), size)
            //Println('Store size: ' + String(size) + ' offset: ' + String(offset))		
        }
		else if op == AddInstr_i32 
		{
			l i32 = self.Pop(i32)
			r i32 = self.Pop(i32)
			//Println('+ i32 ' + String(l) + ' ' + String(r))
			self.Push(i32(l + r))
		}
		else if op == AddInstr_i64
		{
			l i64 = self.Pop(i64)
			r i64 = self.Pop(i64)
			//Println('+ i64 ' + String(l) + ' ' + String(r))
			self.Push(i64(l + r))
		}
		else if op == MulInstr_i32
		{
			l i32 = self.Pop(i32)
			r i32 = self.Pop(i32)
			//Println('* i32 ' + String(l) + ' ' + String(r))
			self.Push(i32(l * r))
		}
		else if op == Muli64
		{
			l i64 = self.Pop(i64)
			r i64 = self.Pop(i64)
			//Println('* i64 ' + String(l) + ' ' + String(r))
			self.Push(i64(l * r))
		}
		else if op == CallInstr
		{
			address i64 = self.Pop(i64)
			//Println('Call ' + String(address))


			//Store current context
			self.Push(cast(i64, self.rPtr))
			self.Push(cast(i64, self.frame))

			self.rPtr = self.iPtr
			self.iPtr = address
			self.frame = cast(i64, self.sPtr)
		}
		else if op == ReturnInstr {
			if self.rPtr == 0 {
				self.iPtr = 10000000000000

			}
			else {
				self.iPtr = self.rPtr
				self.sPtr = cast(i8^, self.frame)
				//Println('Return ' + String(self.rPtr))

				//Restore previous context 
				self.frame = self.Pop(i64)
				self.rPtr = self.Pop(i64)
			}
		}
		else if op == CallExtern {
			address i64 = ^self.GetInstr(i64)
            
            //self.Push
    		dcCallInt(self.cvm, cast(voidptr, address))
    		dcReset(self.cvm)
    		//Println('Call extern')
		}
		else if op == ParamExtern_32 {
			value i32 = self.Pop(i32)
			dcArgInt(self.cvm, value)
		}
		else if op == ParamExtern_64 {
			dcArgLong(self.cvm, cast(i64, self.Pop(i64)))
		}
		else if op == ParamExtern_Ptr {
			dcArgLong(self.cvm, cast(i64, self.Pop(i64)))
		}
		else if op == CompareInstr_i32 {
			b i32 = self.Pop(i32)
			a i32 = self.Pop(i32)
			self.Push(i8((a > b) - (a < b)))
		}
		else if op == TestGreaterInstr {
			test i8 = self.Pop(i8)
			self.Push(i8(test > 0))
		}
		else if op == TestGreaterEqInstr {
			test i8 = self.Pop(i8)
			self.Push(i8(test >= 0))
		}
		else if op == TestLessInstr {
			test i8 = self.Pop(i8)
			self.Push(i8(test < 0))
		}
		else if op == TestLessEqInstr {
			test i8 = self.Pop(i8)
			self.Push(i8(test <= 0))
		}
		else if op == TestEqInstr {
			test i8 = self.Pop(i8)
			self.Push(i8(test == 0))
		}
		else if op == TestNotEqInstr {
			test i8 = self.Pop(i8)
			self.Push(i8(test != 0))
		}
		else if op == JumpInstr {
			instruction i64 = ^self.GetInstr(i64)
			test i8 = self.Pop(i8)
			if !test {
				self.iPtr = instruction
			}
		}
		else if op == WidenInstr_8_64 {
			v i8 = self.Pop(i8)
			self.Push(i64(v))
		}
		else if op == WidenInstr_16_64 {
            self.Push(i64(self.Pop(i64)))
		}
		else if op == WidenInstr_32_64 {
            self.Push(i64(self.Pop(i32)))
		}
		else if op == CastInstr_i64_f64 {
			self.Push(f64(self.Pop(i64)))
		}
        else if op == CastInstr_i64_f32 {
            self.Push(f32(self.Pop(i64)))
        }
		else if op == CastInstr_f64_i64 {
			self.Push(i64(self.Pop(f64)))
		}
		else if op == CastInstr_f32_i64 {
			self.Push(i64(self.Pop(f32)))
		}

		else 
		{
			Println('Unhandled instruction ' + String(op))
			Println('----------------------------------')
			return 
		}
	}
	Println('\n------------finished------------------')
}
