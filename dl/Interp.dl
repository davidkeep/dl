
@import {
	'dl/Array.dl',
	'Expr/Expr.dl',
	'Main.dl',
}

DCCallVM struct


RTLD_LAZY 	i32 = 1
RTLD_NOW	i32 = 2
RTLD_LOCAL	i32 = 4
RTLD_GLOBAL	i32 = 8

@extern {
	dcNewCallVM 	fn(size u32) DCCallVM^
	dcReset 		fn(vm DCCallVM^)
	dcArgChar   	fn(vm DCCallVM^, value i8)
	dcArgShort  	fn(vm DCCallVM^, value i16)
	dcArgInt    	fn(vm DCCallVM^, value i32)
	dcArgLong   	fn(vm DCCallVM^, value i64)
	dcArgFloat  	fn(vm DCCallVM^, value f32)
	dcArgDouble 	fn(vm DCCallVM^, value f64)
	dcArgPointer	fn(vm DCCallVM^, value voidptr)

	dcCallVoid      fn(vm DCCallVM^, func voidptr)
	dcCallChar      fn(vm DCCallVM^, func voidptr) i8
    dcCallShort     fn(vm DCCallVM^, func voidptr) i16
	dcCallInt       fn(vm DCCallVM^, func voidptr) i32
	dcCallLong      fn(vm DCCallVM^, func voidptr) i64
	dcCallFloat     fn(vm DCCallVM^, func voidptr) f32
	dcCallDouble    fn(vm DCCallVM^, func voidptr) f64
	dcCallPointer   fn(vm DCCallVM^, func voidptr) voidptr

	dlopen			fn(path i8^, mode i32) voidptr
	dlsym			fn(handle voidptr, symbol i8^) voidptr
}

@build {
	link = (		
		'-ldyncall_s', 
	)
}



AddInstr_i32 i8 	= 1		// stack left, right
AddInstr_i64 i8 	= 2		// stack left, right

MulInstr_i32 i8 	= 3		// stack left, right
Muli64 i8 	= 4		// stack left, right

Subi32 i8 	= 5
Loadi32 i8 	= 6		// size, address


CallInstr i8 	= 7	// return value, parameters, return pointer, address of procedure
ReturnInstr i8 	= 8




LoadInstr i8 		= 9
				// i8
				// i64 		size
				// i64 		address in stack


// Pushes value from offset
LoadOffsetInstr i8 		= 10
// i8 instr, i64 size, i64 offset
// >> [data(size)... ]


LoadAddressInstr i8 = 11
// Pops value to store from stack


AddOffsetToAddressInstr    i8 = 17
// i8 instr i64 offset
// << i64 address
// >> i64 address + offset
// Takes the local offset and calculates an actual address
LoadAddressFromOffsetInstr    i8 = 12
// i8 instr
// << i64 offset
// >> i64 frame + offset

StoreOffsetInstr i8 		= 13
				// i8
				// i64 		size
				// i64 		offset in frame


StoreInstr i8 		= 14
// i8 instr, i64 size, i64 offset
// << [address, data ...]

DiscardInstr i8 		= 18
// i8 instr, i64 size,
// << [data(size) ...]


//Immediate instructions
//Theses have their size followed by their data stored following the op code
LoadConst i8 	= 15	//	i8
						//	i64 --- the size in bytes
						//	data follows
						//	...
						//	...

// pushes i8  -1 if less 0 if equal 1 if greater
CompareInstr_i64 i8 = 16	// i8


// pop i8 from stack
TestGreaterInstr i8 = 50		// i8
TestGreaterEqInstr i8 = 51		// i8
TestLessEqInstr i8 = 52		// i8
TestLessInstr i8 = 53			// i8
TestEqInstr i8 = 54			// i8
TestNotEqInstr i8 = 55			// i8

// pops i8 from stack and jumps if set
JumpInstr i8 = 56		// i8
					// i64 offset


CallExtern i8 = 25
// There are for fast parameter loading of external functions
// Otherwise we would need to inspect the Call 
ParamExtern_8 i8 = 27
ParamExtern_16 i8 = 28
ParamExtern_32 i8 = 29
ParamExtern_64 i8 = 30
ParamExtern_Ptr i8 = 31		// For potential non 64 bit platforms

// Cast operations
// That these cast opeartions are lossy and operate on twos comp integers
// We don't support unsigned to float right now

// integers less than 64 bits must first be widened to 64 bits
CastInstr_i64_f64		i8 = 104
CastInstr_i64_f32		i8 = 109

CastInstr_f32_i64		i8 = 108
CastInstr_f64_i64		i8 = 107

// We only support widening to 64 bits atm
WidenInstr_8_64         i8 = 110
WidenInstr_16_64        i8 = 111
WidenInstr_32_64        i8 = 112

ConvertInstr_64_32 		i8 = 113

Instruction struct {
	op i8
}

Interp struct {
	registers Array(i64)
	instructions Array(i8)
	stack Array(i8)

	iPtr i64	// instruction pointer
	rPtr i64 	// return pointer
	sPtr i8^
	stackTop i8^

	frame i64	//
				// -------	frame pointer -----2
				//	return address
				//	parameters
				// 	return value

	instructionsSize i64
	labels Table(str, i64)


	cvm DCCallVM^
	dlhandle voidptr

	// Debug info
	frames Table(i64, DebugFrame^)
	frameArray DynamicArray(DebugFrame^)
}

InsertAdd fn() {

}
registerCount i32 = 256

Init fn(self ref Interp)
{
	self.registers.Init(registerCount)
	self.stack.Init(1024 * 1024)
	self.instructions.Init(1024 * 1024)
	self.labels.Init()

	self.sPtr = self.stack.elements + 1024 * 1020
	self.stackTop = self.sPtr

	self.iPtr = 1 // Don't start at zero so we can assume it is a bad value
	self.instructionsSize = 1
	self.cvm = dcNewCallVM(1024)
	self.dlhandle = dlopen(cast(i8^, 0), i32(RTLD_NOW|RTLD_GLOBAL))

	self.frames.Init()
	self.frameArray.Init()
	labelAddresses.Init()
	labelAddresses.Push(0)
}

PrintInstructions fn(self ref Interp) {

	Println('---------------')
	Println('---------------')
}

Push fn(self ref Interp, value T?) {
	self.sPtr = cast(i8^, cast(T^, self.sPtr)  + (- 1))
    ^cast(T^, self.sPtr)  = value
}

Push fn(self ref Interp, from T?^, size i64) {
	self.sPtr = cast(i8^, cast(T^, self.sPtr) + (-size))
    CopyPtr(from, self.sPtr, size)
}

Pop fn(self ref Interp, type T?) T
{
    pPtr i8^ = self.sPtr
	self.sPtr = cast(i8^, cast(T^, self.sPtr) + 1)
	Assert(cast(i64, self.sPtr) >= cast(i64, self.stack.elements), 'Stack underflow')

	return ^(cast(T^, pPtr))
}


//Store fn(self ref Interp, value T?, address i8^) {
//	^cast(T^, self.address) = value
//}

StorePtr fn(self ref Interp, to i8^, from i8^, size i64) {

	CopyPtr(from, to, size)
}


// INSTRUCTION BUILDING 



AddLabel fn(self ref Interp, name str) {
    if self.labels[name] == 0 {
        self.labels[name] = labelAddresses.length
        labelAddresses.Push(-1)
    }
    labelAddresses[self.labels[name]] = self.instructionsSize
	Println('label: ' + name + ' at ' + String(self.instructionsSize))
}
GetLabel fn(self ref Interp, name str) i64 {
    if self.labels[name] == 0 {
        self.labels[name] = labelAddresses.length
        labelAddresses.Push(-1)
    }

	r i64 = self.labels[name]
	Assert(r != 0, 'Label not found ' + name)
	return r
}

AddSpace fn(self ref Interp, value i8) 
{
	^cast(i8^, (self.instructions.elements + self.instructionsSize)) = value
	self.instructionsSize = self.instructionsSize + i64(i8.size)
	if value == AddInstr_i32 {
		PrintTabs(1)
		Println('add i32')
	}
	if value == MulInstr_i32 {
		PrintTabs(1)
		Println('add i32')
	}
}


AddValue fn(self ref Interp, value i8) 
{
//	Println('--' + String(self.instructionsSize) +  '--')
	//Assert(value)
	^cast(i8^, (self.instructions.elements + self.instructionsSize)) = value
	self.instructionsSize = self.instructionsSize + i64(i8.size)
	if value == AddInstr_i32 {
		PrintTabs(1)
		Println('add i32')
	}
	if value == MulInstr_i32 {
		PrintTabs(1)
		Println('add i32')
	}
}

AddValue fn(self ref Interp, value T?) T^
{
	r T^= cast(T^, (self.instructions.elements + self.instructionsSize))
	^r = value
	self.instructionsSize = self.instructionsSize + i64(T.size)
	return r
}

AddLoadConstInstr fn(self ref Interp, value T?) {
	self.AddValue(LoadConst)
	self.AddValue(i64(T.size))
	self.AddValue(value)
	PrintTabs(1)
	Println('load: ' + String(i64(T.size)) + ' value')
}



StoreOffsetInstr fn(self ref Interp, offset i64, size i64) {
	self.AddValue(StoreOffsetInstr)
	self.AddValue(cast(i64, size))
	self.AddValue(cast(i64, offset))
	PrintTabs(1)
	Println('store: ' + String(size) + ' offset: ' + String(offset))
}


AddCall fn(self ref Interp, name str) 
{
	PrintTabs(1)
	Println('call: ' + name)
	self.AddLoadConstInstr(self.GetLabel(name))
	self.AddValue(CallInstr)
	Println('call end:')
}

AddCallExtern fn(self ref Interp, name str) {
	func voidptr = dlsym(self.dlhandle, name.chars)
	self.AddValue(CallExtern)
	self.AddValue(cast(i64, func))
	PrintTabs(1)
	Println('call extern: ' + name)
}

labelAddresses DynamicArray(i64)

AddExternCallLabel fn(self ref Interp, name str) {
	func voidptr = dlsym(self.dlhandle, name.chars)
	Assert(cast(i64, func) != 0 , 'Failed to find external function "' + name + '" you probably need to dynamically link it first')

	self.labels[name] = cast(i64, func)
	PrintTabs(1)
	Println('label extern:  ' + name)
}

DebugLocal struct  {
	variable Variable^
	offset i64
	instr i64
}
Init fn(self ref DebugLocal, variable Variable^, offset i64) {
	self.variable = variable
	self.offset = offset
}

DebugFrame struct {
	function Function^
	locals DynamicArray(DebugLocal^)
	startInstr i64
	endInstr i64
}
Init fn(self ref DebugFrame, function Function^) {
	self.function = function
	self.locals.Init()
}

EnsureStack fn(self ref Interp, type T?, count i32) {
	Assert(cast(i64, self.sPtr) >= (count * cast(i32, T.size)), 'Stack underflow ' + String(cast(i64, self.sPtr)))
}
GetInstr fn(self ref Interp, type T?) T^ {
	t T^ = cast(T^, self.instructions.elements + self.iPtr)
	self.iPtr = self.iPtr + cast(i64, T.size)
	return t
}

GetInstr fn(self ref Interp, size i64) i8^ {
	t i8^ = cast(i8^, self.instructions.elements + self.iPtr)
	self.iPtr = self.iPtr + size
	return t
}


PrintFrame fn(self ref Interp, frame DebugFrame^, current i64, instrPtr i64) {
	Println('----------------------Frame----------------------')

	Assert(frame, 'No frame')

	if frame.function.super.at.file {
		Print(project.files[frame.function.super.at.file-1].path)
	}
	Print(':')
	Print(String(frame.function.super.at.line))
	Print(':')
	Print(String(frame.function.super.at.column))
	Println(':')
	Println(frame.function.ident)

	for i64(0) .. frame.locals.length {
		local DebugLocal^ = frame.locals[it]
		Print(String(local.variable.super.at.line))
		Print(':')
		PrintTabs(2)
		Print(local.variable.ident)
		Print(' ')
		Print(local.variable.super.typ)
		Print(' -> ')
		value i32 = ^cast(i32^, (current - local.offset))
		Print(String(value))

		if local.instr >= instrPtr {
			Print('    ----- unreached ----')
		}
		Println('')
	}
	Println('-------------------------------------------------')
}



FrameAt fn(self ref Interp, instr i64) DebugFrame^ {

	Println('Frame at: ' + String(instr))
	for i64(0) .. self.frameArray.length
	{
		if 	(instr >= self.frameArray[it].startInstr) &&
			(instr <= self.frameArray[it].endInstr)  
		{
			return self.frameArray[it]

		}
	}
	Assert(0, 'frame not found ' + String(instr))
	return cast(DebugFrame^, 0)
}

PrintFrame fn(self ref Interp, frame i64, instr i64, returnInstr i64) {

	PrintFrame(self, self.FrameAt(instr), frame, instr)


	// if the frame pointer is less than the stack we are complete
	// lets also check taht we didn't flow off the top of the stack (This should never happen)
	if cast(i64, frame) >= cast(i64, self.stackTop) {
		Assert(frame == cast(i64, self.stackTop), 'Santity check, Expected frame pointer of the top frame to be at the top of the stack')
		return 
	}

	prevInstrPtr i64 = frame + 8
	prevFramePtr i64 = frame + 0

	prevFrame i64 = ^cast(i64^, (prevFramePtr))
	prevPreInstr i64 = ^cast(i64^, (prevInstrPtr))

	PrintFrame(self, prevFrame, returnInstr, prevPreInstr)
}
PrintFrame fn(self ref Interp) {

	self.PrintFrame(self.frame, self.iPtr, self.rPtr)
}

Run fn(self ref Interp)
{
	self.PrintInstructions()


	self.iPtr = labelAddresses[self.GetLabel('Main')]
	self.frame = cast(i64, self.sPtr)
	Println('Frame :' + String(self.sPtr))

	Println('Running at: ' + String(self.iPtr))
	Println('------------running------------------')

	breakpt i64 = self.GetLabel('Deeper_i32_i32')

	for self.iPtr < self.instructions.length  
	{
		if self.iPtr == breakpt {
			Println('\n-----------------------------------------')
			Println('Breakpoint reached')
			PrintFrame(self)
			breakpt = 10000
		}

		op i8 = ^self.GetInstr(i8)
		if op == LoadConst
		{
			size i64 = ^self.GetInstr(i64)
			data i8^ = self.GetInstr(size)
			self.Push(data, size)
			//Println('Loaded const data of size: ' + String(size))
		}
		else if op == LoadInstr
		{
			size i64 = ^self.GetInstr(i64)
			address i64 = ^self.GetInstr(i64)
			self.Push(cast(i8^, address), size)

			//Println('Loaded data of size: ' + String(size))
		}
		else if op == LoadAddressInstr
		{
			address i64 = self.Pop(i64)
		//	Print('address: ')
		//	Println(String(address))
			size i64 = ^self.GetInstr(i64)
			self.Push(cast(i8^, address), size)
			value i32 = ^cast(i32^, (address))

			//Println('value: ' + String(value) + ' l: ' + String(size))
		}
		else if op == LoadOffsetInstr 
		{
			size i64 = ^self.GetInstr(i64)
			offset i64 = ^self.GetInstr(i64)


			address i64 =  self.frame - offset

			value i32 = ^cast(i32^, (address))
			//Println('value: ' + String(value))
			//Println('Loaded data offset size: ' + String(size) + ' offset: ' + String(offset))

			self.Push(cast(i8^, address), size)
		}
		else if op == AddOffsetToAddressInstr
		{
			offset i64 = ^self.GetInstr(i64)
			address i64 =  self.Pop(i64)
			self.Push(i64(address + offset))
		}
		
		else if op == LoadAddressFromOffsetInstr 
		{
			offset i64 = ^self.GetInstr(i64)
			address i64 =  self.frame - offset
			self.Push(i64(address))
		}
		
		else if op == StoreOffsetInstr 
		{
			size i64 = ^self.GetInstr(i64)
			offset i64 = ^self.GetInstr(i64)
			address i64 =  self.frame - offset
			Assert(address != 0)

			value i32 = ^cast(i32^, self.sPtr)
			//Println('value: ' + String(value))

			self.StorePtr(cast(i8^, address), self.sPtr, size)
			//Println('Store size: ' + String(size) + ' offset: ' + String(offset))		
		}
		else if op == DiscardInstr
        {
            size i64 = ^self.GetInstr(i64)
           	for i64(0) .. size {
           		self.Pop(i8)
           	}	
        }
        else if op == StoreInstr
        {
            size i64 = ^self.GetInstr(i64)
            offset i64 = ^self.GetInstr(i64)
            address i64 = self.Pop(i64) - offset

            Assert(address != 0, 'attempt to store at address 0')

            self.StorePtr(cast(i8^, address), self.sPtr, size)
            self.sPtr = self.sPtr + (-size)

            //for i64(0) .. size {
            //	putchar(i32(^cast(i8^, (address + it))))
            //}
           // Println('Store size: ' + String(size) + ' offset: ' + String(offset))		
        }
		else if op == AddInstr_i32 
		{
			l i32 = self.Pop(i32)
			r i32 = self.Pop(i32)
			//Println('+ i32 ' + String(l) + ' ' + String(r))
			self.Push(i32(l + r))
		}
		else if op == AddInstr_i64
		{
			l i64 = self.Pop(i64)
			r i64 = self.Pop(i64)
			//Println('+ i64 ' + String(l) + ' ' + String(r))
			self.Push(i64(l + r))
		}
		else if op == MulInstr_i32
		{
			l i32 = self.Pop(i32)
			r i32 = self.Pop(i32)
			//Println('* i32 ' + String(l) + ' ' + String(r))
			self.Push(i32(l * r))
		}
		else if op == Muli64
		{
			l i64 = self.Pop(i64)
			r i64 = self.Pop(i64)
			//Println('* i64 ' + String(l) + ' ' + String(r))
			self.Push(i64(l * r))
		}
		else if op == CallInstr
		{
			l i64= self.Pop(i64)
			address i64 = labelAddresses[l]


			//Store current context
			Assert(self.rPtr < self.instructionsSize, 'sr instr address outside possible range at:' + String(self.iPtr))

			self.Push(cast(i64, self.rPtr))
			self.Push(cast(i64, self.frame))

			self.rPtr = self.iPtr
			self.iPtr = address
			Assert(address < self.instructionsSize, 'instr address outside possible range')
			self.frame = cast(i64, self.sPtr)
		}
		else if op == ReturnInstr {
			if self.rPtr == 0 {
				self.iPtr = 10000000000000

			}
			else {
				self.iPtr = self.rPtr
				Assert(self.iPtr < self.instructionsSize, 'instr address outside possible range at:' + String(self.iPtr))

				self.sPtr = cast(i8^, self.frame)
				//Println('Return ' + String(self.rPtr))

				//Restore previous context 
				self.frame = self.Pop(i64)
				self.rPtr = self.Pop(i64)
				Assert(self.rPtr < self.instructionsSize, 'r instr address outside possible range at:' + String(self.iPtr))

			}
		}
		else if op == CallExtern {
			address i64 = ^self.GetInstr(i64)
            self.Push(dcCallInt(self.cvm, cast(voidptr, address)))
    		dcReset(self.cvm)
    		//Println('Call extern')
		}
		else if op == ParamExtern_32 {
			value i32 = self.Pop(i32)
			dcArgInt(self.cvm, value)
		}
		else if op == ParamExtern_64 {
			dcArgLong(self.cvm, cast(i64, self.Pop(i64)))
		}
		else if op == ParamExtern_Ptr {
			dcArgLong(self.cvm, cast(i64, self.Pop(i64)))
		}
		else if op == CompareInstr_i64 {
			b i64 = self.Pop(i64)
			a i64 = self.Pop(i64)
			//Println('')
			//Println(String(a) + ' < ' + String(b))
			self.Push(i8((a > b) - (a < b)))
		}
		else if op == TestGreaterInstr {
			test i8 = self.Pop(i8)
			self.Push(i8(test > 0))
		}
		else if op == TestGreaterEqInstr {
			test i8 = self.Pop(i8)
			self.Push(i8(test >= 0))
		}
		else if op == TestLessInstr {
			test i8 = self.Pop(i8)
			self.Push(i8(test < 0))
		}
		else if op == TestLessEqInstr {
			test i8 = self.Pop(i8)
			self.Push(i8(test <= 0))
		}
		else if op == TestEqInstr {
			test i8 = self.Pop(i8)
			self.Push(i8(test == 0))
		}
		else if op == TestNotEqInstr {
			test i8 = self.Pop(i8)
			self.Push(i8(test != 0))
		}
		else if op == JumpInstr {
			instruction i64 = ^self.GetInstr(i64)
			test i8 = self.Pop(i8)
			if !test {
				self.iPtr = instruction
			}
		}
		else if op == ConvertInstr_64_32 {
			//Println('CASDFASDasdfasfasfdasdf')
			value i32 = i32(self.Pop(i64))
			//Println(String(value))
			self.Push(value)
		}
		else if op == WidenInstr_8_64 {
			v i8 = self.Pop(i8)
			self.Push(i64(v))
		}
		else if op == WidenInstr_16_64 {
            self.Push(i64(self.Pop(i64)))
		}
		else if op == WidenInstr_32_64 {
            self.Push(i64(self.Pop(i32)))
		}

		else if op == CastInstr_i64_f64 {
			self.Push(f64(self.Pop(i64)))
		}
        else if op == CastInstr_i64_f32 {
            self.Push(f32(self.Pop(i64)))
        }
		else if op == CastInstr_f64_i64 {
			self.Push(i64(self.Pop(f64)))
		}
		else if op == CastInstr_f32_i64 {
			self.Push(i64(self.Pop(f32)))
		}

		else 
		{
			Println('Unhandled instruction ' + String(op) + ' at: ' + String(self.iPtr))
			Println('----------------------------------')
			return 
		}
	}
	Println('\n------------finished------------------')
}
