@import {
    'Array.dl'
    'String.dl'
}

@extern {
    putchar fn character i32
    malloc  fn c u64 => ref i8
    calloc  fn nmem u64, size u64        => ref i8
    realloc fn nmem ref i8, size u64    => ref i8
    memcpy  fn dst ref i8, src ref i8, count u64 => ref i8
    memset  fn dst ref i8, value i32, count u64  => ref i8

    glfwCreateWindow fn width i32, height i32, title ref i8, monitor i64, share i64 => i64
    glfwWindowShouldClose fn window i64 => i32
    glfwInit fn => i32
    glfwPollEvents fn
    glfwSwapBuffers fn window i64
    dlopen fn file ref i8, flags i32 => i64
}

== fn l i32, r i32 =>  i8   {   return i64(l) == i64(r)     }
!= fn l i32, r i32 =>  i8   {   return i64(l) != i64(r)     }
!= fn l i8,  r i8  =>  i8   {   return i64(l) != i64(r)     }
== fn l i8,  r i8  =>  i8   {   return i64(l) == i64(r)     }
+  fn l i32, r i32 => i32   {   return i32(i64(l) + i64(r)) }
<  fn l i32, r i32 =>  i8   {   return i64(l) < i64(r)      }

u64 fn l i64 => u64 
{
    return u64(i32(l))
}

i8 fn l i64 =>  i8 
{
    return dref(cast(ref i8, &l))
}

Option struct $Type
{
    value Type
    exists i8
}

Set fn self ref Option(Str), value Str  
{
    self.dref.value = value
    self.dref.exists = (0 == 0)
}


Print fn chars ref i8
{
    a ref i8
    a = chars

    value i32
    value = a.dref.i32

    for value != 0.i32 
    {
        putchar(value)
        a = PtrAdd(a, 1)
        value = a.dref.i32
    }
}


Main fn => i32
{
    if glfwInit() == 1.i32 {
        Print('glfwinit')
    }

    as i64
    as = 25

    array Array(Str)
    array.Init(3)
    
    array[0] = String('ONE')
    array[1] = String('TWO')
    array[2] = String('THREE')

    for 0 .. 3 {
        Print(array[it])
    }

    //array.Position = (1, 1)


    //window i64 = glfwCreateWindow(i32(1000), i32(500), 'Hello there', 0, 0)
    //Last(array)

    //for glfwWindowShouldClose(window) == i32(0) {
    //    glfwPollEvents()
    //    glfwSwapBuffers(window)
    //}
}

