
@import {
	'Expr.dl',
    '../Semantic.dl',
}

Structure struct {
    super Expr
    ident str
    incomplete i8
    
    block Block

    fields DynamicArray(Variable^)
    constraints DynamicArray(Type^)

    specializations DynamicArray(StructureSpec^)

    typeIdent Type^

    state i32
}

Init fn(self ref Structure) {
    self.super.kind = Id(Structure)
    self.block.Init()
    typetype TypeType^ = New(TypeType)
    ident TypeIdentifier^ = New(TypeIdentifier)
    ident.spec = &self.super
    typetype.reference = &ident.super
    self.super.typ = &typetype.super
    self.typeIdent = &ident.super
}

Structure fn() Structure^ {
    self Structure^ = new(Structure)
    self.Init()
    return self
}

Add fn(structure ref Structure, field Variable^) {
    structure.fields.Push(field)
}
Lookup fn(structure ref Structure, ident str) Variable^ {
    for i64(0) .. structure.fields.length {
        if Equal(structure.fields[it].ident, ident) {
            return structure.fields[it]
        }
    }
    return cast(Variable^, 0)
}
StructureSpec struct {
    super Expr
    structure Structure^
    incomplete i8
    constraints DynamicArray(Type^)
}

Init fn(self ref StructureSpec) {
    self.constraints.Init()
    self.super.kind = Id(StructureSpec)
}

Specialize fn(self ref Structure, constraints ref DynamicArray(Type^)) StructureSpec^ {
    verbose i8

    for i64(0) .. self.specializations.length {
        if Equal(self.specializations[it].constraints, constraints) {
            spec StructureSpec^ = self.specializations[it]
            if verbose {
                Println('Specializing: ' + self.ident)
                PrintTabs(1)
                Print('found')
                PrintTabs(1)
                Print(self.ident)
                Print('(')
                Print(constraints)
                Println(')\n')
            }
            return spec
        }
    }
    if verbose {
        Println('Specializing : ' + self.ident)
        PrintTabs(1)
        Print(self.ident)
        Print('(')
        Print(constraints)
        Println(')\n')
    }
    spec StructureSpec^ = New(StructureSpec)
    spec.structure = &self
    spec.constraints = constraints
    self.specializations.Push(spec)

    for i64(0) .. spec.constraints.length {
        if spec.constraints[it].Resolved().Is(TypeAny) {
            spec.incomplete = true
        }
    }
    return spec
}

Apply fn(self ref Structure, spec ref StructureSpec) {
    for i64(0) .. self.constraints.length {
        self.constraints[it].As(TypeAny).reference = spec.constraints[it]
    }
}

Apply fn(spec ref StructureSpec) {
    spec.structure.Apply(spec)
}
