

Str struct {
    length i64
    chars ref i8
}

cstrlen fn chars ref i8 => i32 {

    size i32
    for i32(dref(PtrAdd(chars, i64(size)))) != i32(0) {
      //  a = PtrAdd(a, i64(1))
        size = size + i32(1)
    }
    return (size)
}

String fn chars ref i8 => Str {
    string Str
    string.chars = chars
    string.length = i64(cstrlen(chars))
    return string
}

Print fn value Str {
    for 0 .. value.length {
       putchar(i32(dref(PtrAdd(value.chars, it))))
    }
}

//Println fn(string Str){
//    Print(string + String('\n'))
//}

+ fn a Str, b Str => Str
{
    v Str
    v.chars = Alloc(i8, a.length + b.length + 1)
    CopyPtr(a.chars, v.chars, a.length)
    CopyPtr(b.chars, PtrAdd(v.chars, a.length), b.length)
    v.length = a.length + b.length
    dref(PtrAdd(v.chars, v.length)) = i8(0)
    return v
}

String fn number i64 => Str
{
    if number == 0 {
        return String('0')
    }
    
    negative i64 = 0
    if number < 0 {
        negative = 1
        number = 0-number
    }

    n i64 
    n = number
    count i64 = 0
    for n != 0  {
        n = n / 10
        count = count + 1
    }

    characters Array(i8)
    Init(characters, count + 1)

    a i64 
    a = number
    for 0 .. count {
        characters[count - it - 1] = i8(a % 10 + 48)
        a = a / 10
    }

    characters[count] = i8(0)
    r Str
    r.length = count
    r.chars = characters.elements

    if negative != 0 {
        return String('-') + r
    }
    return r
}

assert fn condition ref $T {
    assert(cast(i64, condition) != 0)
}


assert fn condition ref $T, reason Str 
{
    assert(cast(i64, condition) != 0, reason)
}

assert fn condition i8, reason Str 
{
    if condition == i8(0)
    {
        Print(String('Aborting: ') + reason)
        abort()
    }
}

assert fn condition i8
{
    if condition == i8(0) 
    {
        abort()
    }
}
