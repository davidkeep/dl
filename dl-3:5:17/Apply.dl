@import {
    'Semantic.dl',
}


// Coerces a type from one type to another
// Returns a value of 0 on failure 
// Returns a value above zero according to how strong a match is found
// a value of 1 an equal match

i128 struct {
    hi i64
    lo i64
}

Convert fn(desired ref Expr, from ref Expr, reportError i8) i32 
{
    if Equal(desired.typ, from.typ, true) {
        return 1
    }
    value i32 = Coerce(desired, from, reportError)
    if value != 0 
    {
        return value + 1
    }  
    return 0
}

Coerce fn (desired ref Expr, from ref Expr, reportError i8) i32
{
    return Coerce(^desired.typ.Resolved(), from, reportError)
}

Coerce fn (desiredType ref Type, from ref Expr, reportError i8) i32
{
    fromType Type^ = from.typ.Resolved()

    if from.Is(NumberConstant) 
    {
        if desiredType.Is(TypeNumber) {
            from.As(NumberConstant).super.typ = &desiredType
        }
        else {
            return 0
        }
        //Println('@TODO Check if this is a viable conversion')
        return 1
    }

    if desiredType.Is(TypeNumber)
    {
        if fromType.Is(TypeNumber) 
        {
            f TypeNumber^ = fromType.As(TypeNumber)
            d TypeNumber^ = desiredType.As(TypeNumber)

            if d.kind == f.kind {
                if d.size < f.size {
                    //Println('conversion would result in loss of precision')
                    return 0
                }
            }
            else if (d.kind == TypeNumberInteger && f.kind == TypeNumberUnsigned) ||
                    (f.kind == TypeNumberInteger && d.kind == TypeNumberUnsigned) {
                if d.size < f.size {
                    //Println('conversion would result in loss of precision')
                    return 0
                }
            }
            else  {
                //@TODO remove this check conversion from unsigned should probably be explicit?
                //if d.size < f.size {
                //    Println('conversion would result in loss of precision')
                //    Assert(0)
                //    return 0
                //}
                //Println('Differnt nukber tyes ')
               // Error(from, 'conversion of signed to unsigned ' + String(desiredType) + ' from ' + String(fromType))
               //Assert(0)
               return 0
            }

            return 1
        }
    }
    if reportError {
        Error(from, 'type of ' + String(desiredType) + ' cannot be assigned a type of ' + String(fromType))
        Assert(0)
    }
    return 0
}

