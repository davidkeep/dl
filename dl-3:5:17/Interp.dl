
@import {
	'dl/Array.dl',
	'Expr/Expr.dl',
	'Main.dl',
}

DCCallVM struct


RTLD_LAZY 	i32 = 1
RTLD_NOW	i32 = 2
RTLD_LOCAL	i32 = 4
RTLD_GLOBAL	i32 = 8

@extern {
	dcNewCallVM 	fn(size u32) DCCallVM^
	dcReset 		fn(vm DCCallVM^)
	dcArgChar   	fn(vm DCCallVM^, value i8)
	dcArgShort  	fn(vm DCCallVM^, value i16)
	dcArgInt    	fn(vm DCCallVM^, value i32)
	dcArgLong   	fn(vm DCCallVM^, value i64)
	dcArgFloat  	fn(vm DCCallVM^, value f32)
	dcArgDouble 	fn(vm DCCallVM^, value f64)
	dcArgPointer	fn(vm DCCallVM^, value voidptr)

	dcCallVoid      fn(vm DCCallVM^, func voidptr)
	dcCallChar      fn(vm DCCallVM^, func voidptr) i8
    dcCallShort     fn(vm DCCallVM^, func voidptr) i16
	dcCallInt       fn(vm DCCallVM^, func voidptr) i32
	dcCallLong      fn(vm DCCallVM^, func voidptr) i64
	dcCallFloat     fn(vm DCCallVM^, func voidptr) f32
	dcCallDouble    fn(vm DCCallVM^, func voidptr) f64
	dcCallPointer   fn(vm DCCallVM^, func voidptr) voidptr

	dlopen			fn(path i8^, mode i32) voidptr
	dlsym			fn(handle voidptr, symbol i8^) voidptr
}

@build {
	link = (		
		'-ldyncall_s', 
	)
}



AddPtrInstr i8 	= 		3		// stack left, right

AddInstr_i32 i8 	= 	1		// stack left, right
AddInstr_i64 i8 	= 	2		// stack left, right
MulInstr_i32 i8 	= 	4		// stack left, right
MulInstr_i64 i8 	= 	5		// stack left, right
SubInstr_i64 i8 	= 	6
DivInstr_i64 i8 	= 	7

AddInstr_f32 i8 	= 	120		// stack left, right
MulInstr_f32 i8 	= 	121		// stack left, right
SubInstr_f32 i8 	= 	122
DivInstr_f32 i8 	= 	123


ModInstr_i64 			i8 = 9
AndInstr_i64 			i8 = 10
OrInstr_i64 			i8 = 11
BitAndInstr_i64 		i8 = 12
BitOrInstr_i64 			i8 = 13

Loadi32 				i8 	= 14		// size, address


CallInstr	 			i8 	= 15	// return value, parameters, return pointer, address of procedure
ReturnInstr 			i8 	= 16




LoadInstr 				i8 	= 17
				// i8
				// i64 		size
				// i64 		address in stack


// Pushes value from offset
LoadOffsetInstr i8 		= 18
// i8 instr, i64 size, i64 offset
// >> [data(size)... ]


LoadAddressInstr i8 = 19
// Pops value to store from stack


AddOffsetToAddressInstr    i8 = 20
// i8 instr i64 offset
// << i64 address
// >> i64 address + offset
// Takes the local offset and calculates an actual address
LoadAddressFromOffsetInstr    i8 = 21
// i8 instr
// << i64 offset
// >> i64 frame + offset

StoreOffsetInstr i8 		= 22
				// i8
				// i64 		size
				// i64 		offset in frame


StoreInstr i8 		= 23
// i8 instr, i64 size, i64 offset
// << [address, data ...]

DiscardInstr i8 		= 24
// i8 instr, i64 size,
// << [data(size) ...]


//Immediate instructions
//Theses have their size followed by their data stored following the op code
LoadConst i8 	= 25	//	i8
						//	i64 --- the size in bytes
						//	data follows
						//	...
						//	...

// pushes i8  -1 if less 0 if equal 1 if greater
CompareInstr_i64 i8 = 26	// i8


// pop i8 from stack
TestGreaterInstr i8 = 27		// i8
TestGreaterEqInstr i8 = 28		// i8
TestLessEqInstr i8 = 29		// i8
TestLessInstr i8 = 30			// i8
TestEqInstr i8 = 31			// i8
TestNotEqInstr i8 = 32			// i8

// pops i8 from stack and jumps if set
JumpInstr i8 = 33		// i8
					// i64 offset


CallExternVoid i8 = 34
CallExternPtr i8 = 35
CallExtern32 i8 = 36
CallExtern64 i8 = 37
CallExtern16 i8 = 52
CallExtern8 i8 = 53

// There are for fast parameter loading of external functions
// Otherwise we would need to inspect the Call 
ParamExtern_8 i8 = 38
ParamExtern_16 i8 = 39
ParamExtern_32 i8 = 40
ParamExtern_64 i8 = 41
ParamExtern_Ptr i8 = 42		// For potential non 64 bit platforms

ParamExtern_f32 i8 = 100
ParamExtern_f64 i8 = 101
CallExtern_16 i8 = 102
CallExtern_8 i8 = 103
CallExtern_f32 i8 = 104
CallExtern_f64 i8 = 105

// Cast operations
// That these cast opeartions are lossy and operate on twos comp integers
// We don't support unsigned to float right now

// integers less than 64 bits must first be widened to 64 bits
CastInstr_i64_f64		i8 = 43
CastInstr_i64_f32		i8 = 44

CastInstr_f32_i64		i8 = 45
CastInstr_f64_i64		i8 = 46

CastInstr_f32_f64		i8 = 150
CastInstr_f64_f32		i8 = 151

// We only support widening to 64 bits atm
WidenInstr_8_64         i8 = 47
WidenInstr_16_64        i8 = 48
WidenInstr_32_64        i8 = 59

ConvertInstr_64_32 		i8 = 50

ConvertInstr			i8 = 51


TrapInstr 		i8 = 0
TrapAbort 		i8 = 0


Instruction struct {
	op i8
}

Interp struct {
	registers Array(i64)
	instructions Array(i8)
	stack Array(i8)

	iPtr i64	// instruction pointer
	rPtr i64 	// return pointer
	sPtr i8^
	stackTop i8^

	frame i64	//
				// -------	frame pointer -----2
				//	return address
				//	parameters
				// 	return value

	instructionsSize i64
	labels Table(str, i64)


	cvm DCCallVM^
	dlhandle voidptr

	// Debug info
	frames Table(i64, DebugFrame^)
	frameArray DynamicArray(DebugFrame^)
}

InsertAdd fn() {

}
registerCount i32 = 256

Init fn(self ref Interp)
{
	self.registers.Init(registerCount)
	self.stack.Init(1024 * 1024)
	self.instructions.Init(1024 * 1024)
	self.labels.Init()

	self.sPtr = self.stack.elements + 1000 * 1000
	self.stackTop = self.sPtr

	self.iPtr = 1 // Don't start at zero so we can assume it is a bad value
	self.instructionsSize = 1
	self.cvm = dcNewCallVM(1024)

	dlopen('/Users/David/Desktop/Projects/glfw/src/libglfw.3.3.dylib'.chars, 1)
	dlopen('/Users/David/Desktop/dl/dl/build/libdyndl.dylib'.chars, 1)
	self.dlhandle = dlopen(cast(i8^, 0), i32(RTLD_NOW|RTLD_GLOBAL))

	self.frames.Init()
	self.frameArray.Init()
	labelAddresses.Init()
	labelAddresses.Push(0)
}

PrintInstructions fn(self ref Interp) {

	Println('---------------')
	Println('---------------')
}

Push fn(self ref Interp, value T?) {
	self.sPtr = cast(i8^, cast(T^, self.sPtr)  + (- 1))
    ^cast(T^, self.sPtr)  = value
}

Push fn(self ref Interp, from T?^, size i64) {
	self.sPtr = cast(i8^, cast(T^, self.sPtr) + (-size))
    CopyPtr(from, self.sPtr, size)
}

Pop fn(self ref Interp, type T?) T
{
    pPtr i8^ = self.sPtr
	self.sPtr = cast(i8^, cast(T^, self.sPtr) + 1)
	Assert(cast(i64, self.sPtr) >= cast(i64, self.stack.elements), 'Stack underflow')

	return ^(cast(T^, pPtr))
}


//Store fn(self ref Interp, value T?, address i8^) {
//	^cast(T^, self.address) = value
//}

StorePtr fn(self ref Interp, to i8^, from i8^, size i64) {

	CopyPtr(from, to, size)
}


// INSTRUCTION BUILDING 



AddLabel fn(self ref Interp, name str) {
    if self.labels[name] == 0 {
        self.labels[name] = labelAddresses.length
        labelAddresses.Push(-1)
    }
    labelAddresses[self.labels[name]] = self.instructionsSize
	Println('label: ' + name + ' at ' + String(self.instructionsSize))
}
GetLabel fn(self ref Interp, name str) i64 {
    if self.labels[name] == 0 {
        self.labels[name] = labelAddresses.length
        labelAddresses.Push(-1)
    }

	r i64 = self.labels[name]
	Assert(r != 0, 'Label not found ' + name)
	return r
}

AddSpace fn(self ref Interp, value i8) 
{
	^cast(i8^, (self.instructions.elements + self.instructionsSize)) = value
	self.instructionsSize = self.instructionsSize + i64(i8.size)
}


AddValue fn(self ref Interp, value i8) 
{
//	Println('--' + String(self.instructionsSize) +  '--')
	//Assert(value)
	^cast(i8^, (self.instructions.elements + self.instructionsSize)) = value
	self.instructionsSize = self.instructionsSize + i64(i8.size)
}


AddValue fn(self ref Interp, value f64) f64^
{
    r f64^= cast(f64^, (self.instructions.elements + self.instructionsSize))
    ^r = value
    self.instructionsSize = self.instructionsSize + i64(f64.size)
    return r
}
AddValue fn(self ref Interp, value T?) T^
{
	r T^= cast(T^, (self.instructions.elements + self.instructionsSize))
	^r = value
	self.instructionsSize = self.instructionsSize + i64(T.size)
	return r
}

AddValue fn(self ref Interp, value f64) f64^
{ 
    r f64^= cast(f64^, (self.instructions.elements + self.instructionsSize))
    ^r = value
    self.instructionsSize = self.instructionsSize + i64(f64.size)
    return r
}

AddLoadConstInstr fn(self ref Interp, value T?) {
	self.AddValue(LoadConst)
	self.AddValue(i64(T.size))
	self.AddValue(value)
	PrintTabs(1)
	Println('load: ' + String(i64(T.size)) + ' value')
}



StoreOffsetInstr fn(self ref Interp, offset i64, size i64) {
	self.AddValue(StoreOffsetInstr)
	self.AddValue(cast(i64, size))
	self.AddValue(cast(i64, offset))
	PrintTabs(1)
	Println('store: ' + String(size) + ' offset: ' + String(offset))
}


AddCall fn(self ref Interp, name str) 
{
	PrintTabs(1)
	Println('call: ' + name)
	self.AddLoadConstInstr(self.GetLabel(name))
	self.AddValue(CallInstr)
	Println('call end:')
}

AddCallExternVoid fn(self ref Interp, name str) {
	func voidptr = dlsym(self.dlhandle, name.chars)
	self.AddValue(CallExternVoid)
	self.AddValue(cast(i64, func))
	PrintTabs(1)
	Println('call extern: ' + name)
}

AddCallExtern8 fn(self ref Interp, name str) {
	func voidptr = dlsym(self.dlhandle, name.chars)
	self.AddValue(CallExtern8)
	self.AddValue(cast(i64, func))
	PrintTabs(1)
	Println('call extern: ' + name)
}
AddCallExtern16 fn(self ref Interp, name str) {
	func voidptr = dlsym(self.dlhandle, name.chars)
	self.AddValue(CallExtern16)
	self.AddValue(cast(i64, func))
	PrintTabs(1)
	Println('call extern: ' + name)
}
AddCallExtern32 fn(self ref Interp, name str) {
	func voidptr = dlsym(self.dlhandle, name.chars)
	self.AddValue(CallExtern32)
	self.AddValue(cast(i64, func))
	PrintTabs(1)
	Println('call extern: ' + name)
}

AddCallExternf32 fn(self ref Interp, name str) {
	func voidptr = dlsym(self.dlhandle, name.chars)
	self.AddValue(CallExtern_f32)
	self.AddValue(cast(i64, func))
	PrintTabs(1)
	Println('call extern: ' + name)
}

AddCallExtern64 fn(self ref Interp, name str) {
	func voidptr = dlsym(self.dlhandle, name.chars)
	self.AddValue(CallExtern64)
	self.AddValue(cast(i64, func))
	PrintTabs(1)
	Println('call extern: ' + name)
}
AddCallExternPtr fn(self ref Interp, name str) {
	func voidptr = dlsym(self.dlhandle, name.chars)
	self.AddValue(CallExternPtr)
	self.AddValue(cast(i64, func))
	PrintTabs(1)
	Println('call extern: ' + name)
}

labelAddresses DynamicArray(i64)

AddExternCallLabel fn(self ref Interp, name str) {
	func voidptr = dlsym(self.dlhandle, name.chars)
	Assert(cast(i64, func) != 0 , 'Failed to find external function "' + name + '" you probably need to dynamically link it first')

	self.labels[name] = cast(i64, func)
	PrintTabs(1)
	Println('label extern:  ' + name)
}

DebugLocal struct  {
	variable Variable^
	offset i64
	instr i64
}
Init fn(self ref DebugLocal, variable Variable^, offset i64) {
	self.variable = variable
	self.offset = offset
}

DebugFrame struct {
	function Function^
	locals DynamicArray(DebugLocal^)
	startInstr i64
	endInstr i64
}
Init fn(self ref DebugFrame, function Function^) {
	self.function = function
	self.locals.Init()
}

EnsureStack fn(self ref Interp, type T?, count i32) {
	Assert(cast(i64, self.sPtr) >= (count * cast(i32, T.size)), 'Stack underflow ' + String(cast(i64, self.sPtr)))
}
GetInstr fn(self ref Interp, type T?) T^ {
	t T^ = cast(T^, self.instructions.elements + self.iPtr)
	self.iPtr = self.iPtr + cast(i64, T.size)
	return t
}

GetInstr fn(self ref Interp, size i64) i8^ {
	t i8^ = cast(i8^, self.instructions.elements + self.iPtr)
	self.iPtr = self.iPtr + size
	return t
}


PrintType fn(t Type^ , location i8^) i8^ {

	typ Type^ = t.Resolved()

	if typ.Is(TypeRef) {
		value i64 = ^cast(i64^, (location))
		Print('x' + String(value))
		Print(': ')
		if value {
			PrintType(typ.As(TypeRef).reference, cast(i8^, value))
		}
		return location + 8
	}
    if typ.Is(TypeNumber) {
        self TypeNumber^ = typ.As(TypeNumber)
        value i64
        if self.size == 1 {
            value = ^cast(i8^, (location))
        }
        if self.size == 2 {
            value = ^cast(i16^, (location))
        }
        if self.size == 4 {
            value = ^cast(i32^, (location))
        }
        if self.size == 8 {
            value = ^cast(i64^, (location))
        }
        Print(String(value))
        return location + self.size
    }
	else if typ.Is(TypeIdentifier) {
		spec Expr^ = typ.As(TypeIdentifier).spec
		structure Structure^ = spec.As(Structure)
		if structure.ident == 'voidptr' {
			value i64 = ^cast(i64^, (location))
			Print('x' + String(value))
			return location + 8
		}
		if structure.ident == 'Str' {
			chars str = ^cast(str^, (location))
			Print('"')
			Print(chars)
			Print('"')
			return location + 16
		}
		at i8^ = location
		for i64(0) .. structure.fields.length {
			Print(structure.fields[it].ident)
			Print(': ')
			at = PrintType(structure.fields[it].super.typ, at)
			Print(' ')
		}
		return at
	}
	if typ.Is(TypeGeneric) {
		self TypeGeneric^ = typ.As(TypeGeneric)
		spec StructureSpec^ spec = self.spec.As(StructureSpec)
		spec.structure.Apply(^spec)
		return PrintType(spec.structure.typeIdent, location)
	}
	return location		
}

PrintFrame fn(self ref Interp, frame DebugFrame^, current i64, instrPtr i64) {
	Println('----------------------Frame----------------------')

	Assert(frame, 'No frame')

	if frame.function.super.at.file {
		Print(project.files[frame.function.super.at.file-1].path)
	}
	Print(':')
	Print(String(frame.function.super.at.line))
	Print(':')
	Print(String(frame.function.super.at.column))
	Println(':')
	Println(frame.function.ident)

	for i64(0) .. frame.locals.length {
		local DebugLocal^ = frame.locals[it]
		Print(String(local.variable.super.at.line))
		Print(':')
		len i64 = 4 - String(local.variable.super.at.line).length
		for i64(0) .. len {
			Print(' ')
		}

		value str = local.variable.ident + ' ' + String(local.variable.super.typ)
		for value.length < 25 {
			value = value + ' '
		}

		Print(value)
		Print('= ')
		PrintType(local.variable.super.typ, cast(i8^, (current - local.offset)))

		if local.instr >= instrPtr {
			Print('    <<<<<-unreached ->>>>>')
		}
		Println('')
	}
	Println('-------------------------------------------------')
}



FrameAt fn(self ref Interp, instr i64) DebugFrame^ {

	Println('Frame at: ' + String(instr))
	for i64(0) .. self.frameArray.length
	{
		if 	(instr >= self.frameArray[it].startInstr) &&
			(instr <= self.frameArray[it].endInstr)  
		{
			return self.frameArray[it]

		}
	}
	Assert(0, 'frame not found ' + String(instr))
	return cast(DebugFrame^, 0)
}

PrintFrame fn(self ref Interp, frame i64, instr i64, returnInstr i64) {

    if !instr {
        return
    }
    
	PrintFrame(self, self.FrameAt(instr), frame, instr)


	// if the frame pointer is less than the stack we are complete
	// lets also check taht we didn't flow off the top of the stack (This should never happen)
	if cast(i64, frame) >= cast(i64, self.stackTop) {
		Assert(frame == cast(i64, self.stackTop), 'Santity check, Expected frame pointer of the top frame to be at the top of the stack')
		return 
	}

	prevInstrPtr i64 = frame + 8
	prevFramePtr i64 = frame + 0

	prevFrame i64 = ^cast(i64^, (prevFramePtr))
	prevPreInstr i64 = ^cast(i64^, (prevInstrPtr))

	PrintFrame(self, prevFrame, returnInstr, prevPreInstr)
}
PrintFrame fn(self ref Interp) {

	self.PrintFrame(self.frame, self.iPtr, self.rPtr)
}


Run fn(self ref Interp, label str) {
	//self.PrintInstructions()
	self.iPtr = labelAddresses[self.GetLabel('main')]
	self.frame = cast(i64, self.sPtr)

    Assert(self.iPtr >= 0)
	//breakpt i64 = self.GetLabel('Deeper_i32_i32')
	Println('Running at: ' + String(self.iPtr))
	Println('------------running------------------')
	Run(self)
	Println('\n------------finished------------------')
}

Run fn(self ref Interp)
{
	for self.iPtr < self.instructions.length  
	{
		//if self.iPtr == breakpt {
		//	Println('\n-----------------------------------------')
		//	Println('Breakpoint reached')
		//	PrintFrame(self)
		//	breakpt = 10000
		//}

		op i8 = ^self.GetInstr(i8)
		if op == LoadConst
		{
			size i64 = ^self.GetInstr(i64)
			data i8^ = self.GetInstr(size)
			self.Push(data, size)
			//Println('Loaded const data of size: ' + String(size))
		}
		else if op == LoadInstr
		{
			size i64 = ^self.GetInstr(i64)
			address i64 = ^self.GetInstr(i64)
			self.Push(cast(i8^, address), size)

			//Println('Loaded data of size: ' + String(size))
		}
		else if op == LoadAddressInstr
		{
			address i64 = self.Pop(i64)
		//	Print('address: ')
		//	Println(String(address))
			size i64 = ^self.GetInstr(i64)
			self.Push(cast(i8^, address), size)
			//Println('value: ' + String(value) + ' l: ' + String(size))
		}
		else if op == LoadOffsetInstr 
		{
			size i64 = ^self.GetInstr(i64)
			offset i64 = ^self.GetInstr(i64)


			address i64 =  self.frame - offset
			//Println('value: ' + String(value))
			//Println('Loaded data offset size: ' + String(size) + ' offset: ' + String(offset))

			self.Push(cast(i8^, address), size)
		}
		else if op == AddOffsetToAddressInstr
		{
			offset i64 = ^self.GetInstr(i64)
			address i64 =  self.Pop(i64)
			self.Push(i64(address + offset))
		}
		else if op == LoadAddressFromOffsetInstr 
		{
			offset i64 = ^self.GetInstr(i64)
			address i64 =  self.frame - offset
			self.Push(i64(address))
		}
		
		else if op == StoreOffsetInstr 
		{
			size i64 = ^self.GetInstr(i64)
			offset i64 = ^self.GetInstr(i64)
			address i64 =  self.frame - offset
			Assert(address != 0)

			value i32 = ^cast(i32^, self.sPtr)
			//Println('value: ' + String(value))

			self.StorePtr(cast(i8^, address), self.sPtr, size)
			self.sPtr = self.sPtr + (size)
			//Println('Store size: ' + String(size) + ' offset: ' + String(offset))		
		}
		else if op == DiscardInstr
        {
            size i64 = ^self.GetInstr(i64)
            //Println('discard: ' + String(size))
           	for i64(0) .. size {
           		self.Pop(i8)
           	}	
        }
        else if op == StoreInstr
        {
            size i64 = ^self.GetInstr(i64)
            offset i64 = ^self.GetInstr(i64)
            address i64 = self.Pop(i64) - offset

            Assert(address != 0, 'attempt to store at address 0')

            self.StorePtr(cast(i8^, address), self.sPtr, size)
            self.sPtr = self.sPtr + (size)

            //for i64(0) .. size {
            //	putchar(i32(^cast(i8^, (address + it))))
            //}
           // Println('Store size: ' + String(size) + ' offset: ' + String(offset))		
		}
		else if op == AddPtrInstr
		{
			size i64 = ^self.GetInstr(i64)
			right i64 = self.Pop(i64) * size
			left i64 = self.Pop(i64)  
			//Println('+ i64 ' + String(l) + ' ' + String(r))
			self.Push(i64(left + right))
		}
		else if op == AddInstr_i64
		{
			r i64 = self.Pop(i64)
			l i64 = self.Pop(i64)
			//Println('+ i64 ' + String(l) + ' ' + String(r))
			self.Push(i64(l + r))
		}
		else if op == MulInstr_i64
		{
			l i64 = self.Pop(i64)
			r i64 = self.Pop(i64)
			//Println('* i64 ' + String(l) + ' ' + String(r))
			self.Push(i64(l * r))
		}
		else if op == SubInstr_i64
		{
			r i64 = self.Pop(i64)
			l i64 = self.Pop(i64)
			//Println('* i64 ' + String(l) + ' ' + String(r))
			self.Push(i64(l - r))
		}
		else if op == DivInstr_i64
		{
			r i64 = self.Pop(i64)
			l i64 = self.Pop(i64)
			//Println('* i64 ' + String(l) + ' ' + String(r))
			self.Push(i64(l / r))
		}
		else if op == ModInstr_i64
		{
			r i64 = self.Pop(i64)
			l i64 = self.Pop(i64)
			self.Push(i64(l % r))
		}
		else if op == AndInstr_i64
		{
			r i8 = self.Pop(i8)
			l i8 = self.Pop(i8)
			self.Push(i8(l && r))
		}
		else if op == OrInstr_i64
		{
			r i8 = self.Pop(i8)
			l i8 = self.Pop(i8)
			self.Push(i8(l || r))
		}
		else if op == AddInstr_f32
		{
			r f32 = self.Pop(f32)
			l f32 = self.Pop(f32)
			//Println('+ f32 ' + String(l) + ' ' + String(r))
			self.Push(f32(l + r))
		}
		else if op == MulInstr_f32
		{
			l f32 = self.Pop(f32)
			r f32 = self.Pop(f32)
			//Println('* f32 ' + String(l) + ' ' + String(r))
			self.Push(f32(l * r))
		}
		else if op == SubInstr_f32
		{
			r f32 = self.Pop(f32)
			l f32 = self.Pop(f32)
			//Println('* f32 ' + String(l) + ' ' + String(r))
			self.Push(f32(l - r))
		}
		else if op == DivInstr_f32
		{
			r f32 = self.Pop(f32)
			l f32 = self.Pop(f32)
			//Println('* f32 ' + String(l) + ' ' + String(r))
			self.Push(f32(l / r))
		}
		else if op == CallInstr
		{
			l i64= self.Pop(i64)
			address i64 = labelAddresses[l]

			//Store current context
			Assert(self.rPtr < self.instructionsSize, 'sr instr address outside possible range at:' + String(self.iPtr))

			//Println('Call start at    = ' + String(cast(i64, self.stackTop) - cast(i64, self.sPtr)))

			self.Push(cast(i64, self.rPtr))
			self.Push(cast(i64, self.frame))

			self.rPtr = self.iPtr
			self.iPtr = address
			Assert(address < self.instructionsSize, 'instr address outside possible range')
			self.frame = cast(i64, self.sPtr)
		}
		else if op == ReturnInstr {
			if self.rPtr == 0 {
				self.iPtr = 10000000000000

			}
			else {
				self.iPtr = self.rPtr
				Assert(self.iPtr < self.instructionsSize, 'instr address outside possible range at:' + String(self.iPtr))

				self.sPtr = cast(i8^, self.frame)
				//Println('Return ' + String(self.rPtr))

				//Restore previous context 
				self.frame = self.Pop(i64)
				self.rPtr = self.Pop(i64)
				Assert(self.rPtr < self.instructionsSize, 'r instr address outside possible range at:' + String(self.iPtr))
				//Println('Call end at      = ' + String(cast(i64, self.stackTop) - cast(i64, self.sPtr)))

			}
		}
		else if op == CallExternPtr {
			address i64 = ^self.GetInstr(i64)
			ret i64 = cast(i64, dcCallPointer(self.cvm, cast(voidptr, address)))
            self.Push(ret)
    		dcReset(self.cvm)
    		//Println('Call extern')
		}
		else if op == CallExternVoid {
			address i64 = ^self.GetInstr(i64)
			dcCallVoid(self.cvm, cast(voidptr, address))
    		dcReset(self.cvm)
		}
		else if op == CallExtern_8 {
			address i64 = ^self.GetInstr(i64)
			self.Push(i8(dcCallChar(self.cvm, cast(voidptr, address))))
    		dcReset(self.cvm)
		}
		else if op == CallExtern_16 {
			address i64 = ^self.GetInstr(i64)
			self.Push(i16(dcCallShort(self.cvm, cast(voidptr, address))))
    		dcReset(self.cvm)
		}
		else if op == CallExtern32 {
			address i64 = ^self.GetInstr(i64)
			self.Push(i32(dcCallInt(self.cvm, cast(voidptr, address))))
    		dcReset(self.cvm)
		}
		else if op == CallExtern64 {
			address i64 = ^self.GetInstr(i64)
			self.Push(i64(dcCallLong(self.cvm, cast(voidptr, address))))
    		dcReset(self.cvm)
		}
		else if op == CallExtern_f32 {
			address i64 = ^self.GetInstr(i64)
			self.Push(f32(dcCallFloat(self.cvm, cast(voidptr, address))))
    		dcReset(self.cvm)
		}
		else if op == CallExtern_f64 {
			address i64 = ^self.GetInstr(i64)
			self.Push(f64(dcCallDouble(self.cvm, cast(voidptr, address))))
    		dcReset(self.cvm)
		}
		else if op == ParamExtern_8 {
			value i8 = self.Pop(i8)
			dcArgChar(self.cvm, value)
		}
		else if op == ParamExtern_16 {
            value i16 = self.Pop(i16)
			dcArgShort(self.cvm, value)
		}
		else if op == ParamExtern_32 {
			value i32 = self.Pop(i32)
			dcArgInt(self.cvm, value)
		}
		else if op == ParamExtern_64 {
            value i64 = self.Pop(i64)
			dcArgLong(self.cvm, value)
		}
		else if op == ParamExtern_Ptr {
            ptr i64 =  self.Pop(i64)
			dcArgLong(self.cvm, ptr)
		}
		else if op == ParamExtern_f32 {
            value f32 =  self.Pop(f32)
			dcArgFloat(self.cvm, value)
		}
		else if op == ParamExtern_f64 {
            value f64 =  self.Pop(f64)
			dcArgDouble(self.cvm, value)
		}
		else if op == CompareInstr_i64 {
			b i64 = self.Pop(i64)
			a i64 = self.Pop(i64)
			//Println('')
			//Println(String(a) + ' < ' + String(b))
			self.Push(i8((a > b) - (a < b)))
		}
		else if op == TestGreaterInstr {
			test i8 = self.Pop(i8)
			self.Push(i8(test > 0))
		}
		else if op == TestGreaterEqInstr {
			test i8 = self.Pop(i8)
			self.Push(i8(test >= 0))
		}
		else if op == TestLessInstr {
			test i8 = self.Pop(i8)
			self.Push(i8(test < 0))
		}
		else if op == TestLessEqInstr {
			test i8 = self.Pop(i8)
			self.Push(i8(test <= 0))
		}
		else if op == TestEqInstr {
			test i8 = self.Pop(i8)
			self.Push(i8(test == 0))
		}
		else if op == TestNotEqInstr {
			test i8 = self.Pop(i8)
			self.Push(i8(test != 0))
		}
		else if op == JumpInstr {
			instruction i64 = ^self.GetInstr(i64)
			test i8 = self.Pop(i8)
			if !test {
				self.iPtr = instruction
			}
		}
		else if op == ConvertInstr_64_32 {
			//Println('CASDFASDasdfasfasfdasdf')
			value i32 = i32(self.Pop(i64))
			//Println(String(value))
			self.Push(value)
		}
		else if op == WidenInstr_8_64 {
			v i8 = self.Pop(i8)
			self.Push(i64(v))
		}
		else if op == WidenInstr_16_64 {
            self.Push(i64(self.Pop(i64)))
		}
		else if op == WidenInstr_32_64 {
            self.Push(i64(self.Pop(i32)))
		}

		else if op == CastInstr_i64_f64 {
			self.Push(f64(self.Pop(i64)))
		}
        else if op == CastInstr_i64_f32 {
            self.Push(f32(self.Pop(i64)))
        }
		else if op == CastInstr_f64_i64 {
			self.Push(i64(self.Pop(f64)))
		}
		else if op == CastInstr_f32_i64 {
			self.Push(i64(self.Pop(f32)))
		}
		else if op == CastInstr_f32_f64 {
			self.Push(f64(self.Pop(f32)))
		}
		else if op == CastInstr_f64_f32 {
            value f64 = self.Pop(f64)
			self.Push(f32(value))
		}
		else if op == ConvertInstr {
			from i8 = ^self.GetInstr(i8)
			to i8 = ^self.GetInstr(i8)

			value i64
			if from == 8 {
				value = self.Pop(i64)
			}
			else if from == 4 {
				value = self.Pop(i32)
			}
			else if from == 2 {
				value = self.Pop(i16)
			}
			else if from == 1 {
				value = self.Pop(i8)
			}
			else {
				Assert(0, 'No conversion')
			}

			if to == 8 {
				self.Push(i64(value))
			}
			else if to == 4 {
				self.Push(i32(value))
			}
			else if to == 2 {
				self.Push(i16(value))
			}
			else if to == 1 {
				self.Push(i8(value))
			}
			else {
				Assert(0, 'No conversion')
			}
		}
		else if op == TrapInstr {
			code i8 = ^self.GetInstr(i8)
			if code == 0 
			{
				Println('\nAborting')
				self.PrintFrame()
				return
			}
			Println('Uhandled trap code ' + String(code))
			return
		}
		else 
		{
			Println('Unhandled instruction ' + String(op) + ' at: ' + String(self.iPtr))
			Println('----------------------------------')
			return 
		}
	}
}
