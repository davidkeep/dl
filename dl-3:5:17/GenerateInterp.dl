

@import {
	'Semantic.dl',
	'GenerateBasic.dl',
	'Interp.dl',
}

Size fn(t Type^) i64 {
	typ Type^ = t.Resolved()
	if typ.Is(TypeRef) {
		return 8
	}
	else if typ.Is(TypeIdentifier) {
		spec Expr^ = typ.As(TypeIdentifier).spec
		structure Structure^ = spec.As(Structure)

		if structure.ident == 'voidptr' {	return 8	}

		size i64
		for i64(0) .. structure.fields.length {
			size = size + Size(structure.fields[it].super.typ)
		}
		return size
	}
    else if typ.Is(TypeStructure) {
        self TypeStructure^ = typ.As(TypeStructure)
    
        size i64
        for i64(0) .. self.fields.length {
            size = size + Size(self.fields[it])
        }
        return size
    }
	if typ.Is(TypeGeneric) {
		self TypeGeneric^ = typ.As(TypeGeneric)
        size i64 = Size(&self.referenced.super)
		return size
	}
    
	if typ.Is(TypeType) {
		return 0
	}
	if typ.Is(TypeNumber) {
		return typ.As(TypeNumber).size
	}


	Println('unhandled type for Size : ' + String(typ.kind))
	return 0
}
Size fn(expressions ref ExpressionList) i64
{
	size i64
	for i64(0) .. expressions.list.length {
		size = size + Size(expressions.list[it].typ)
	}
	return size
}
Size fn(t Expr^) i64 {
	if t.Is(TypeAs) {
		return 0
	}
	return Size(t.typ)
}

OffsetOfMemeber fn (self ref Structure, field str) i64 
{
	offset i64
	for i64(0) .. self.fields.length {
		fieldVar Variable^ = self.fields[it]
		// The offset is calculated at the top thus the first field has an offset of 0
		if fieldVar.ident == field {
			//Println('offset ' + fieldVar.ident + ' ' + String(offset))
			return offset
		}
		offset = offset + Size(fieldVar.super.typ)
	}
	Assert(0, 'No field named ' + field + ' on structure ' + self.ident)
	return 0
}

AddVariable fn(self ref GenerateInterp, variable Variable^) {

	size i64 = Size(variable.super.typ)
	self.FrameOffset(size)

	local DebugLocal^ = new(DebugLocal)
	local.Init(variable, self.frameOffset)
	local.instr = self.interp.instructionsSize
	self.currentFrame.locals.Push(local)

	if variable.assign {
		self.PushContext(ContextLoad)
		self.Visit(^variable.assign)
		self.PopContext()
        rightSize i64 = Size(variable.assign.typ)
        
        if variable.super.typ.Resolved().Is(TypeNumber) && variable.assign.typ.Resolved().Is(TypeNumber)
        {
            to TypeNumber^ = variable.super.typ.Resolved().As(TypeNumber)
            from TypeNumber^ = variable.assign.typ.Resolved().As(TypeNumber)
            
            if from.size != to.size {
                self.interp.AddValue(ConvertInstr)
                self.interp.AddValue(i8(from.size))
                self.interp.AddValue(i8(to.size))
                rightSize = to.size
            }
        }
        Assert(size == rightSize)

	}
	else {
		self.interp.AddValue(LoadConst)
		self.interp.AddValue(i64(size))
		// Zero out this mem
		for i64(0) .. size {
			self.interp.AddSpace(i8(0))
		}
	}
	self.Print('variable: ' + variable.ident + ' size:' + String(size) + '		frame:' + String(self.frameOffset) + '\n')
	address InterpAddress
	address.global = variable.global
	address.address = self.frameOffset
	self.offsets[&variable.super] = address
}

LoadConst fn(self ref GenerateInterp, value T?) {
	self.interp.AddLoadConstInstr(value)
}


FrameOffset fn(self ref GenerateInterp, offset i64) {
	self.frameOffset = self.frameOffset + offset
}

ReserveResult fn(self ref GenerateInterp, typ Type^) {

	size i64 = Size(typ)
	self.interp.AddValue(LoadConst)
	self.interp.AddValue(i64(size))

	// Zero out this mem
	for i64(0) .. size {
		self.interp.AddValue(i8(0))
	}
	self.Print('result:  size:' + String(size) + '		frame:' + String(self.frameOffset) + '\n')
	//self.FrameOffset(size)
}

LoadAddressInstr fn(self ref GenerateInterp, size i64) {
	self.interp.AddValue(LoadAddressInstr)
	self.interp.AddValue(cast(i64, size))
	self.Print('load address size: ' + String(size) + '\n')
}

Discard fn(self ref GenerateInterp, size i64) {
	self.interp.AddValue(DiscardInstr)
	self.interp.AddValue(cast(i64, size))
	self.Print('discard size: ' + String(size) + '\n')
}

LoadAddressFromOffset fn(self ref GenerateInterp, offset i64) {
	self.interp.AddValue(LoadAddressFromOffsetInstr)
	self.interp.AddValue(offset)
	self.Print('load address from offset: ' + String(offset) + '\n')
}

LoadOffsetInstr fn(self ref GenerateInterp, offset i64, size i64) {

	self.interp.AddValue(LoadOffsetInstr)
	self.interp.AddValue(cast(i64, size))
	self.interp.AddValue(cast(i64, offset))
	//self.frameOffset = self.frameOffset + size
	self.Print('load: ' + String(size) + ' offset: ' + String(offset) + '     frame:' + String(self.frameOffset) + '\n')
}
LoadInstr fn(self ref GenerateInterp, address i64, size i64) {

	self.interp.AddValue(LoadInstr)
	self.interp.AddValue(cast(i64, size))
	self.interp.AddValue(cast(i64, address))
	self.Print('load global: ' + String(size) + ' offset: ' + String(address) + '     frame:' + String(self.frameOffset) + '\n')
}

Store fn(self ref GenerateInterp, size i64, offset i64) {
	self.interp.AddValue(StoreInstr)
	self.interp.AddValue(cast(i64, size))
	self.interp.AddValue(cast(i64, offset))
	self.Print('store: ' + String(size) + ' offset: ' + String(offset) + '\n')
}

AddOffsetToAddress fn(self ref GenerateInterp, offset i64) {
	self.interp.AddValue(AddOffsetToAddressInstr)
	self.interp.AddValue(cast(i64, offset))
	self.Print('add offset: ' + String(offset) + '\n')
}

Print fn(self GenerateInterp, string str) {
	for i64(0) .. self.indent {
		Print('   ')
	}
	Print(string)
}
InterpAddress struct {
	address i64
	global i8
}

GenerateInterp struct {
	semantic Semantic^
	interp Interp^
	frameOffset i64
	retOffset i64
	retDiscardSize i64

	offsets Table(Expr^, InterpAddress)
	currentFrame DebugFrame^
    addressContext i32
    context DynamicArray(i32)
    indent i64
}


ContextStore		i32 = 1
ContextLoad			i32 = 2
ContextDiscard		i32 = 3


Context fn(self ref GenerateInterp) i32 
{
	return self.context.Last()
}
PushContext fn(self ref GenerateInterp, context i32) 
{
	self.context.Push(context)
}
PopContext fn(self ref GenerateInterp) 
{
	self.context.Pop()
}

Init fn(generate ref GenerateInterp, semantic ref Semantic, ast ref Block, interp ref Interp) {
	
	generate.interp = &interp
	generate.semantic = &semantic
	generate.offsets.Init()
	generate.context.Init()
	generate.PushContext(ContextLoad)

	generate.currentFrame = new(DebugFrame)


	for i64(0) .. ast.expressions.length {
		expr Expr^ = ast.expressions[it]
		if expr.Is(Variable) {
			generate.Visit(^expr)
		}
	}
	generate.interp.AddValue(ReturnInstr)

	for i64(0) .. ast.expressions.length {
		expr Expr^ = ast.expressions[it]
		if !expr.Is(Variable) {
			generate.Visit(^expr)
		}
	}

	for i64(0) .. gSpecializations.length {
		spec FunctionSpec^ = gSpecializations[it]
		if !spec.incomplete 
		{
			spec.Apply()
			generate.semantic.Visit(spec.function.super)
			generate.Visit(spec.function.super)
            spec.Clear()

		}
	}

	Println('Starting data segment : ' + String(cast(i64, generate.interp.sPtr)))
	interp.Run()
	Println('Ending data segment : ' + String(cast(i64, generate.interp.sPtr)))
}
StructureFromType fn(typ ref Type) Structure^ {
    resolved Type^ = typ.Resolved()
    if resolved.Is(TypeIdentifier) {
    	return resolved.As(TypeIdentifier).spec.As(Structure)
    }
    else if resolved.Is(TypeGeneric) {
        
        self TypeGeneric^ = resolved.As(TypeGeneric)
        spec StructureSpec^ = self.spec.As(StructureSpec)
        spec.structure.Apply(^spec)
        return spec.structure
    }
   
   Assert(0, 'Cannot resolve type to a structure')
   return cast(Structure^, 0)
}
Visit fn(generate ref GenerateInterp, expr ref Expr) 
{
    
	if expr.Is(Block) {
		self Block^ = expr.As(Block)
		generate.PushContext(ContextDiscard)
		discardSize i64 = 0

		for i64(0) .. self.expressions.length {
			expr Expr^ = self.expressions[it]
			generate.Visit(^expr)
			if expr.Is(Variable){
				discardSize = discardSize + Size(expr)
			}
		}
		generate.Discard(discardSize)
		generate.frameOffset = generate.frameOffset - discardSize
		generate.PopContext()
		return
	}
	if expr.Is(Structure) {
		self Structure^ = expr.As(Structure)
		return
	}
	if expr.Is(Function) {
		self Function^ = expr.As(Function)
		if generate.semantic.intrinsic.IsIntrinsic(self) 
		{
			return
		}

		if self.any.length == 0 || cast(i64, self.spec) != 0 
		{
            ident str = self.Name()

			generate.currentFrame = new(DebugFrame)
			generate.currentFrame.Init(self)

			if self.block 
			{

				resultSize i64
				if self.result {
					resultSize = Size(self.result)
				}


				generate.frameOffset = -(Size(self.params) + 16)
				generate.retOffset = generate.frameOffset
			//	generate.frameOffset = generate.frameOffset + resultSize
				for i64(0) .. self.params.list.length 
				{
					Print('Param -- ')
					generate.Visit(^self.params.list[it])
				}

				Assert(generate.frameOffset == -16, 'Expected -16 frame offset, space for return and frame ptr')
				generate.frameOffset = 0
				generate.interp.AddLabel(ident)
		
				generate.currentFrame.startInstr = generate.interp.instructionsSize
				generate.interp.frames[generate.interp.instructionsSize] = generate.currentFrame
				generate.interp.frameArray.Push(generate.currentFrame)

				generate.Visit(self.block.super)
				generate.interp.AddValue(ReturnInstr)
				generate.currentFrame.endInstr = generate.interp.instructionsSize - 1
				Println('')
				Println('')
			}
			else {

				generate.retOffset = 0
				generate.frameOffset = 0 // doesn't really matter here
				generate.interp.AddExternCallLabel(ident)
			}
		}
		return
	}
	if expr.Is(Call) 
	{
		self Call^ = expr.As(Call)
		if self.func.Is(Function) 
		{
			function Function^ = self.func.As(Function)
			if generate.semantic.intrinsic.IsIntrinsic(function) 
			{
				generate.GenerateBasicIntrinsic(function, self)
			}
			else 
			{
				ident str = function.Name()
				if function.block {
					generate.PushContext(ContextLoad)
					if function.result {
						generate.ReserveResult(function.result)
					}
					for i64(0) .. self.params.list.length 
					{
						generate.PerformVisitAutoReference(^self.params.list[it], i64(self.drefCount[it]))
						generate.PerformCoercion(^function.params.list[it], ^self.params.list[it])
					}
					generate.interp.AddCall(ident)
					generate.Discard(Size(function.params))
					generate.PopContext()
				}
				else 
				{
					generate.PushContext(ContextLoad)
					for i64(0) .. self.params.list.length 
					{
						i i64 = self.params.list.length - it - 1
						generate.PerformVisitAutoReference(^self.params.list[i], i64(self.drefCount[i]))
						generate.PerformCoercion(^function.params.list[i], ^self.params.list[i])
					}
					generate.PopContext()

					for i64(0) .. function.params.list.length 
					{
						t Type^ = function.params.list[it].typ.Resolved()
						// These go in reverse order since we will be popping these values from the stack but the instructions go in forward order!
                        if t.Is(TypeRef) {
                            generate.interp.AddValue(ParamExtern_Ptr)
                        }                      
                        else if t == &i8Type.super || t == &u8Type.super {
							generate.interp.AddValue(ParamExtern_8)
						}
						else if t == &i16Type.super || t == &u16Type.super {
							generate.interp.AddValue(ParamExtern_16)
						}
						else if t == &i32Type.super || t == &u32Type.super {
							generate.interp.AddValue(ParamExtern_32)
						}
						else if t == &i64Type.super || t == &u64Type.super {
							generate.interp.AddValue(ParamExtern_64)
						}
						else if t == &f32Type.super {
							generate.interp.AddValue(ParamExtern_f32)
						}
						else if t == &f64Type.super {
							generate.interp.AddValue(ParamExtern_f64)
						}
					
						else {
							Assert(0, 'Parameter is of invalid type in @extern call, we only support basic types and pointers')
						}
					}

					if function.result 
					{
						t Type^ = function.result.Resolved()

						if t.Is(TypeRef) {
							generate.interp.AddCallExternPtr(ident)
						}
						else if t == &i8Type.super || t == &u8Type.super
						{
							generate.interp.AddCallExtern8(ident)
						}
						else if t == &i16Type.super || t == &u16Type.super
						{
							generate.interp.AddCallExtern16(ident)
						}
						else if t == &i32Type.super || t == &u32Type.super
						{
							generate.interp.AddCallExtern32(ident)
						}
						else if t == &i64Type.super || t == &u64Type.super
						{
							generate.interp.AddCallExtern64(ident)
						}
                        else if t == &f32Type.super
                        {
                            generate.interp.AddCallExternf32(ident)
                        }
						else {
							Assert(0, 'Return is of invalid type in @extern call, we only support basic types and pointers')
						}
					}
					else
					{
						generate.interp.AddCallExternVoid(ident)
					}
				}
			}
			if function.result {
				if generate.Context() == ContextDiscard {
					generate.Discard(Size(function.result))
				}
			}
		}
		else if self.func.Is(FunctionSpec) 
		{
			spec FunctionSpec^ = self.func.As(FunctionSpec)
			function Function^ = spec.function
            prev FunctionSpec^ = function.spec
            spec.Apply()
			if generate.semantic.intrinsic.IsIntrinsic(function) 
			{
				generate.GenerateBasicIntrinsic(function, self)
			}
			else 
			{
                generate.PushContext(ContextLoad)
				ident str = function.Name()

				if function.block {
					if function.result {
						generate.ReserveResult(function.result)
					}
					for i64(0) .. self.params.list.length 
					{
						generate.PerformVisitAutoReference(^self.params.list[it], i64(self.drefCount[it]))
						generate.PerformCoercion(^function.params.list[it], ^self.params.list[it])
					}
					
					generate.interp.AddCall(ident)
					generate.Discard(Size(function.params))
				}
				generate.PopContext()
			}
			if function.result {
				if generate.Context() == ContextDiscard {
					generate.Discard(Size(function.result))
				}
			}
            if prev {
                prev.Apply()
            }
            else {
                spec.Clear()
            }
		}
		else {
			Assert(0, 'Expected fn or fn spec ' + String(self.operand.kind))
		}
		return
	}
	if expr.Is(Variable) {
		self Variable^ = expr.As(Variable)
		generate.AddVariable(self)
		return
	}
	if expr.Is(Identifier) {
		self Identifier^ = expr.As(Identifier)
		if !self.reference {
			Println('not loading ident: ' + self.ident + ' no referenced object')
			Assert(generate.Context() == ContextLoad, 'Internal: Expected value context why would you take the address of something that doesnt refer to an address')
			return
		}
        if generate.Context() == ContextStore 
        {
            a i64 = generate.offsets[self.reference].address
            if self.reference.As(Variable).global {
            	//Assert(0, '@unimplemented')
            	generate.LoadConst(i64(cast(i64, generate.interp.stackTop) - a))
            }
            else {
            	generate.LoadAddressFromOffset(a)
            }
        }
        else if generate.Context() == ContextLoad 
        {
            a i64 = generate.offsets[self.reference].address
            if generate.offsets[self.reference].global {
            	generate.LoadInstr(cast(i64, generate.interp.stackTop) - a, Size(self.reference))
            }
            else {
            	generate.LoadOffsetInstr(a, Size(self.reference))
            }
        }
        else 
        {
        	Println('unused variable ' + self.ident)
        }
		return
	}
	if expr.Is(ForList) {
		self ForList^ = expr.As(ForList)

		//Println('Jump: offset: ' + String(generate.frameOffset))
		//generate.interp.AddValue(JumpInstr)
		//generate.interp.AddValue(generate.frameOffset)

		//for i64(0) .. self.list.list.length {
		//	generate.semantic.SetIt(^self, self.list.list[it])
		//	generate.impl.Write('/*ForList ' + String(it) + '*/')
		//	self.it.assign = self.list.list[it]
		//	self.it.super.typ = self.list.list[it].typ
		//	Assert(self.it.super.typ)
		//	//generate.Visit(self.it.super)
		//	generate.Visit(self.block.super)
		//}
		//generate.impl.Write(' ')
		//generate.impl.Write(self.ident)
		return
	}
	if expr.Is(For) {
		self For^ = expr.As(For)
		generate.PushContext(ContextLoad)

		if self.to {
			generate.Visit(self.it.super)
			generate.Visit(^self.it.assign) //Push right on the stack
			generate.interp.StoreOffsetInstr(generate.offsets[&self.it.super].address, Size(self.it.assign.typ))	// Pop and store
		}

		start i64 = generate.interp.instructionsSize
		Println('start:')

		if self.to {
			generate.Visit(self.test.super)
		}
		else {
			Assert(Size(self.from) == 1)
			generate.Visit(^self.from)
		}

		//generate.FrameOffset(-1)

		PrintTabs(1)
		Println('Jump: end ')
		generate.interp.AddValue(JumpInstr)
		at i64^ = generate.interp.AddValue(i64(0))
        generate.PopContext()

		generate.Visit(self.block.super)
	
		generate.PushContext(ContextLoad)
		if self.to {
			generate.Visit(^self.inc)
		}
		generate.interp.AddLoadConstInstr(i8(0))
		generate.interp.AddValue(JumpInstr)
		generate.interp.AddValue(i64(start))
		PrintTabs(1)
		Println('Jump: start')
		Println('end:')
		^at = generate.interp.instructionsSize
        generate.PopContext()
		return
	}
	
	if expr.Is(If) {
		self If^ = expr.As(If)
		generate.PushContext(ContextLoad)
		generate.Visit(^self.condition)
		generate.PopContext()

		PrintTabs(1)
		Println('Jump: end ')
		generate.interp.AddValue(JumpInstr)
		at i64^ = generate.interp.AddValue(i64(0))
		generate.Visit(self.trueBranch.super)
		^at = generate.interp.instructionsSize
		Println('end:')
		return
	}

	if expr.Is(Access) {
		self Access^ = expr.As(Access)

		if self.call {
			generate.Visit(self.call.super)
			return
		}

        Println('context address')
		generate.PushContext(ContextStore)
		generate.Visit(^self.operand)
		generate.PopContext()

		structure Structure^ = self.operand.typ.StructureFromType()
		if generate.Context() == ContextStore {
			generate.AddOffsetToAddress(structure.OffsetOfMemeber(self.field))
		}
		else 
		{
			Println('context value')
			generate.AddOffsetToAddress(structure.OffsetOfMemeber(self.field))
			generate.LoadAddressInstr(Size(self.super.typ))
		}
		//generate.Visit(^self.field)
		return
	}
    
	if expr.Is(Assign) {
		self Assign^ = expr.As(Assign)
		if self.drefCount > 0{

			generate.PushContext(ContextStore)
			generate.Visit(^self.right)
			generate.PopContext()

			generate.PushContext(ContextStore)
			generate.Visit(^self.left) // Calculate the address to store
			generate.PopContext()

			leftSize i64 = Size(self.left.typ)
			generate.Store(leftSize, 0)	// Pop adddress and store
			return
		}
		else if self.drefCount < 0 {

			//Load this reference into an address to store to
			generate.PushContext(ContextLoad)
			generate.Visit(^self.right)
			generate.PopContext()

			generate.PushContext(ContextStore)
			generate.Visit(^self.left) // Calculate the address to store
			generate.PopContext()
			// We use the right side size because we are dereferencing the left
			// the other option is get the referenced type on the left
			rightSize i64 = Size(self.right.typ)
			generate.Store(rightSize, 0)	// Pop adddress and store
			return
		}


		leftSize i64 = Size(self.left.typ)
		rightSize i64 = Size(self.right.typ)

		generate.PushContext(ContextLoad)
		generate.Visit(^self.right) // Push the value on the stack

		rightSize = generate.PerformCoercion(^self.left, ^self.right)
		generate.PopContext()

		generate.PushContext(ContextStore)
		generate.Visit(^self.left) // Calculate the address to store
		generate.PopContext()

		Assert(leftSize == rightSize, 'Internal compiler interp error: Expected same size arguments for assign')

		generate.Store(rightSize, 0)	// Pop adddress and store

		return
	}
	if expr.Is(Return) {
		generate.PushContext(ContextLoad)
		self Return^ = expr.As(Return)
		generate.Visit(^self.expr)
		generate.interp.StoreOffsetInstr(generate.retOffset, Size(self.expr.typ))
		generate.PopContext()
		generate.interp.AddValue(ReturnInstr)
		return
	}
	if expr.Is(Trait) {
		self Trait^ = expr.As(Trait)
		return
	}
	if expr.Is(NumberConstant) {
		self NumberConstant^ = expr.As(NumberConstant)
		//if self.super.typ == i64Type {
		//	generate.LoadConst(f64FromString(self.value))
		//}
		//else
		if generate.Context() == ContextLoad 
		{
			if self.super.typ == &i64Type.super {
				generate.LoadConst(i64FromString(self.value))
			}
			else if self.super.typ == &i32Type.super {
				generate.LoadConst(i32(i64FromString(self.value)))
			}
			else if self.super.typ == &i16Type.super {
				generate.LoadConst(i16(i64FromString(self.value)))
			}
			else if self.super.typ == &i8Type.super {
				generate.LoadConst(i8(i64FromString(self.value)))
			}
			else if self.super.typ == &u64Type.super {
				generate.LoadConst(u64(i64FromString(self.value)))
			}
			else if self.super.typ == &u32Type.super {
				generate.LoadConst(u32(i64FromString(self.value)))
			}
			else if self.super.typ == &u16Type.super {
				generate.LoadConst(u16(i64FromString(self.value)))
			}
			else if self.super.typ == &u8Type.super {
				generate.LoadConst(u8(i64FromString(self.value)))
			}
			else if self.super.typ == &f32Type.super {
				generate.LoadConst(f32(f64FromString(self.value)))
			}
			else {
				Assert(0, 'No match for NumberConstant type')
			}
		}
		else {
			Assert(0)
		}
   
		return
	}
	if expr.Is(StringConstant) {
		self StringConstant^ = expr.As(StringConstant)

		if generate.Context() == ContextStore 
        {
			generate.LoadConst(cast(i64, &self.value))
        }
        else if generate.Context() == ContextLoad 
        {
			generate.LoadConst(self.value)
        }
        else 
        {
        	Println('unused string')
        }

		return
	}
}

PerformVisitAutoReference fn(self ref GenerateInterp, expr ref Expr, count i64) { 
	if count < 0 {
		self.PerformReference(expr, -count)
		return
	}
	else if count > 0 {
		self.PerformDereference(expr, count)
		return
	}
	Assert(count == 0, 'Internal: expected count == 0')
	self.Visit(expr)
}
PerformReference fn(self ref GenerateInterp, expr ref Expr, count i64) {
	Assert(count == 1, 'Internal: expected dref count greater than 0')
	Assert(self.Context() == ContextLoad)

	Println('ref')
	self.PushContext(ContextStore)
	self.Visit(expr)
	self.PopContext()
}

PerformDereference fn(self ref GenerateInterp, expr ref Expr, count i64) {
	
	Assert(count > 0, 'Internal: expected dref count greater than 0')
	// load initial reference
	Println('dref')
	self.PushContext(ContextLoad)
	self.Visit(expr)
	self.PopContext()


	currentType Type^ = expr.typ

	for i64(0) .. count {
		Assert(currentType.Is(TypeRef), 'Expected reference to derference')

		currentType = currentType.As(TypeRef).reference
		self.LoadAddressInstr(Size(currentType))

	}

	// This isn't for dref store operations only for loads
	Assert(self.Context() == ContextLoad)
}

PerformCoercion fn(generate ref GenerateInterp, toExpr ref Expr, fromExpr ref Expr) i32
{
	if toExpr.typ.Resolved().Is(TypeNumber) && fromExpr.typ.Resolved().Is(TypeNumber) 
	{
		to TypeNumber^   = toExpr.typ.Resolved().As(TypeNumber)
		from TypeNumber^ = fromExpr.typ.Resolved().As(TypeNumber)

		if from.size != to.size 
		{
			generate.interp.AddValue(ConvertInstr)
			generate.interp.AddValue(i8(from.size))
			generate.interp.AddValue(i8(to.size))
		}	
		return to.size
	}
	return Size(&toExpr)
}

GenerateBasicIntrinsic fn(generate ref GenerateInterp, function Function^, call Call^) {

	if function == &generate.semantic.intrinsic.abortFn {
		generate.interp.AddValue(TrapInstr)
		generate.interp.AddValue(TrapAbort)
		return
	}
	if function.ident == '&' {
		generate.PushContext(ContextStore)
		for i64(0) .. call.params.list.length {
			generate.PerformVisitAutoReference(^call.params.list[it], i64(call.drefCount[it]))
		}
		generate.PopContext()
		return
	}

	// Everything inside a dref tag is a value
	else if function.ident == 'dref' {
		generate.PushContext(ContextLoad)
		//Println('context address')
		for i64(0) .. call.params.list.length {
			generate.PerformVisitAutoReference(^call.params.list[it], i64(call.drefCount[it]))
		}
		//Println('context end')
		generate.PopContext()
	}
	else 
	{
		generate.PushContext(ContextLoad)
		for i64(0) .. call.params.list.length {
			generate.PerformVisitAutoReference(^call.params.list[it], i64(call.drefCount[it]))

			if call.params.list[it].typ.Resolved().Is(TypeNumber) && function.params.list[it].typ.Resolved().Is(TypeNumber) 
			{
				from TypeNumber^ = call.params.list[it].typ.Resolved().As(TypeNumber)
				to TypeNumber^ = function.params.list[it].typ.Resolved().As(TypeNumber)

				if from.size != to.size {
					generate.interp.AddValue(ConvertInstr)
					generate.interp.AddValue(i8(from.size))
					generate.interp.AddValue(i8(to.size))
				}
			}
		}
		generate.PopContext()
	}

	if function == &generate.semantic.intrinsic.ptr_add {
		generate.interp.AddValue(AddPtrInstr)
		size i64 = Size(call.params.list[0].typ.As(TypeRef).reference)
		generate.interp.AddValue(size)
		Println('Ptr + ' + String(size))
		return
	}

	if function == &generate.semantic.intrinsic.sizeFn {
		size i64 = Size(call.params.list[0].typ.As(TypeType).reference)
		generate.LoadConst(cast(i64, size))
		Print('Size() : ' + String(size))
		Print('    ')
		Print(^call.params.list[0].typ)
		Println('')
		return
	}

	if function == &generate.semantic.intrinsic.castOp {
		Println('Cast +')
		Assert(Size(call.params.list[0].typ.Resolved().As(TypeType).reference) == Size(call.params.list[1].typ), 'Cant cast to between differnt sized types')
		return
	}
	if function == &generate.semantic.intrinsic.to_u8 {

		generate.interp.AddValue(ConvertInstr)
		generate.interp.AddValue(i8(Size(call.params.list[0])))
		generate.interp.AddValue(i8(1))
		return
	}
	if function == &generate.semantic.intrinsic.to_u16 {

		generate.interp.AddValue(ConvertInstr)
		generate.interp.AddValue(i8(Size(call.params.list[0])))
		generate.interp.AddValue(i8(2))
		return
	}
	if function == &generate.semantic.intrinsic.to_u32 {

		generate.interp.AddValue(ConvertInstr)
		generate.interp.AddValue(i8(Size(call.params.list[0])))
		generate.interp.AddValue(i8(4))
		return
	}
	if function == &generate.semantic.intrinsic.to_u64 {

		generate.interp.AddValue(ConvertInstr)
		generate.interp.AddValue(i8(Size(call.params.list[0])))
		generate.interp.AddValue(i8(8))
		return
	}
	if function == &generate.semantic.intrinsic.to_i8 {

		generate.interp.AddValue(ConvertInstr)
		generate.interp.AddValue(i8(Size(call.params.list[0])))
		generate.interp.AddValue(i8(1))
		return
	}
	if function == &generate.semantic.intrinsic.to_i16 {

		generate.interp.AddValue(ConvertInstr)
		generate.interp.AddValue(i8(Size(call.params.list[0])))
		generate.interp.AddValue(i8(2))
		return
	}
	if function == &generate.semantic.intrinsic.to_i32 {

		generate.interp.AddValue(ConvertInstr)
		generate.interp.AddValue(i8(Size(call.params.list[0])))
		generate.interp.AddValue(i8(4))
		return
	}
	if function == &generate.semantic.intrinsic.to_i64 {
		if call.params.list[0].typ.Resolved() == &f32Type.super {
			generate.interp.AddValue(CastInstr_f32_i64)
			return
		}

		generate.interp.AddValue(ConvertInstr)
		generate.interp.AddValue(i8(Size(call.params.list[0])))
		generate.interp.AddValue(i8(8))
		return
	}
	if function == &generate.semantic.intrinsic.to_f32 {

		generate.interp.AddValue(ConvertInstr)
		generate.interp.AddValue(i8(Size(call.params.list[0])))
		generate.interp.AddValue(i8(8))
		generate.interp.AddValue(CastInstr_i64_f32)
		return
	}
 	// Theses all push two values on the stack and pop one thus 1 - 2 = -1 thus 1 pop
	if function == &generate.semantic.intrinsic.add_i64 {
		generate.interp.AddValue(AddInstr_i64)
		Println('add i64')
	}
	else if function == &generate.semantic.intrinsic.sub_i64 {
		generate.interp.AddValue(SubInstr_i64)
		Println('sub i64')
	}
	else if function == &generate.semantic.intrinsic.div_i64 {
		generate.interp.AddValue(DivInstr_i64)
		Println('div i64')
	}
	else if function == &generate.semantic.intrinsic.mul_i64 {
		generate.interp.AddValue(MulInstr_i64)
		Println('mul i64')
	}
	else if function == &generate.semantic.intrinsic.mod_i64 {
		generate.interp.AddValue(ModInstr_i64)
		Println('mod i64')
	}
	else if function == &generate.semantic.intrinsic.add_f32 {
		generate.interp.AddValue(AddInstr_f32)
		Println('add f32')
	}
	else if function == &generate.semantic.intrinsic.sub_f32 {
		generate.interp.AddValue(SubInstr_f32)
		Println('sub f32')
	}
	else if function == &generate.semantic.intrinsic.div_f32 {
		generate.interp.AddValue(DivInstr_f32)
		Println('div f32')
	}
	else if function == &generate.semantic.intrinsic.mul_f32 {
		generate.interp.AddValue(MulInstr_f32)
		Println('mul f32')
	}
	else if function.ident == '==' {
		generate.Print('Comp: == i64' + '\n')
		generate.interp.AddValue(CompareInstr_i64)
		generate.interp.AddValue(TestEqInstr) // pop i8 then push i8 net 0
	}
	else if function.ident == '!=' {
		generate.Print('Comp: != i64' + '\n')
		generate.interp.AddValue(CompareInstr_i64)
		generate.interp.AddValue(TestNotEqInstr) // pop i8 then push i8 net 0
	}
	else if function.ident == '<' {
		generate.Print('Comp: < i64' + '\n')
		generate.interp.AddValue(CompareInstr_i64)
		generate.interp.AddValue(TestLessInstr) // pop i8 then push i8 net 0
	}
	else if function.ident == '>' {
		generate.Print('Comp: > i64' + '\n')
		generate.interp.AddValue(CompareInstr_i64)
		generate.interp.AddValue(TestGreaterInstr) // pop i8 then push i8 net 0
	}
	else if function.ident == '<=' {
		generate.Print('Comp: <= i64' + '\n')
		generate.interp.AddValue(CompareInstr_i64)
		generate.interp.AddValue(TestLessEqInstr) // pop i8 then push i8 net 0
	}
	else if function.ident == '>=' {
		generate.Print('Comp: >= i64' + '\n')
		generate.interp.AddValue(CompareInstr_i64)
		generate.interp.AddValue(TestGreaterEqInstr) // pop i8 then push i8 net 0
	}
	else if function.ident == 'dref' {
		if generate.Context() == ContextStore {
			Println('dref: no op context store')
		}
		else {
			Print('dref:')
			generate.LoadAddressInstr(Size(call.params.list[0].typ.Resolved().As(TypeRef).reference))
		}
	}
	else
	{
		Println('----unhandled intrinsic interp -----' + function.ident)
		Assert(0)
	}
}
