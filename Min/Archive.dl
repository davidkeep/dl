
@import{
	'Lexer.dl',
	'Vec.dl',
	'Transform.dl',
	'Sprite.dl',
}

//@TODO change to enum
ArchiveNone i64 = 0
ArchiveArray i64 = 1
ArchiveTable i64 = 2
ArchiveNumber i64 = 3
ArchiveString i64 = 4

Archive struct
{
	Type i64 
	id str
	string str
	number f64
	array DynamicArray(Archive)
}

Archive fn() Archive
{
	self Archive
	Init(self.array)
	self.Type = ArchiveNone
	self.id = ''
	self.string = ''
	return self
}

Load fn(self Archive, v ref Vec4){
	v.x = f32(self.array[0].number)
	v.y = f32(self.array[1].number)
	v.z = f32(self.array[2].number)
	v.w = f32(self.array[3].number)
}
Load fn(self Archive, v ref Vec3){
	v.x = f32(self.array[0].number)
	v.y = f32(self.array[1].number)
	v.z = f32(self.array[2].number)
}
Save fn(self ref Archive, v u64){
	self.Type = ArchiveNumber
	self.number = f64(v)
}
Save fn(self ref Archive, v i64){
	self.Type = ArchiveNumber
	self.number = f64(v)
}
Save fn(self ref Archive, v f64){
	self.Type = ArchiveNumber
	self.number = v
}
Save fn(self ref Archive, v f32){
	self.Type = ArchiveNumber
	self.number = f64(v)
}
Save fn(self ref Archive, string str){
	self.Type = ArchiveString
	self.string = string
}
Save fn(self ref Archive, v Vec4)
{
	self.Type = ArchiveArray
	Resize(self.array, 4)
	Save(self.array[0], v.x)
	Save(self.array[1], v.y)
	Save(self.array[2], v.z)
	Save(self.array[3], v.w)
}
Save fn(self ref Archive, v Vec3)
{
	self.Type = ArchiveArray
	Resize(self.array, 3)
	Save(self.array[0], v.x)
	Save(self.array[1], v.y)
	Save(self.array[2], v.z)
}
Save fn(self ref Archive, v Vec2)
{
	self.Type = ArchiveArray
	Resize(self.array, 2)
	Save(self.array[0], v.x)
	Save(self.array[1], v.y)
}

OpArray fn(self ref Archive, field str) ref Archive
{
	for i64(0) .. self.array.length {
		if Equal(self.array[it].id, field){
			return self.array[it]
		}
	}
	Push(self.array, Archive())
	self.array[self.array.length - 1].id = field
	return self.array[self.array.length - 1]
}

Save fn(self ref Archive, transform Transform)
{
	self.Type = ArchiveTable
	Save(self['Position'], Position(transform))
	Save(self['Scale'], Scale(transform))
}

Save fn(self ref Archive, sprite Sprite)
{
	self.Type = ArchiveTable
	Save(self['Texture'], sprite.material.texture.file)
	Save(self['Vertex'], sprite.material.shader.vs)
	Save(self['Fragment'], sprite.material.shader.fs)
	Save(self['Color'], sprite.color)
}

PrintDepth fn(depth i64)
{
	for i64(0) .. depth
	{
		Print('\t')
	}
}

WriteDepth fn(file File^, depth i64)
{
	for i64(0) .. depth
	{
		Write(file,'\t')
	}
}

Print fn(self ref Archive, depth ref i64)
{
	if(self.Type == ArchiveArray)
	{
		for i64(0) .. self.array.length
		{
			Print(self.array[it], depth)
			Print(' ')
		}
	}
	if(self.Type == ArchiveTable)
	{
		depth = depth + 1

		for i64(0) .. self.array.length
		{
			PrintDepth(depth)
			Print(self.array[it].id)
			Print(' ')
			Print(self.array[it], depth)
			Print('\n')
		}
		if(depth > 0){
			PrintDepth(depth)
			Print('}\n')
		}
		depth = depth - 1
	}
	if(self.Type == ArchiveString)
	{
		Print(self.string)
	}
	if(self.Type == ArchiveNumber)
	{
		Print(String(f32(self.number)))
	}
	if(self.Type == ArchiveNone)
	{
		Print('nil')
	}
}

Write fn(file File^, string str)
{
	FileWrite(cast(voidptr, string.chars), 1, u64(string.length), file)
}
ArchiveFile fn(self ref Archive, file File^, depth i64)
{
	if(self.Type == ArchiveArray)
	{
		Write(file, '(')
		for i64(0) .. self.array.length
		{
			ArchiveFile(self.array[it],file, depth)
			Write(file, ' ')
		}
		Write(file, ')')
	}
	if(self.Type == ArchiveTable)
	{
		depth = depth + 1

		if(depth > 0){
			Write(file, '{\n')
		}
		for i64(0) .. self.array.length
		{
			WriteDepth(file, depth)
			Write(file,self.array[it].id)
			Write(file, ' ')
			ArchiveFile(self.array[it], file, depth)
			Write(file,'\n')
		}
		depth = depth - 1

		if(depth >= 0){
			WriteDepth(file, depth)
			Write(file,'}')
		}
	}
	if(self.Type == ArchiveString)
	{
		Write(file, '\'')
		Write(file, self.string)
		Write(file, '\'')
	}
	if(self.Type == ArchiveNumber)
	{
		Write(file, String(f32(self.number)))
	}
	if(self.Type == ArchiveNone)
	{
		Write(file, 'nil')
	}
}
ArchiveFile fn(self ref Archive, file str) 
{
	f File^ = FileOpen(file.chars, 'w'.chars)
	ArchiveFile(self, f, -1)
}
Unarchive fn(file str) Archive
{
	archive Archive = Archive()
	archive.Type = ArchiveTable
	lexer Lexer = Lexer(file)
	Unarchive(archive, lexer)
	return archive
}
Unarchive fn(archive ref Archive, lexer ref Lexer) i8
{
	if archive.Type == ArchiveNone
	{
		if lexer.token.Type == Char('{')
		{
			Consume(lexer)

			archive.Type = ArchiveTable
			Unarchive(archive, lexer)

			if lexer.token.Type != Char('}')
			{
				Print('Expected }')
			}
			Consume(lexer)
			return true
		}
		if lexer.token.Type == Char('(')
		{
			Consume(lexer)
			archive.Type = ArchiveArray
			Unarchive(archive, lexer)
			if lexer.token.Type != Char(')')
			{
				Print('Expected )')
			}
			Consume(lexer)
			return true
		}
		if lexer.token.Type == LexerNumber
		{
			archive.Type = ArchiveNumber
			archive.number = lexer.token.number
			Consume(lexer)
			return true
		}
		if lexer.token.Type == LexerString
		{
			archive.Type = ArchiveString
			archive.string = lexer.token.string
			Consume(lexer)
			return true
		}
		return false
	}
	else if archive.Type == ArchiveTable
	{
		for lexer.token.Type == LexerIdentifier{
			t Token = lexer.token
			Consume(lexer)
			Unarchive(archive[t.string], lexer)
		}
	}
	else if archive.Type == ArchiveArray
	{
		a Archive = Archive()
		for Unarchive(a, lexer) {
			Push(archive.array, a)
			a = Archive()
		}
	}
	else {
		return false
	}
	return true
}
