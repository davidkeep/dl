#include "../lang/Header.h"
struct TypeInfo;
struct tuple1;
struct tuple2;
struct tuple3;
struct tuple4;
struct str;
struct Command;
struct DynamicArray1;
struct Vec2;
struct RenderTarget;
struct Texture;
struct DynamicArray2;
struct Vec4;
struct PositionTextureColor;
struct Shader;
struct Material;
struct Sprite;
struct ShadingPass;
struct DynamicArray3;
struct tuple5;
struct TableNode1;
struct DynamicArray4;
struct Table1;
struct tuple6;
struct TableNode2;
struct DynamicArray5;
struct Table2;
struct Renderer;
struct tuple7;
struct Callback1;
struct DynamicArray6;
struct MouseCallback;
struct DynamicArray7;
struct Window;
struct Mat4;
struct Camera;
struct Scene;
struct DynamicArray8;
struct Archive;
struct Array1;
struct Entity;
struct Array2;
struct Vec3;
struct DynamicArray9;
struct Transform;
struct Array3;
struct Array4;
struct Editable;
struct Array5;
struct PositionTextureColorColor;
struct Array6;
struct Array7;
struct Mesh;
struct Array8;
struct World;
struct tuple8;
struct tuple9;
struct Quaternion;
struct tuple10;
struct tuple11;
struct Array9;
struct tuple12;
struct File;
struct tuple13;
struct tuple14;
struct tuple15;
struct tuple16;
struct tuple17;
struct tuple18;
struct tuple19;
struct tuple20;
struct tuple21;
struct tuple22;
struct tuple23;
struct Token;
struct Lexer;
struct DynamicArray10;
struct tuple24;
struct tuple25;
struct tuple26;
struct tuple27;
struct tuple28;
struct tuple29;
struct Array10;
struct tuple30;
struct tuple31;
struct Buffer;
struct tuple32;
struct tuple33;
struct tuple34;
struct tuple35;
struct tuple36;
struct tuple37;
struct tuple38;
struct Index1;
struct tuple39;
struct GLFWwindow;
struct tuple40;
struct tuple41;
struct tuple42;
struct GLFWmonitor;
struct tuple43;
struct tuple44;
struct tuple45;
struct tuple46;
struct tuple47;
struct tuple48;
struct Array11;
struct tuple49;
struct tuple50;
struct tuple51;
struct tuple52;
struct tuple53;
struct spBoneData;
struct spSlotData;
struct spSkin;
struct spEventData;
struct spTimeline;
struct spAnimation;
struct spIkConstraintData;
struct spTransformConstraintData;
struct spPathConstraintData;
struct spSkeletonData;
struct spBone;
struct spAttachmentLoader;
struct spAttachment;
struct spSlot;
struct spIkConstraint;
struct spTransformConstraint;
struct spPathConstraint;
struct spSkeleton;
struct spAnimationStateData;
struct spTrackEntry;
struct spAnimationState;
struct Array12;
struct Spine;
struct spAtlasPage;
struct spAtlasRegion;
struct spAtlas;
struct spSkeletonJson;
struct tuple54;
struct tuple55;
struct tuple56;
struct tuple57;
struct Editor;
struct Ray;
struct tuple58;
struct tuple59;
struct Plane;
struct tuple60;
struct tuple61;
struct tuple62;
struct tuple63;
struct spRegionAttachment;
struct spVertexAttachment;
struct spMeshAttachment;
struct CameraBlock;
struct tuple64;
struct tuple65;
struct TransformBlock;
struct tuple66;
struct tuple67;
struct tuple68;
struct tuple69;
struct GLFWvidmode;
struct GLFWgammaramp;
struct imag;
struct GLFWcursor;
struct spAtlasRegion;
struct spEvent;
struct spAttachmentLoader;
struct spTimeline;
struct spSkeleton;
struct spCurveTimeline;
struct spBaseTimeline;
struct spRotateTimeline;
struct spTranslateTimeline;
struct spScaleTimeline;
struct spShearTimeline;
struct spColorTimeline;
struct spAttachmentTimeline;
struct spEventTimeline;
struct spDrawOrderTimeline;
struct spDeformTimeline;
struct spIkConstraintTimeline;
struct spTransformConstraintTimeline;
struct spPathConstraintPositionTimeline;
struct spPathConstraintSpacingTimeline;
struct spPathConstraintMixTimeline;
struct spBoneData;
struct spSkeleton;
struct _Entry;
struct _Entry;
struct _spSkin;
struct spAnimationState;
struct spTrackEntry;
struct spAtlas;
struct spAtlasPage;
struct spAtlasRegion;
struct spAtlasAttachmentLoader;
struct spSkeleton;
struct spBone;
struct spVertexAttachment;
struct spMeshAttachment;
struct spBoundingBoxAttachment;
struct spSkeleton;
struct spSkeleton;
struct spPathAttachment;
struct spSkeleton;
struct spPolygon;
struct spSkeletonBounds;
struct spAtlasAttachmentLoader;
struct spSkeletonBinary;
struct spAtlasAttachmentLoader;
struct TypeInfo{
	u32 size;
};
struct tuple1{
	i64 i0;
	i64 i1;
};
struct tuple2{
	f64 i0;
	f64 i1;
};
struct tuple3{
	f32 i0;
	f32 i1;
};
struct tuple4{
	u64 i0;
	u64 i1;
};
struct str{
	i64 length;
	i8* chars;
};
struct Command{
	u32 vao;
	i32 count;
};
struct DynamicArray1{
	i64 capacity;
	i64 length;
	Command* elements;
};
struct Vec2{
	f32 x;
	f32 y;
};
struct RenderTarget{
	Vec2 position;
	Vec2 size;
	u32 framebuffer;
};
struct Texture{
	u32 id;
	Vec2 size;
	str file;
};
struct DynamicArray2{
	i64 capacity;
	i64 length;
	Texture** elements;
};
struct Vec4{
	f32 x;
	f32 y;
	f32 z;
	f32 w;
};
struct PositionTextureColor{
	Vec2 position;
	Vec2 texture;
	Vec4 color;
};
struct Shader{
	u32 id;
	str vs;
	str fs;
};
struct Material{
	Shader shader;
	Texture texture;
};
struct Sprite{
	PositionTextureColor* vertices;
	u16* indices;
	u32 vao;
	Material material;
	u32 buffer;
	u32 index;
	Vec4 color;
	u32 count;
};
struct ShadingPass{
	i8 render;
	i8 clear;
	RenderTarget target;
	DynamicArray2 in;
	DynamicArray2 out;
	Sprite sprite;
};
struct DynamicArray3{
	i64 capacity;
	i64 length;
	ShadingPass* elements;
};
struct tuple5{
	str i0;
	Shader* i1;
};
struct TableNode1{
	i64 hash;
	str key;
	Shader* value;
};
struct DynamicArray4{
	i64 capacity;
	i64 length;
	TableNode1* elements;
};
struct Table1{
	i64 length;
	i64 capacity;
	DynamicArray4 data;
};
struct tuple6{
	str i0;
	Texture* i1;
};
struct TableNode2{
	i64 hash;
	str key;
	Texture* value;
};
struct DynamicArray5{
	i64 capacity;
	i64 length;
	TableNode2* elements;
};
struct Table2{
	i64 length;
	i64 capacity;
	DynamicArray5 data;
};
struct Renderer{
	DynamicArray1 commands;
	DynamicArray3 passes;
	Table1 shaders;
	Table2 textures;
};
struct tuple7{
	voidptr i0;
	Vec2 i1;
};
struct Callback1{
	voidptr self;
	func func;
};
struct DynamicArray6{
	i64 capacity;
	i64 length;
	Callback1* elements;
};
struct MouseCallback{
	voidptr self;
	func Up;
	func Down;
};
struct DynamicArray7{
	i64 capacity;
	i64 length;
	MouseCallback* elements;
};
struct Window{
	Vec2 size;
	f32 time;
	Vec2 mouse;
	DynamicArray6 resized;
	DynamicArray7 mouseCallbacks;
};
struct Mat4{
	Vec4 x;
	Vec4 y;
	Vec4 z;
	Vec4 w;
};
struct Camera{
	Mat4 projection;
	Mat4 view;
	Mat4 viewProjection;
	Vec2 viewportPosition;
	Vec2 viewportScale;
	f32 near;
	f32 far;
	f32 fieldOfView;
	Vec4 clearColor;
	i8 clear;
};
struct Scene{
	Renderer* renderer;
	Window* window;
	Camera* camera;
};
struct DynamicArray8{
	i64 capacity;
	i64 length;
	Archive* elements;
};
struct Archive{
	i64 Type;
	str id;
	str string;
	f64 number;
	DynamicArray8 array;
};
struct Array1{
	i64 length;
	i64* elements;
};
struct Entity{
	i64 id;
	i64 version;
};
struct Array2{
	i64 length;
	Entity* elements;
};
struct Vec3{
	f32 x;
	f32 y;
	f32 z;
};
struct DynamicArray9{
	i64 capacity;
	i64 length;
	Transform** elements;
};
struct Transform{
	Entity entity;
	Mat4 matrix;
	Vec3 position;
	Vec3 scale;
	Transform* parent;
	DynamicArray9 children;
};
struct Array3{
	i64 length;
	Transform* elements;
};
struct Array4{
	i64 length;
	Sprite* elements;
};
struct Editable{
	Entity entity;
	Entity transform;
	i8 selected;
};
struct Array5{
	i64 length;
	Editable* elements;
};
struct PositionTextureColorColor{
	Vec3 position;
	Vec2 texture;
	Vec4 color;
	Vec4 colorAlt;
};
struct Array6{
	i64 length;
	PositionTextureColorColor* elements;
};
struct Array7{
	i64 length;
	u16* elements;
};
struct Mesh{
	Array6 vertices;
	Array7 indices;
	Material material;
	u32 vao;
	u32 buffer;
	u32 index;
	Vec4 color;
	u32 count;
};
struct Array8{
	i64 length;
	Mesh* elements;
};
struct World{
	i64 count;
	Array1 components;
	Array2 entities;
	Array3 transforms;
	Array4 sprites;
	Array5 editables;
	Array8 meshes;
};
struct tuple8{
	Array1& i0;
	i64 i1;
};
struct tuple9{
	i64 i0;
};
struct Quaternion{
	f32 w;
	f32 x;
	f32 y;
	f32 z;
};
struct tuple10{
	DynamicArray8& i0;
	i64 i1;
};
struct tuple11{
	i8* i0;
	i8* i1;
	i64 i2;
};
struct Array9{
	i64 length;
	i8* elements;
};
struct tuple12{
	Array9& i0;
	i64 i1;
};
struct tuple13{
	DynamicArray8& i0;
	Archive i1;
};
struct tuple14{
	Array2& i0;
	i64 i1;
};
struct tuple15{
	i64 i0;
};
struct tuple16{
	Array3& i0;
	i64 i1;
};
struct tuple17{
	i64 i0;
};
struct tuple18{
	Array4& i0;
	i64 i1;
};
struct tuple19{
	i64 i0;
};
struct tuple20{
	Array5& i0;
	i64 i1;
};
struct tuple21{
	i64 i0;
};
struct tuple22{
	Array8& i0;
	i64 i1;
};
struct tuple23{
	i64 i0;
};
struct Token{
	i32 Type;
	str string;
	f64 number;
};
struct Lexer{
	File* file;
	i32 nextCharacter;
	Token token;
};
struct DynamicArray10{
	i64 capacity;
	i64 length;
	i8* elements;
};
struct tuple24{
	DynamicArray10& i0;
	i8 i1;
};
struct tuple25{
	DynamicArray10& i0;
	i64 i1;
};
struct tuple26{
	Entity i0;
};
struct tuple27{
	Entity i0;
};
struct tuple28{
	i64 i0;
};
struct tuple29{
	i64 i0;
};
struct Array10{
	i64 length;
	u8* elements;
};
struct tuple30{
	Array10& i0;
	i64 i1;
};
struct tuple31{
	Table2& i0;
	str i1;
};
struct Buffer{
	u32 id;
	u32 buffertype;
	i64 length;
	voidptr ptr;
};
struct tuple32{
	DynamicArray5& i0;
	i64 i1;
};
struct tuple33{
	i64 i0;
};
struct tuple34{
	Array7& i0;
	i64 i1;
};
struct tuple35{
	Table1& i0;
	str i1;
};
struct tuple36{
	DynamicArray4& i0;
	i64 i1;
};
struct tuple37{
	i64 i0;
};
struct tuple38{
	Entity i0;
};
struct Index1{
	Transform* item;
	i64 i;
	World world;
};
struct tuple39{
	DynamicArray9& i0;
	i64 i1;
};
struct tuple40{
	DynamicArray6& i0;
	i64 i1;
};
struct tuple41{
	Callback1 i0;
	Vec2 i1;
};
struct tuple42{
	DynamicArray7& i0;
	i64 i1;
};
struct tuple43{
	GLFWwindow* i0;
	u32 i1;
	u32 i2;
};
struct tuple44{
	GLFWwindow* i0;
	u32 i1;
	u32 i2;
	u32 i3;
};
struct tuple45{
	GLFWwindow* i0;
	f64 i1;
	f64 i2;
};
struct tuple46{
	DynamicArray6& i0;
	Callback1 i1;
};
struct tuple47{
	DynamicArray2& i0;
	Texture* i1;
};
struct tuple48{
	DynamicArray2& i0;
	i64 i1;
};
struct Array11{
	i64 length;
	u32* elements;
};
struct tuple49{
	Array11& i0;
	i64 i1;
};
struct tuple50{
	i64 i0;
};
struct tuple51{
	DynamicArray3& i0;
	ShadingPass i1;
};
struct tuple52{
	DynamicArray3& i0;
	i64 i1;
};
struct tuple53{
	Entity i0;
};
struct spBoneData{
	i32 index;
	i8* name;
	spBoneData* parent;
	f32 length;
	f32 x;
	f32 y;
	f32 rotation;
	f32 scaleX;
	f32 scaleY;
	f32 shearX;
	f32 shearY;
	i32 transformMode;
};
struct spSlotData{
	i32 index;
	i8* name;
	spBoneData* boneData;
	i8* attachmentName;
	f32 r;
	f32 g;
	f32 b;
	f32 a;
	i32 blendMode;
};
struct spSkin{
	i8* name;
};
struct spEventData{
	i8* name;
	i32 intValue;
	f32 floatValue;
	i8* stringValue;
};
struct spTimeline{
	i32 kind;
	voidptr vtable;
};
struct spAnimation{
	i8* name;
	f32 duration;
	i32 timelinesCount;
	spTimeline** timelines;
};
struct spIkConstraintData{
	i8* name;
	i32 order;
	i32 bonesCount;
	spBoneData** bones;
	spBoneData* target;
	i32 bendDirection;
	f32 mix;
};
struct spTransformConstraintData{
	i8* name;
	i32 order;
	i32 bonesCount;
	spBoneData** bones;
	spBoneData* target;
	f32 rotateMix;
	f32 translateMix;
	f32 scaleMix;
	f32 shearMix;
	f32 offsetRotation;
	f32 offsetX;
	f32 offsetY;
	f32 offsetScaleX;
	f32 offsetScaleY;
	f32 offsetShearY;
};
struct spPathConstraintData{
	i8* name;
	i32 order;
	i32 bonesCount;
	spBoneData** bones;
	spSlotData* target;
	i32 positionMode;
	i32 spacingMode;
	i32 rotateMode;
	f32 offsetRotation;
	f32 position;
	f32 spacing;
	f32 rotateMix;
	f32 translateMix;
};
struct spSkeletonData{
	i8* version;
	i8* hash;
	f32 width;
	f32 height;
	i32 bonesCount;
	spBoneData** bones;
	i32 slotsCount;
	spSlotData** slots;
	i32 skinsCount;
	spSkin** skins;
	spSkin* defaultSkin;
	i32 eventsCount;
	spEventData** events;
	i32 animationsCount;
	spAnimation** animations;
	i32 ikConstraintsCount;
	spIkConstraintData** ikConstraints;
	i32 transformConstraintsCount;
	spTransformConstraintData** transformConstraints;
	i32 pathConstraintsCount;
	spPathConstraintData** pathConstraints;
};
struct spBone{
	spBoneData* data;
	spSkeleton* skeleton;
	spBone* parent;
	i32 childrenCount;
	spBone** children;
	f32 x;
	f32 y;
	f32 rotation;
	f32 scaleX;
	f32 scaleY;
	f32 shearX;
	f32 shearY;
	f32 ax;
	f32 ay;
	f32 arotation;
	f32 ascaleX;
	f32 ascaleY;
	f32 ashearX;
	f32 ashearY;
	i32 appliedValid;
	f32 a;
	f32 b;
	f32 worldX;
	f32 c;
	f32 d;
	f32 worldY;
	i32 sorted;
};
struct spAttachmentLoader{
	i8* error1;
	i8* error2;
	voidptr vtable;
};
struct spAttachment{
	i8* name;
	i32 kind;
	voidptr vtable;
	spAttachmentLoader* attachmentLoader;
};
struct spSlot{
	spSlotData* data;
	spBone* bone;
	f32 r;
	f32 g;
	f32 b;
	f32 a;
	spAttachment* attachment;
	i32 attachmentVerticesCapacity;
	i32 attachmentVerticesCount;
	f32* attachmentVertices;
};
struct spIkConstraint{
	spIkConstraintData* data;
	i32 bonesCount;
	spBone** bones;
	spBone* target;
	i32 bendDirection;
	f32 mix;
};
struct spTransformConstraint{
	spTransformConstraintData* data;
	i32 bonesCount;
	spBone** bones;
	spBone* target;
	f32 rotateMix;
	f32 translateMix;
	f32 scaleMix;
	f32 shearMix;
};
struct spPathConstraint{
	spPathConstraintData* data;
	i32 bonesCount;
	spBone** bones;
	spSlot* target;
	f32 position;
	f32 spacing;
	f32 rotateMix;
	f32 translateMix;
	i32 spacesCount;
	f32* spaces;
	i32 positionsCount;
	f32* positions;
	i32 worldCount;
	f32* world;
	i32 curvesCount;
	f32* curves;
	i32 lengthsCount;
	f32* lengths;
	f32 segments[10];
};
struct spSkeleton{
	spSkeletonData* data;
	i32 bonesCount;
	spBone** bones;
	spBone* root;
	i32 slotsCount;
	spSlot** slots;
	spSlot** drawOrder;
	i32 ikConstraintsCount;
	spIkConstraint** ikConstraints;
	i32 transformConstraintsCount;
	spTransformConstraint** transformConstraints;
	i32 pathConstraintsCount;
	spPathConstraint** pathConstraints;
	spSkin* skin;
	f32 r;
	f32 g;
	f32 b;
	f32 a;
	f32 time;
	i32 flipX;
	i32 flipY;
	f32 x;
	f32 y;
};
struct spAnimationStateData{
	spSkeletonData* skeletonData;
	f32 defaultMix;
	voidptr entries;
};
struct spTrackEntry{
	spAnimation* animation;
	spTrackEntry* next;
	spTrackEntry* mixingFrom;
	voidptr listener;
	i32 trackIndex;
	i32 loop;
	f32 eventThreshold;
	f32 attachmentThreshold;
	f32 drawOrderThreshold;
	f32 animationStart;
	f32 animationEnd;
	f32 animationLast;
	f32 nextAnimationLast;
	f32 delay;
	f32 trackTime;
	f32 trackLast;
	f32 nextTrackLast;
	f32 trackEnd;
	f32 timeScale;
	f32 alpha;
	f32 mixTime;
	f32 mixDuration;
	f32 mixAlpha;
	i32* timelinesFirst;
	i32 timelinesFirstCount;
	f32* timelinesRotation;
	i32 timelinesRotationCount;
	voidptr rendererObject;
};
struct spAnimationState{
	spAnimationStateData* data;
	i32 tracksCount;
	spTrackEntry** tracks;
	voidptr listener;
	f32 timeScale;
	voidptr rendererObject;
};
struct Array12{
	i64 length;
	f32* elements;
};
struct Spine{
	Entity entity;
	str spineFile;
	str atlasFile;
	spSkeleton* skeleton;
	spAnimationState* state;
	Array12 data;
	Mesh* mesh;
};
struct spAtlasPage{
	spAtlas* atlas;
	i8* name;
	i32 format;
	i32 minFilter;
	i32 magFilter;
	i32 uWrap;
	i32 vWrap;
	voidptr rendererObject;
	i32 width;
	i32 height;
	spAtlasPage* next;
};
struct spAtlasRegion{
	i8* name;
	i32 x;
	i32 y;
	i32 width;
	i32 height;
	f32 u;
	f32 v;
	f32 u2;
	f32 v2;
	i32 offsetX;
	i32 offsetY;
	i32 originalWidth;
	i32 originalHeight;
	i32 index;
	i32 rotate;
	i32 flip;
	i32* splits;
	i32* pads;
	spAtlasPage* page;
	spAtlasRegion* next;
};
struct spAtlas{
	spAtlasPage* pages;
	spAtlasRegion* regions;
	voidptr rendererObject;
};
struct spSkeletonJson{
	f32 scale;
	spAttachmentLoader* attachmentLoader;
	i8* error;
};
struct tuple54{
	Array12& i0;
	i64 i1;
};
struct tuple55{
	i64 i0;
};
struct tuple56{
	Array6& i0;
	i64 i1;
};
struct tuple57{
	i64 i0;
};
struct Editor{
	World* world;
	Camera* camera;
};
struct Ray{
	Vec3 orgin;
	Vec3 direction;
};
struct tuple58{
	i64 i0;
	Transform*& i1;
	Editable*& i2;
};
struct tuple59{
	Entity i0;
};
struct Plane{
	Vec3 orgin;
	Vec3 normal;
};
struct tuple60{
	Editor& i0;
	Vec2 i1;
};
struct tuple61{
	Window& i0;
	Editor& i1;
	func i2;
	func i3;
};
struct tuple62{
	DynamicArray7& i0;
	MouseCallback i1;
};
struct tuple63{
	DynamicArray9& i0;
	Transform* i1;
};
struct spRegionAttachment{
	spAttachment super;
	i8* path;
	f32 x;
	f32 y;
	f32 scaleX;
	f32 scaleY;
	f32 rotation;
	f32 width;
	f32 height;
	f32 r;
	f32 g;
	f32 b;
	f32 a;
	voidptr rendererObject;
	i32 regionOffsetX;
	i32 regionOffsetY;
	i32 regionWidth;
	i32 regionHeight;
	i32 regionOriginalWidth;
	i32 regionOriginalHeight;
	f32 offset[8];
	f32 uvs[8];
};
struct spVertexAttachment{
	spAttachment super;
	i32 bonesCount;
	i32* bones;
	i32 verticesCount;
	f32* vertices;
	i32 worldVerticesLength;
};
struct spMeshAttachment{
	spVertexAttachment super;
	voidptr rendererObject;
	i32 regionOffsetX;
	i32 regionOffsetY;
	i32 regionWidth;
	i32 regionHeight;
	i32 regionOriginalWidth;
	i32 regionOriginalHeight;
	f32 regionU;
	f32 regionV;
	f32 regionU2;
	f32 regionV2;
	i32 regionRotate;
	i8* path;
	f32* regionUVs;
	f32* uvs;
	i32 trianglesCount;
	u16* triangles;
	f32 r;
	f32 g;
	f32 b;
	f32 a;
	i32 hullLength;
	spMeshAttachment* parentMesh;
	i32 inheritDeform;
	i32 edgesCount;
	i32* edges;
	f32 width;
	f32 height;
};
struct CameraBlock{
	Mat4 viewProjection;
	Vec2 windowSize;
	Vec2 pixelSize;
	f32 time;
};
struct tuple64{
	CameraBlock i0;
	i64 i1;
};
struct tuple65{
	Buffer i0;
	CameraBlock i1;
};
struct TransformBlock{
	Mat4 matrix;
};
struct tuple66{
	TransformBlock i0;
	i64 i1;
};
struct tuple67{
	i64 i0;
	Transform*& i1;
	Sprite*& i2;
};
struct tuple68{
	Buffer i0;
	TransformBlock i1;
};
struct tuple69{
	i64 i0;
	Transform*& i1;
	Mesh*& i2;
};
struct imag{
	i32 width;
	i32 height;
	u8* pixels;
};
struct spEvent{
	spEventData* data;
	f32 time;
	i32 intValue;
	f32 floatValue;
	i8* stringValue;
};
struct spCurveTimeline{
	spTimeline super;
	f32* curves;
};
struct spBaseTimeline{
	spCurveTimeline super;
	i32 framesCount;
	f32* frames;
	i32 boneIndex;
};
struct spColorTimeline{
	spCurveTimeline super;
	i32 framesCount;
	f32* frames;
	i32 slotIndex;
};
struct spAttachmentTimeline{
	spTimeline super;
	i32 framesCount;
	f32* frames;
	i32 slotIndex;
	i8** attachmentNames;
};
struct spEventTimeline{
	spTimeline super;
	i32 framesCount;
	f32* frames;
	spEvent** events;
};
struct spDrawOrderTimeline{
	spTimeline super;
	i32 framesCount;
	f32* frames;
	i32** drawOrders;
	i32 slotsCount;
};
struct spDeformTimeline{
	spCurveTimeline super;
	i32 framesCount;
	f32* frames;
	i32 frameVerticesCount;
	f32** frameVertices;
	i32 slotIndex;
	spAttachment* attachment;
};
struct spIkConstraintTimeline{
	spCurveTimeline super;
	i32 framesCount;
	f32* frames;
	i32 ikConstraintIndex;
};
struct spTransformConstraintTimeline{
	spCurveTimeline super;
	i32 framesCount;
	f32* frames;
	i32 transformConstraintIndex;
};
struct spPathConstraintPositionTimeline{
	spCurveTimeline super;
	i32 framesCount;
	f32* frames;
	i32 pathConstraintIndex;
};
struct spPathConstraintSpacingTimeline{
	spCurveTimeline super;
	i32 framesCount;
	f32* frames;
	i32 pathConstraintIndex;
};
struct spPathConstraintMixTimeline{
	spCurveTimeline super;
	i32 framesCount;
	f32* frames;
	i32 pathConstraintIndex;
};
struct _Entry{
	i32 slotIndex;
	i8* name;
	spAttachment* attachment;
	_Entry* next;
};
struct _spSkin{
	spSkin super;
	_Entry* entries;
};
struct spAtlasAttachmentLoader{
	spAttachmentLoader super;
	spAtlas* atlas;
};
struct spBoundingBoxAttachment{
	spVertexAttachment super;
};
struct spPathAttachment{
	spVertexAttachment super;
	i32 lengthsLength;
	f32* lengths;
	i32 closed;
	i32 constantSpeed;
};
struct spPolygon{
	f32* vertices;
	i32 count;
	i32 capacity;
};
struct spSkeletonBounds{
	i32 count;
	spBoundingBoxAttachment** boundingBoxes;
	spPolygon** polygons;
	f32 minX;
	f32 minY;
	f32 maxX;
	f32 maxY;
};
struct spSkeletonBinary{
	f32 scale;
	spAttachmentLoader* attachmentLoader;
	i8* error;
};
extern "C" void abort();
void Load97(str file,Scene& scene);
void Test99(voidptr self,i32 t);
void Test100(voidptr self,Vec2 t);
void Resized101(GLFWwindow* glfwwindow,u32 x,u32 y);
void Mouses102(GLFWwindow* glfwwindow,u32 button,u32 action,u32 mods);
void Moved103(GLFWwindow* glfwwindow,f64 x,f64 y);
i32 main();
void Init0815(Array9& array,i64 length);
void Init0809(Array1& array,i64 length);
void Init2820(Array2& array,i64 length);
void Init3822(Array3& array,i64 length);
void Init4824(Array4& array,i64 length);
void Init5826(Array5& array,i64 length);
void Init6828(Array8& array,i64 length);
void Init7875(Array11& array,i64 length);
void Init8884(Array12& array,i64 length);
void Init9886(Array6& array,i64 length);
void Init10888(Array7& array,i64 length);
i8& OpArray0816(Array9& array,i64 index);
i64& OpArray1835(Array1& array,i64 index);
Editable& OpArray2837(Array5& array,i64 index);
Sprite& OpArray3839(Array4& array,i64 index);
u8& OpArray4843(Array10& array,i64 index);
u16& OpArray5850(Array7& array,i64 index);
Transform& OpArray6858(Array3& array,i64 index);
u32& OpArray7878(Array11& array,i64 index);
Mesh& OpArray8882(Array8& array,i64 index);
PositionTextureColorColor& OpArray9891(Array6& array,i64 index);
f32& OpArray10897(Array12& array,i64 index);
Archive& OpArray0817(DynamicArray8& array,i64 index);
Archive& OpArray0811(DynamicArray8& array,i64 index);
TableNode2& OpArray2847(DynamicArray5& array,i64 index);
TableNode1& OpArray3854(DynamicArray4& array,i64 index);
Transform*& OpArray4860(DynamicArray9& array,i64 index);
Callback1& OpArray5861(DynamicArray6& array,i64 index);
MouseCallback& OpArray6863(DynamicArray7& array,i64 index);
Texture*& OpArray7877(DynamicArray2& array,i64 index);
ShadingPass& OpArray8900(DynamicArray3& array,i64 index);
void Init0830(DynamicArray8& array);
void Init1832(DynamicArray10& array);
void Init2866(DynamicArray3& array);
void Init3868(DynamicArray4& array);
void Init4870(DynamicArray5& array);
void Init5871(DynamicArray2& array);
void Push0818(DynamicArray8& array,Archive value);
void Push1833(DynamicArray10& array,i8 value);
void Push2864(DynamicArray6& array,Callback1 value);
void Push3872(DynamicArray2& array,Texture* value);
void Push4879(DynamicArray3& array,ShadingPass value);
void Push5893(DynamicArray7& array,MouseCallback value);
void Push6895(DynamicArray9& array,Transform* value);
void Reserve0819(DynamicArray8& array,i64 size);
void Reserve1834(DynamicArray10& array,i64 size);
void Reserve2865(DynamicArray6& array,i64 size);
void Reserve3873(DynamicArray2& array,i64 size);
void Reserve4880(DynamicArray3& array,i64 size);
void Reserve5894(DynamicArray7& array,i64 size);
void Reserve6896(DynamicArray9& array,i64 size);
void Resize0846(DynamicArray5& array,i64 size);
void Resize1853(DynamicArray4& array,i64 size);
void Resize2905(DynamicArray8& array,i64 size);
void Init0867(Table1& table);
void Init1869(Table2& table);
void Resize0845(Table2& table);
void Resize1852(Table1& table);
Texture*& OpArray0844(Table2& table,str key);
Shader*& OpArray1851(Table1& table,str key);
extern "C" i32 putchar(i32 c);
extern "C" void abort();
extern "C" i32 strlen(i8* string);
extern "C" i32 strcpy(i8* dst,i8* src);
void Print126(str string);
void Println127(str string);
str String128(i8* string);
void Error129(str string);
str add130(str a,str b);
str String131(i8* chars,i64 length);
str String132(i64 number);
str String133(f32 number);
i64 Equal134(str l,str r);
i64 Hash135(str string);
extern "C" i32 glfwInit();
extern "C" void glfwWindowHint(i32 hint,i32 value);
extern "C" GLFWwindow* glfwCreateWindow(u32 width,u32 height,i8* title,GLFWmonitor* monitor,GLFWwindow* share);
extern "C" u32 glfwWindowShouldClose(GLFWwindow* window);
extern "C" void glfwSetWindowUserPointer(GLFWwindow* window,voidptr pointer);
extern "C" voidptr glfwGetWindowUserPointer(GLFWwindow* window);
extern "C" func glfwSetWindowSizeCallback(GLFWwindow* window,func cbfun);
extern "C" void glfwPollEvents();
extern "C" void glfwGetCursorPos(GLFWwindow* window,f64* xpos,f64* ypos);
extern "C" func glfwSetMouseButtonCallback(GLFWwindow* window,func cbfun);
extern "C" func glfwSetCursorPosCallback(GLFWwindow* window,func cbfun);
extern "C" void glfwMakeContextCurrent(GLFWwindow* window);
extern "C" void glfwSwapBuffers(GLFWwindow* window);
extern "C" void glTexParameteri(u32 target,u32 pname,i32 param);
extern "C" void glTexImage2D(u32 target,i32 level,i32 internalformat,i32 width,i32 height,i32 border,u32 format,u32 ttype,voidptr pixels);
extern "C" void glClear(u32 mask);
extern "C" void glClearColor(f32 red,f32 green,f32 blue,f32 alpha);
extern "C" void glEnable(u32 cap);
extern "C" void glBlendFunc(u32 sfactor,u32 dfactor);
extern "C" u32 glGetError();
extern "C" void glViewport(i32 x,i32 y,i32 width,i32 height);
extern "C" void glDrawElements(u32 mode,i32 count,u32 ttype,voidptr indices);
extern "C" void glBindTexture(u32 target,u32 texture);
extern "C" void glGenTextures(i32 n,u32* textures);
extern "C" void glActiveTexture(u32 texture);
extern "C" void glBindBuffer(u32 target,u32 buffer);
extern "C" void glGenBuffers(i32 n,u32* buffers);
extern "C" void glBufferData(u32 target,i64 size,voidptr data,u32 usage);
extern "C" i8 glUnmapBuffer(u32 target);
extern "C" void glDrawBuffers(i32 n,u32* bufs);
extern "C" void glAttachShader(u32 program,u32 shader);
extern "C" void glCompileShader(u32 shader);
extern "C" u32 glCreateProgram();
extern "C" u32 glCreateShader(u32 theType);
extern "C" void glDeleteProgram(u32 program);
extern "C" void glDeleteShader(u32 shader);
extern "C" void glEnableVertexAttribArray(u32 index);
extern "C" void glGetActiveUniform(u32 program,u32 index,i32 bufSize,i32* length,i32* size,u32* ttype,i8* name);
extern "C" void glGetProgramiv(u32 program,u32 pname,i32* params);
extern "C" void glGetShaderiv(u32 shader,u32 pname,i32* params);
extern "C" void glGetShaderInfoLog(u32 shader,i32 bufSize,i32* length,i8* infoLog);
extern "C" i32 glGetUniformLocation(u32 program,i8* name);
extern "C" void glLinkProgram(u32 program);
extern "C" void glShaderSource(u32 shader,i32 count,i8** string,i32* length);
extern "C" void glUseProgram(u32 program);
extern "C" void glVertexAttribPointer(u32 index,i32 size,u32 ttype,i8 normalized,i32 stride,voidptr pointer);
extern "C" void glBindBufferBase(u32 target,u32 index,u32 buffer);
extern "C" void glBindFramebuffer(u32 target,u32 framebuffer);
extern "C" void glGenFramebuffers(i32 n,u32* framebuffers);
extern "C" u32 glCheckFramebufferStatus(u32 target);
extern "C" void glFramebufferTexture2D(u32 target,u32 attachment,u32 textarget,u32 texture,i32 level);
extern "C" voidptr glMapBufferRange(u32 target,i64 offset,i64 length,u32 access);
extern "C" void glBindVertexArray(u32 array);
extern "C" void glGenVertexArrays(i32 n,u32* arrays);
extern "C" u32 glGetUniformBlockIndex(u32 program,i8* uniformBlockName);
extern "C" void glUniformBlockBinding(u32 program,u32 uniformBlockIndex,u32 uniformBlockBinding);
extern "C" void glProgramUniform1i(u32 program,i32 location,i32 v0);
extern "C" void glBlendFuncSeparatei(u32 buf,u32 srcRGB,u32 dstRGB,u32 srcAlpha,u32 dstAlpha);
str String204(Vec4 v);
str String205(Vec3 v);
str String206(Vec2 v);
Vec4& OpArray207(Mat4& matrix,i64 index);
f32& OpArray208(Vec4& v,i64 index);
Mat4 Mat4209(f32 v);
Mat4 Mat4Scale210(Vec3 scale);
Mat4 Mat4Transform211(Vec3 v);
Mat4 mul212(Mat4 lhs,Mat4 rhs);
Vec4 Vec4213(f32 x,f32 y,f32 z,f32 w);
Vec4 Vec4214(Vec3 v,f32 w);
Vec4 Vec4215(f32 v);
Vec3 Vec3216(f32 x,f32 y,f32 z);
Vec3 Vec3217(f32 value);
Vec3 Vec3218(Vec2 v);
Vec2 Vec2219(Vec3 v);
Vec2 Vec2220(f32 x,f32 y);
Vec2 Vec2221(f32 v);
Vec3 sub222(Vec3 lhs,Vec3 rhs);
Vec3 sub223(Vec3 lhs,Vec2 rhs);
Vec2 sub224(Vec2 lhs,Vec2 rhs);
Vec3 add225(Vec3 lhs,Vec3 rhs);
Vec3 add226(Vec3 lhs,Vec2 rhs);
Vec2 add227(Vec2 lhs,Vec2 rhs);
Vec3 mul228(Vec3 lhs,Vec3 rhs);
Vec4 mul229(f32 l,Vec4 r);
Vec4 mul230(Vec4 l,f32 r);
Vec3 mul231(f32 l,Vec3 r);
Vec3 mul232(Vec3 l,f32 r);
Vec2 mul233(f32 l,Vec2 r);
Vec2 mul234(Vec2 l,f32 r);
Vec2 div235(Vec2 l,f32 r);
Vec3 div236(Vec3 l,f32 r);
Vec4 div237(Vec4 l,f32 r);
f32 Dot238(Vec3 l,Vec3 r);
f32 Dot239(Vec2 l,Vec2 r);
Vec3 Cross240(Vec3 l,Vec3 r);
f32 Length241(Vec3 v);
f32 Length242(Vec2 v);
Vec3 Normalize243(Vec3 v);
Vec2 Normalize244(Vec2 v);
void Init247(World& world);
i64 Bits248();
i64 Bits249();
i64 Bits250();
i64 Bits251();
Array3& Components252();
Array4& Components253();
Array5& Components254();
Array8& Components255();
i8 Retrieve0889(i64 i,Transform*& a,Editable*& b);
i8 Retrieve1902(i64 i,Transform*& a,Sprite*& b);
i8 Retrieve2904(i64 i,Transform*& a,Mesh*& b);
Editable& AddComponent0836(Entity entity);
Sprite& AddComponent1838(Entity entity);
Transform& AddComponent2857(Entity entity);
Mesh& AddComponent3881(Entity entity);
Entity CreateEntity260();
Mesh* Get0890(Entity entity);
Transform& Transform263(Index1 index);
RenderTarget RenderTarget268();
void GenerateFrameBuffer269(RenderTarget& target,DynamicArray2& textures);
void Bind270(RenderTarget target,Window window);
void BindScreen271();
ShadingPass ShadingPass273();
ShadingPass PostProcess274(Sprite& sprite);
void Refresh275(ShadingPass& pass);
Shader& Shader277(Renderer& renderer,str vs,str fs);
Texture& Texture278(Renderer& renderer,str file);
Renderer Renderer279();
void Draw280(Sprite& sprite,Transform& transform);
void Draw281(Mesh& sprite,Transform& transform);
u32 InterfaceBinding284();
u32 InterfaceBinding285();
Buffer CreateInterfaceBlock0898(CameraBlock block,i64 count);
Buffer CreateInterfaceBlock1901(TransformBlock block,i64 count);
void LoadInterfaceBlock0899(Buffer buffer,CameraBlock block);
void LoadInterfaceBlock1903(Buffer buffer,TransformBlock block);
void Draw288(Renderer& renderer,World& world);
void Render289(Renderer& renderer,World& world,Camera camera,Window window);
Archive Archive291();
void Load292(Archive self,Vec4& v);
void Load293(Archive self,Vec3& v);
void Save294(Archive& self,u64 v);
void Save295(Archive& self,i64 v);
void Save296(Archive& self,f64 v);
void Save297(Archive& self,f32 v);
void Save298(Archive& self,str string);
void Save299(Archive& self,Vec4 v);
void Save300(Archive& self,Vec3 v);
void Save301(Archive& self,Vec2 v);
Archive& OpArray302(Archive& self,str field);
void Save303(Archive& self,Transform transform);
void Save304(Archive& self,Sprite sprite);
void PrintDepth305(i64 depth);
void WriteDepth306(File* file,i64 depth);
void Print307(Archive& self,i64& depth);
void Write308(File* file,str string);
void ArchiveFile309(Archive& self,File* file,i64 depth);
void ArchiveFile310(Archive& self,str file);
Archive Unarchive311(str file);
i8 Unarchive312(Archive& archive,Lexer& lexer);
Editor Editor314(World* world,Camera* camera);
Editable* Editable316(Entity entity);
void Selected317(Editable& editable,i8 selected);
i8 MouseDown318(Editor& editor,Vec2 position);
void MouseUp319(Editor& editor,Vec2 position);
void Update320(Editor& editor,Vec2 position);
void AddEditables321(Editor& editor,World& world,Renderer& renderer,Window& window);
extern "C" spAtlas* spAtlas_createFromFile(i8* path,voidptr userptr);
extern "C" i8* _readFile(i8* path,i32* length);
extern "C" void _spAtlasPage_createTexture(spAtlasPage* self,i8* path);
extern "C" void _spAtlasPage_disposeTexture(spAtlasPage* self);
extern "C" i8* _spUtil_readFile(i8* path,i32* length);
Spine Spine329(Renderer& renderer,Mesh* mesh,str spineFile,str atlasFile);
void Update330(Spine& self,f32 delta);
extern "C" voidptr malloc(u64 c);
extern "C" voidptr calloc(u64 nmem,u64 size);
extern "C" voidptr realloc(voidptr nmem,u64 size);
extern "C" voidptr memcpy(voidptr dst,voidptr src,u64 count);
extern "C" voidptr memset(voidptr ptr,i32 value,u64 count);
Texture* new0848(Texture t);
Shader* new1855(Shader t);
void Assert338(i8 condition,str reason);
void Assert339(i8 condition);
i8* Alloc0812(i64 len);
i64* Alloc0810(i64 len);
Entity* Alloc2821(i64 len);
Transform* Alloc3823(i64 len);
Sprite* Alloc4825(i64 len);
Editable* Alloc5827(i64 len);
Mesh* Alloc6829(i64 len);
PositionTextureColor* Alloc7840(i64 len);
u16* Alloc8841(i64 len);
Texture* Alloc9849(i64 len);
Shader* Alloc10856(i64 len);
u32* Alloc11876(i64 len);
f32* Alloc12885(i64 len);
PositionTextureColorColor* Alloc13887(i64 len);
void CopyPtr0813(i8* from,i8* to,i64 len);
i64 i64343(u8 i);
i64 i64344(u16 i);
i64 i64345(u32 i);
i64 i64346(u64 i);
i64 i64347(i8 i);
i64 i64348(i32 i);
i64 i64349(i64 i);
i64 i64350(f32 i);
i64 i64351(f64 i);
i32 i32352(u8 i);
i32 i32353(u32 i);
i32 i32354(u64 i);
i32 i32355(i8 i);
i32 i32356(i32 i);
i32 i32357(i64 i);
i32 i32358(f32 i);
i32 i32359(f64 i);
i8 i8360(u8 i);
i8 i8361(u32 i);
i8 i8362(u64 i);
i8 i8363(i8 i);
i8 i8364(i32 i);
i8 i8365(i64 i);
i8 i8366(f32 i);
i8 i8367(f64 i);
u8 u8368(u8 i);
u8 u8369(u32 i);
u8 u8370(u64 i);
u8 u8371(i8 i);
u8 u8372(i32 i);
u8 u8373(i64 i);
u8 u8374(f32 i);
u8 u8375(f64 i);
u16 u16376(u16 i);
u16 u16377(u32 i);
u16 u16378(u64 i);
u16 u16379(i8 i);
u16 u16380(i32 i);
u16 u16381(i64 i);
u16 u16382(f32 i);
u16 u16383(f64 i);
u32 u32384(u8 i);
u32 u32385(u32 i);
u32 u32386(u64 i);
u32 u32387(i8 i);
u32 u32388(i32 i);
u32 u32389(i64 i);
u32 u32390(f32 i);
u32 u32391(f64 i);
u64 u64392(u8 i);
u64 u64393(u32 i);
u64 u64394(u64 i);
u64 u64395(i8 i);
u64 u64396(i32 i);
u64 u64397(i64 i);
u64 u64398(f32 i);
u64 u64399(f64 i);
f32 f32400(u8 i);
f32 f32401(u32 i);
f32 f32402(u64 i);
f32 f32403(i8 i);
f32 f32404(i32 i);
f32 f32405(i64 i);
f32 f32406(f32 i);
f32 f32407(f64 i);
f64 f64408(u8 i);
f64 f64409(u32 i);
f64 f64410(u64 i);
f64 f64411(i8 i);
f64 f64412(i32 i);
f64 f64413(i64 i);
f64 f64414(f32 i);
f64 f64415(f64 i);
extern "C" f32 cosf(f32 v);
extern "C" f32 sinf(f32 v);
extern "C" f32 tanf(f32 v);
extern "C" f32 fabsf(f32 v);
extern "C" f32 sqrtf(f32 v);
f32 sqrt421(f32 f);
f32 abs422(f32 f);
f32 cos423(f32 f);
f32 sin424(f32 f);
f32 tan425(f32 f);
void Bind430(Material material);
Sprite* Sprite431(Entity entity,Renderer& renderer,str file);
Sprite Sprite432(Renderer& renderer,str file);
void Color433(Sprite& sprite,Vec4 color);
Mesh* Mesh435(Entity entity,Renderer& renderer);
Mesh Mesh436(Renderer& renderer);
void MeshScreenSpaceCircle437(Mesh& mesh,Vec3 position,f32 radius,Vec4 color);
Transform* Transform439(Entity entity);
Vec3 Scale440(Transform self);
void Scale441(Transform& self,Vec3 scale);
Vec3 Position442(Transform& self);
void Position443(Transform& self,Vec3 position);
Vec3 WorldPosition444(Transform self);
void Recalculate445(Transform& self);
void Parent446(Transform& self,Transform& parent);
Buffer Buffer448(u32 buffertype,i64 length);
voidptr Map449(Buffer& buffer,i64 begin,i64 length);
void Unmap450(Buffer buffer);
void Resize451(Buffer buffer,i64 size);
void RegisterMouse0892(Window& window,Editor& self,func Down,func Up);
void Call0862(Callback1 callback,Vec2 data);
void Mouse457(Window& window,Vec2 mouse,i8 down);
void Size458(Window& window,Vec2 size);
extern "C" u8* stbi_load(i8* file,u32* x,u32* y,u32* comp,u32 req);
extern "C" void stbi_image_free(voidptr retval_from_stbi_load);
Texture Texture462(str file);
Texture Texture463(Vec2 size);
Camera Camera465();
Mat4 Frustum466(f32 left,f32 right,f32 bottom,f32 top,f32 near,f32 far);
Mat4 Perspective467(f32 fovy,f32 aspect,f32 zNear,f32 zFar);
Mat4 Translate468(Vec3 translate);
f32 IntersectsPlane471(Ray ray,Plane plane);
Vec3 PointAt472(Ray self,f32 distance);
i8 IntersectsSphere473(Ray self,Vec3 point,f32 radius);
f32 IntersectsSphereDistance474(Ray self,Vec3 point,f32 radius);
Ray ScreenToRay475(Camera self,Vec2 screen);
Vec4 mul476(Mat4 self,Vec4 v);
Mat4 Inverse477(Mat4 v);
i32 Char480(str char);
Lexer Lexer481(str file);
i32 Peek482(Lexer& self);
i32 Get483(Lexer& self);
extern "C" i32 isspace(i32 v);
extern "C" i32 isalpha(i32 v);
extern "C" i32 isalnum(i32 v);
extern "C" i32 isdigit(i32 v);
void Consume488(Lexer& self);
Token Next489(Lexer& self);
extern "C" spEventData* spEventData_create(i8* name);
extern "C" void spEventData_dispose(spEventData* self);
extern "C" spEvent* spEvent_create(f32 time,spEventData* data);
extern "C" void spEvent_dispose(spEvent* self);
extern "C" void spAttachment_dispose(spAttachment* self);
extern "C" spAnimation* spAnimation_create(i8* name,i32 timelinesCount);
extern "C" void spAnimation_dispose(spAnimation* self);
extern "C" void spAnimation_apply(spAnimation* self,spSkeleton* skeleton,f32 lastTime,f32 time,i32 loop,spEvent** events,i32* eventsCount,f32 alpha,i32 setupPose,i32 mixingOut);
extern "C" void spTimeline_dispose(spTimeline* self);
extern "C" void spTimeline_apply(spTimeline* self,spSkeleton* skeleton,f32 lastTime,f32 time,spEvent** firedEvents,i32* eventsCount,f32 alpha,i32 setupPose,i32 mixingOut);
extern "C" i32 spTimeline_getPropertyId(spTimeline* self);
extern "C" void spCurveTimeline_setLinear(spCurveTimeline* self,i32 frameIndex);
extern "C" void spCurveTimeline_setStepped(spCurveTimeline* self,i32 frameIndex);
extern "C" void spCurveTimeline_setCurve(spCurveTimeline* self,i32 frameIndex,f32 cx1,f32 cy1,f32 cx2,f32 cy2);
extern "C" f32 spCurveTimeline_getCurvePercent(spCurveTimeline* self,i32 frameIndex,f32 percent);
extern "C" spRotateTimeline* spRotateTimeline_create(i32 framesCount);
extern "C" void spRotateTimeline_setFrame(spRotateTimeline* self,i32 frameIndex,f32 time,f32 angle);
extern "C" spTranslateTimeline* spTranslateTimeline_create(i32 framesCount);
extern "C" void spTranslateTimeline_setFrame(spTranslateTimeline* self,i32 frameIndex,f32 time,f32 x,f32 y);
extern "C" spScaleTimeline* spScaleTimeline_create(i32 framesCount);
extern "C" void spScaleTimeline_setFrame(spScaleTimeline* self,i32 frameIndex,f32 time,f32 x,f32 y);
extern "C" spShearTimeline* spShearTimeline_create(i32 framesCount);
extern "C" void spShearTimeline_setFrame(spShearTimeline* self,i32 frameIndex,f32 time,f32 x,f32 y);
extern "C" spColorTimeline* spColorTimeline_create(i32 framesCount);
extern "C" void spColorTimeline_setFrame(spColorTimeline* self,i32 frameIndex,f32 time,f32 r,f32 g,f32 b,f32 a);
extern "C" spAttachmentTimeline* spAttachmentTimeline_create(i32 framesCount);
extern "C" void spAttachmentTimeline_setFrame(spAttachmentTimeline* self,i32 frameIndex,f32 time,i8* attachmentName);
extern "C" spEventTimeline* spEventTimeline_create(i32 framesCount);
extern "C" void spEventTimeline_setFrame(spEventTimeline* self,i32 frameIndex,spEvent* event);
extern "C" spDrawOrderTimeline* spDrawOrderTimeline_create(i32 framesCount,i32 slotsCount);
extern "C" void spDrawOrderTimeline_setFrame(spDrawOrderTimeline* self,i32 frameIndex,f32 time,i32* drawOrder);
extern "C" spDeformTimeline* spDeformTimeline_create(i32 framesCount,i32 frameVerticesCount);
extern "C" void spDeformTimeline_setFrame(spDeformTimeline* self,i32 frameIndex,f32 time,f32* vertices);
extern "C" spIkConstraintTimeline* spIkConstraintTimeline_create(i32 framesCount);
extern "C" void spIkConstraintTimeline_setFrame(spIkConstraintTimeline* self,i32 frameIndex,f32 time,f32 mix,i32 bendDirection);
extern "C" spTransformConstraintTimeline* spTransformConstraintTimeline_create(i32 framesCount);
extern "C" void spTransformConstraintTimeline_setFrame(spTransformConstraintTimeline* self,i32 frameIndex,f32 time,f32 rotateMix,f32 translateMix,f32 scaleMix,f32 shearMix);
extern "C" spPathConstraintPositionTimeline* spPathConstraintPositionTimeline_create(i32 framesCount);
extern "C" void spPathConstraintPositionTimeline_setFrame(spPathConstraintPositionTimeline* self,i32 frameIndex,f32 time,f32 value);
extern "C" spPathConstraintSpacingTimeline* spPathConstraintSpacingTimeline_create(i32 framesCount);
extern "C" void spPathConstraintSpacingTimeline_setFrame(spPathConstraintSpacingTimeline* self,i32 frameIndex,f32 time,f32 value);
extern "C" spPathConstraintMixTimeline* spPathConstraintMixTimeline_create(i32 framesCount);
extern "C" void spPathConstraintMixTimeline_setFrame(spPathConstraintMixTimeline* self,i32 frameIndex,f32 time,f32 rotateMix,f32 translateMix);
extern "C" spBoneData* spBoneData_create(i32 index,i8* name,spBoneData* parent);
extern "C" void spBoneData_dispose(spBoneData* self);
extern "C" spSlotData* spSlotData_create(i32 index,i8* name,spBoneData* boneData);
extern "C" void spSlotData_dispose(spSlotData* self);
extern "C" void spSlotData_setAttachmentName(spSlotData* self,i8* attachmentName);
extern "C" spSkin* spSkin_create(i8* name);
extern "C" void spSkin_dispose(spSkin* self);
extern "C" void spSkin_addAttachment(spSkin* self,i32 slotIndex,i8* name,spAttachment* attachment);
extern "C" spAttachment* spSkin_getAttachment(spSkin* self,i32 slotIndex,i8* name);
extern "C" i8* spSkin_getAttachmentName(spSkin* self,i32 slotIndex,i32 attachmentIndex);
extern "C" void spSkin_attachAll(spSkin* self,spSkeleton* skeleton,spSkin* oldspSkin);
extern "C" spIkConstraintData* spIkConstraintData_create(i8* name);
extern "C" void spIkConstraintData_dispose(spIkConstraintData* self);
extern "C" spTransformConstraintData* spTransformConstraintData_create(i8* name);
extern "C" void spTransformConstraintData_dispose(spTransformConstraintData* self);
extern "C" spPathConstraintData* spPathConstraintData_create(i8* name);
extern "C" void spPathConstraintData_dispose(spPathConstraintData* self);
extern "C" spSkeletonData* spSkeletonData_create();
extern "C" void spSkeletonData_dispose(spSkeletonData* self);
extern "C" spBoneData* spSkeletonData_findBone(spSkeletonData* self,i8* boneName);
extern "C" i32 spSkeletonData_findBoneIndex(spSkeletonData* self,i8* boneName);
extern "C" spSlotData* spSkeletonData_findSlot(spSkeletonData* self,i8* slotName);
extern "C" i32 spSkeletonData_findSlotIndex(spSkeletonData* self,i8* slotName);
extern "C" spSkin* spSkeletonData_findSkin(spSkeletonData* self,i8* skinName);
extern "C" spEventData* spSkeletonData_findEvent(spSkeletonData* self,i8* eventName);
extern "C" spAnimation* spSkeletonData_findAnimation(spSkeletonData* self,i8* animationName);
extern "C" spIkConstraintData* spSkeletonData_findIkConstraint(spSkeletonData* self,i8* constraintName);
extern "C" spTransformConstraintData* spSkeletonData_findTransformConstraint(spSkeletonData* self,i8* constraintName);
extern "C" spPathConstraintData* spSkeletonData_findPathConstraint(spSkeletonData* self,i8* constraintName);
extern "C" spAnimationStateData* spAnimationStateData_create(spSkeletonData* skeletonData);
extern "C" void spAnimationStateData_dispose(spAnimationStateData* self);
extern "C" void spAnimationStateData_setMixByName(spAnimationStateData* self,i8* fromName,i8* toName,f32 duration);
extern "C" void spAnimationStateData_setMix(spAnimationStateData* self,spAnimation* from,spAnimation* to,f32 duration);
extern "C" f32 spAnimationStateData_getMix(spAnimationStateData* self,spAnimation* from,spAnimation* to);
extern "C" spAnimationState* spAnimationState_create(spAnimationStateData* data);
extern "C" void spAnimationState_dispose(spAnimationState* self);
extern "C" void spAnimationState_update(spAnimationState* self,f32 delta);
extern "C" void spAnimationState_apply(spAnimationState* self,spSkeleton* skeleton);
extern "C" void spAnimationState_clearTracks(spAnimationState* self);
extern "C" void spAnimationState_clearTrack(spAnimationState* self,i32 trackIndex);
extern "C" spTrackEntry* spAnimationState_setAnimationByName(spAnimationState* self,i32 trackIndex,i8* animationName,i32 loop);
extern "C" spTrackEntry* spAnimationState_setAnimation(spAnimationState* self,i32 trackIndex,spAnimation* animation,i32 loop);
extern "C" spTrackEntry* spAnimationState_addAnimationByName(spAnimationState* self,i32 trackIndex,i8* animationName,i32 loop,f32 delay);
extern "C" spTrackEntry* spAnimationState_addAnimation(spAnimationState* self,i32 trackIndex,spAnimation* animation,i32 loop,f32 delay);
extern "C" spTrackEntry* spAnimationState_setEmptyAnimation(spAnimationState* self,i32 trackIndex,f32 mixDuration);
extern "C" spTrackEntry* spAnimationState_addEmptyAnimation(spAnimationState* self,i32 trackIndex,f32 mixDuration,f32 delay);
extern "C" void spAnimationState_setEmptyAnimations(spAnimationState* self,f32 mixDuration);
extern "C" spTrackEntry* spAnimationState_getCurrent(spAnimationState* self,i32 trackIndex);
extern "C" void spAnimationState_clearListenerNotifications(spAnimationState* self);
extern "C" f32 spTrackEntry_getAnimationTime(spTrackEntry* entry);
extern "C" void spAnimationState_disposeStatics();
extern "C" spAtlasPage* spAtlasPage_create(spAtlas* atlas,i8* name);
extern "C" void spAtlasPage_dispose(spAtlasPage* self);
extern "C" spAtlasRegion* spAtlasRegion_create();
extern "C" void spAtlasRegion_dispose(spAtlasRegion* self);
extern "C" spAtlas* spAtlas_create(i8* data,i32 length,i8* dir,voidptr rendererObject);
extern "C" spAtlas* spAtlas_createFromFile(i8* path,voidptr rendererObject);
extern "C" void spAtlas_dispose(spAtlas* atlas);
extern "C" spAtlasRegion* spAtlas_findRegion(spAtlas* self,i8* name);
extern "C" void spAttachmentLoader_dispose(spAttachmentLoader* self);
extern "C" spAttachment* spAttachmentLoader_createAttachment(spAttachmentLoader* self,spSkin* skin,i8* name,i8* path);
extern "C" void spAttachmentLoader_configureAttachment(spAttachmentLoader* self,spAttachment* attachment);
extern "C" void spAttachmentLoader_disposeAttachment(spAttachmentLoader* self,spAttachment* attachment);
extern "C" spAtlasAttachmentLoader* spAtlasAttachmentLoader_create(spAtlas* atlas);
extern "C" void spBone_setYDown(i32 yDown);
extern "C" i32 spBone_isYDown();
extern "C" spBone* spBone_create(spBoneData* data,spSkeleton* skeleton,spBone* parent);
extern "C" void spBone_dispose(spBone* self);
extern "C" void spBone_setToSetupPose(spBone* self);
extern "C" void spBone_updateWorldTransform(spBone* self);
extern "C" void spBone_updateWorldTransformWith(spBone* self,f32 x,f32 y,f32 rotation,f32 scaleX,f32 scaleY,f32 shearX,f32 shearY);
extern "C" f32 spBone_getWorldRotationX(spBone* self);
extern "C" f32 spBone_getWorldRotationY(spBone* self);
extern "C" f32 spBone_getWorldScaleX(spBone* self);
extern "C" f32 spBone_getWorldScaleY(spBone* self);
extern "C" f32 spBone_worldToLocalRotationX(spBone* self);
extern "C" f32 spBone_worldToLocalRotationY(spBone* self);
extern "C" void spBone_rotateWorld(spBone* self,f32 degrees);
extern "C" void spBone_updateAppliedTransform(spBone* self);
extern "C" void spBone_worldToLocal(spBone* self,f32 worldX,f32 worldY,f32* localX,f32* localY);
extern "C" void spBone_localToWorld(spBone* self,f32 localX,f32 localY,f32* worldX,f32* worldY);
extern "C" spSlot* spSlot_create(spSlotData* data,spBone* bone);
extern "C" void spSlot_dispose(spSlot* self);
extern "C" void spSlot_setAttachment(spSlot* self,spAttachment* attachment);
extern "C" void spSlot_setAttachmentTime(spSlot* self,f32 time);
extern "C" f32 spSlot_getAttachmentTime(spSlot* self);
extern "C" void spSlot_setToSetupPose(spSlot* self);
extern "C" spRegionAttachment* spRegionAttachment_create(i8* name);
extern "C" void spRegionAttachment_setUVs(spRegionAttachment* self,f32 u,f32 v,f32 u2,f32 v2,i32 rotate);
extern "C" void spRegionAttachment_updateOffset(spRegionAttachment* self);
extern "C" void spRegionAttachment_computeWorldVertices(spRegionAttachment* self,spBone* bone,f32* vertices);
extern "C" void spVertexAttachment_computeWorldVertices(spVertexAttachment* self,spSlot* slot,f32* worldVertices);
extern "C" void spVertexAttachment_computeWorldVertices1(spVertexAttachment* self,i32 start,i32 count,spSlot* slot,f32* worldVertices,i32 offset);
extern "C" spMeshAttachment* spMeshAttachment_create(i8* name);
extern "C" void spMeshAttachment_updateUVs(spMeshAttachment* self);
extern "C" void spMeshAttachment_computeWorldVertices(spMeshAttachment* self,spSlot* slot,f32* worldVertices);
extern "C" void spMeshAttachment_setParentMesh(spMeshAttachment* self,spMeshAttachment* parentMesh);
extern "C" spBoundingBoxAttachment* spBoundingBoxAttachment_create(i8* name);
extern "C" void spBoundingBoxAttachment_computeWorldVertices(spBoundingBoxAttachment* self,spSlot* slot,f32* worldVertices);
extern "C" spIkConstraint* spIkConstraint_create(spIkConstraintData* data,spSkeleton* skeleton);
extern "C" void spIkConstraint_dispose(spIkConstraint* self);
extern "C" void spIkConstraint_apply(spIkConstraint* self);
extern "C" void spIkConstraint_apply1(spBone* bone,f32 targetX,f32 targetY,f32 alpha);
extern "C" void spIkConstraint_apply2(spBone* parent,spBone* child,f32 targetX,f32 targetY,i32 bendDirection,f32 alpha);
extern "C" spTransformConstraint* spTransformConstraint_create(spTransformConstraintData* data,spSkeleton* skeleton);
extern "C" void spTransformConstraint_dispose(spTransformConstraint* self);
extern "C" void spTransformConstraint_apply(spTransformConstraint* self);
extern "C" spPathAttachment* spPathAttachment_create(i8* name);
extern "C" void spPathAttachment_computeWorldVertices(spPathAttachment* self,spSlot* slot,f32* worldVertices);
extern "C" void spPathAttachment_computeWorldVertices1(spPathAttachment* self,spSlot* slot,i32 start,i32 count,f32* worldVertices,i32 offset);
extern "C" spPathConstraint* spPathConstraint_create(spPathConstraintData* data,spSkeleton* skeleton);
extern "C" void spPathConstraint_dispose(spPathConstraint* self);
extern "C" void spPathConstraint_apply(spPathConstraint* self);
extern "C" f32* spPathConstraint_computeWorldPositions(spPathConstraint* self,spPathAttachment* path,i32 spacesCount,i32 tangents,i32 percentPosition,i32 percentSpacing);
extern "C" spSkeleton* spSkeleton_create(spSkeletonData* data);
extern "C" void spSkeleton_dispose(spSkeleton* self);
extern "C" void spSkeleton_updateCache(spSkeleton* self);
extern "C" void spSkeleton_updateWorldTransform(spSkeleton* self);
extern "C" void spSkeleton_setToSetupPose(spSkeleton* self);
extern "C" void spSkeleton_setBonesToSetupPose(spSkeleton* self);
extern "C" void spSkeleton_setSlotsToSetupPose(spSkeleton* self);
extern "C" spBone* spSkeleton_findBone(spSkeleton* self,i8* boneName);
extern "C" i32 spSkeleton_findBoneIndex(spSkeleton* self,i8* boneName);
extern "C" spSlot* spSkeleton_findSlot(spSkeleton* self,i8* slotName);
extern "C" i32 spSkeleton_findSlotIndex(spSkeleton* self,i8* slotName);
extern "C" void spSkeleton_setSkin(spSkeleton* self,spSkin* skin);
extern "C" i32 spSkeleton_setSkinByName(spSkeleton* self,i8* skinName);
extern "C" spAttachment* spSkeleton_getAttachmentForSlotName(spSkeleton* self,i8* slotName,i8* attachmentName);
extern "C" spAttachment* spSkeleton_getAttachmentForSlotIndex(spSkeleton* self,i32 slotIndex,i8* attachmentName);
extern "C" i32 spSkeleton_setAttachment(spSkeleton* self,i8* slotName,i8* attachmentName);
extern "C" spIkConstraint* spSkeleton_findIkConstraint(spSkeleton* self,i8* constraintName);
extern "C" spTransformConstraint* spSkeleton_findTransformConstraint(spSkeleton* self,i8* constraintName);
extern "C" spPathConstraint* spSkeleton_findPathConstraint(spSkeleton* self,i8* constraintName);
extern "C" void spSkeleton_update(spSkeleton* self,f32 deltaTime);
extern "C" spPolygon* spPolygon_create(i32 capacity);
extern "C" void spPolygon_dispose(spPolygon* self);
extern "C" i32 spPolygon_containsPoint(spPolygon* polygon,f32 x,f32 y);
extern "C" i32 spPolygon_intersectsSegment(spPolygon* polygon,f32 x1,f32 y1,f32 x2,f32 y2);
extern "C" spSkeletonBounds* spSkeletonBounds_create();
extern "C" void spSkeletonBounds_dispose(spSkeletonBounds* self);
extern "C" void spSkeletonBounds_update(spSkeletonBounds* self,spSkeleton* skeleton,i32 updateAabb);
extern "C" i32 spSkeletonBounds_aabbContainsPoint(spSkeletonBounds* self,f32 x,f32 y);
extern "C" i32 spSkeletonBounds_aabbIntersectsSegment(spSkeletonBounds* self,f32 x1,f32 y1,f32 x2,f32 y2);
extern "C" i32 spSkeletonBounds_aabbIntersectsSkeleton(spSkeletonBounds* self,spSkeletonBounds* bounds);
extern "C" spBoundingBoxAttachment* spSkeletonBounds_containsPoint(spSkeletonBounds* self,f32 x,f32 y);
extern "C" spBoundingBoxAttachment* spSkeletonBounds_intersectsSegment(spSkeletonBounds* self,f32 x1,f32 y1,f32 x2,f32 y2);
extern "C" spPolygon* spSkeletonBounds_getPolygon(spSkeletonBounds* self,spBoundingBoxAttachment* boundingBox);
extern "C" spSkeletonBinary* spSkeletonBinary_createWithLoader(spAttachmentLoader* attachmentLoader);
extern "C" spSkeletonBinary* spSkeletonBinary_create(spAtlas* atlas);
extern "C" void spSkeletonBinary_dispose(spSkeletonBinary* self);
extern "C" spSkeletonData* spSkeletonBinary_readSkeletonData(spSkeletonBinary* self,u16* binary,i32 length);
extern "C" spSkeletonData* spSkeletonBinary_readSkeletonDataFile(spSkeletonBinary* self,i8* path);
extern "C" spSkeletonJson* spSkeletonJson_createWithLoader(spAttachmentLoader* attachmentLoader);
extern "C" spSkeletonJson* spSkeletonJson_create(spAtlas* atlas);
extern "C" void spSkeletonJson_dispose(spSkeletonJson* self);
extern "C" spSkeletonData* spSkeletonJson_readSkeletonData(spSkeletonJson* self,i8* json);
extern "C" spSkeletonData* spSkeletonJson_readSkeletonDataFile(spSkeletonJson* self,i8* path);
Shader Shader764(str vs,str fs);
void GLError765(str string);
void Bind766(Shader shader);
u32 CompileShader767(u32 shaderType,str data,str file);
void AddUniforms768(Shader shader);
str ReadFile769(str file);
Mat4 GetRotationMatrix771(Quaternion q);
Quaternion CreateQuaternion772(Vec3 axis,f32 angle);
Quaternion CreateQuaternion773();
void normalize774(Quaternion& v);
Quaternion mul775(Quaternion lhs,Quaternion rhs);
extern "C" File* FileOpen(i8* filename,i8* mode);
extern "C" u32 FileClose(File* file);
extern "C" u64 GetLine(i8** lineptr,u64* n,File* stream);
extern "C" u64 FileRead(i8* f,u64 a,u64 b,File* c);
extern "C" i32 FileGetChar(File* file);
extern "C" u64 FileWrite(voidptr ptr,u64 size,u64 count,File* stream);
extern "C" void FileFlush(File* file);
extern "C" File* FileOut();
extern "C" File* FileError();
extern "C" i32 chdir(i8* dir);
