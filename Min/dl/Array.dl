@import {
    'Memory.dl'
}
Array struct (T?) {
    length i64 
    elements T^
}

DynamicArray struct (T?) {
    capacity i64
    length i64
    elements T^
}

Init fn(array ref Array(T?), length i64) {
    array.elements = Alloc(T, length)
    array.length = length
}

OpArray fn(array ref Array(T?), index i64) ref T {
    if index >= array.length {
        Assert(0, 'Array access out of bounds [' + String(index) + ']'+' length is ' + String(array.length))
    }
    return ^(array.elements + index)
}


OpArray fn(array ref DynamicArray(T?), index i64) ref T {
    if(index >= array.length){
        Assert(0, 'Array access out of bounds [' + String(index) + ']'+' length is ' + String(array.length))
    }
    return ^(array.elements + index)
}

Init fn(array ref DynamicArray(T?))
{
    array.capacity = 0
    array.length = 0
    array.elements = cast(T^, 0)
}

Push fn(array ref DynamicArray(T?), value T)
{
    if array.capacity < array.length + 1
    {
        capacity i64 = array.capacity * 2
        if capacity < 10 {
            Reserve(array, 10)
        }
        else {
            Reserve(array, capacity)
        }
    }
    ^(array.elements + array.length) = value
    array.length = array.length + 1
}

Reserve fn(array ref DynamicArray(T?), size i64)
{
    if array.capacity < size
    {
        bytes i64 = i64(T.size) * size
        array.elements = cast(T^, realloc(cast(voidptr, array.elements), u64(bytes)))
        memset(cast(voidptr, array.elements + array.capacity), 0, u64(i64(T.size) * (size - array.capacity)))
        array.capacity = size
    }
}

Resize fn(array ref DynamicArray(T?), size i64)
{
    if array.capacity < size
    {
        bytes i64 = i64(T.size) * size
        array.elements = cast(T^, realloc(cast(voidptr, array.elements), u64(bytes)))
        memset(cast(voidptr, array.elements + array.capacity), 0, u64(i64(T.size) * (size - array.capacity)))
        array.capacity = size
    }
    array.length = size
}

Pop fn(array ref DynamicArray(T?))
{
    array.length = array.length - 1
}

Last fn(array ref DynamicArray(T?)) ref T
{
    Assert(array.length > 0, 'Array needs at least 1 element')
    return array[array.length - 1]
}

Remove fn(array ref DynamicArray(T?), value T) i64
{
    count i64
    i i64
    for i < array.length {
        array[i - count] = array[i]
        if array[i] == value
        {
            count = count + 1
        }
        i = i + 1
    }
    array.length = array.length - count
    return count
}

TableNode struct (Key?, Value?)
{
    hash i64
    key Key
    value Value
}

Table struct (Key?, Value?)
{
    length i64
    capacity i64
    data DynamicArray(TableNode(Key, Value))
}

Init fn(table ref Table(Key?, Value?))
{
    table.length = 0
    table.capacity = 16

    Init(table.data)
    Resize(table.data, 16)
}

Resize fn(table ref Table(Key?, Value?))
{
    data DynamicArray(TableNode(Key, Value))
    data.Init()
    Resize(data, table.capacity * 2)

    for i64(0) .. table.data.length
    {
        if table.data[it].hash {
            hash i64  = Hash(table.data[it].key)
            at i64 = (hash % (data.length - 1)) + 1

            done i8 = false
            for !done
            {
                if data[at].hash == 0 
                {
                    data[at] = table.data[it]
                    done = true
                }
                else 
                {
                    if Equal(table.data[it].key, data[at].key)
                    {   
                        data[at] = table.data[it]
                        done = true
                    }
                    at = (at + 1) % data.length
                }
            }
        }
    }

    table.data = data
    table.capacity = table.capacity * 2
}


OpArray fn(table ref Table(Key?, Value?), key Key) ref Value
{
    Assert(table.capacity != 0, 'Table requires Init')
    if table.length * 2.0 > table.capacity
    {
        Resize(table)
    }

    length i64  = table.capacity
    hash i64  = Hash(key)
    at i64 = (hash % (length - 1)) + 1

    table.length = table.length + 1

    for 1 {

        if table.data[at].hash == 0 {
            table.data[at].key = key
            table.data[at].hash = 1
            return table.data[at].value
        }
        else {
            if Equal(key, table.data[at].key)
            {
                return table.data[at].value
            }
            at = (at + 1) % length
        }
    }

}
