//
//  Quaternion.dl
//  Created by David on 6/24/16.
//

struct Quaternion
{            
    float32 w
    float32 x
    float32 y
    float32 z
}
    
fn GetRotationMatrix(Quaternion q) Mat4
{
    Mat4 r
    r[0][0] = 1 - 2*q.y*q.y - 2*q.z*q.z
    r[0][1] = 2*q.x*q.y + 2*q.w*q.z
    r[0][2] = 2*q.x*q.z - 2*q.w*q.y
    r[0][3] = 0
    
    r[1][0] = 2*q.x*q.y - 2*q.w*q.z
    r[1][1] = 1 - 2*q.x*q.x-2*q.z*q.x
    r[1][2] = 2*q.y*q.z+2*q.w*q.x
    r[1][3] = 0

    r[2][0] = 2*q.x*q.z + 2*q.w*q.y
    r[2][1] = 2*q.y*q.z - 2*q.w*q.x
    r[2][2] = 1 - 2*q.x*q.x - 2*q.y*q.y
    r[2][3] = 0
    
    r[3][0] = 0
    r[3][1] = 0
    r[3][2] = 0
    r[3][3] = 1
    
    return r
}

fn CreateQuaternion(Vec3 axis, float32 angle) Quaternion
{
    Quaternion r
    r.w = cos(angle/2);
    r.x = axis.x * sin(angle/2)
    r.y = axis.y * sin(angle/2)
    r.z = axis.z * sin(angle/2)
    return r
}

fn CreateQuaternion() Quaternion
{
    Quaternion r
    r.w = 1.0
    r.x = 0
    r.y = 0
    r.z = 0
    return r
}

fn normalize(ref Quaternion v)
{
    float32 magnitude = sqrt(v.w*v.w + v.x*v.x + v.y*v.y + v.z*v.z)
    v.w = v.w / magnitude
    v.x = v.x / magnitude
    v.y = v.y / magnitude
    v.z = v.z / magnitude
}

fn mul(Quaternion lhs, Quaternion rhs) Quaternion
{
    Quaternion r
    r.w = (lhs.w * rhs.w - lhs.x * rhs.x - lhs.y * rhs.y - lhs.z * rhs.z)
    r.x = (lhs.w * rhs.x + lhs.x * rhs.w + lhs.y * rhs.z - lhs.z * rhs.y)
    r.y = (lhs.w * rhs.y - lhs.x * rhs.z + lhs.y * rhs.w + lhs.z * rhs.x)
    r.z = (lhs.w * rhs.z + lhs.x * rhs.y - lhs.y * rhs.x + lhs.z * rhs.w)
    return r
}
