
@import {
	'dl/Array.dl',
	'dl/String.dl',
	'Libs/glfw.dl',
	'Libs/gl.dl',
	'Vec.dl',
	'World.dl',
	'Renderer.dl',
	'Archive.dl',
    'Editor.dl',
    'Spine.dl',
    'Physics.dl',
}

@build {
	link = (		
		'-framework OpenGL',
		'-framework Cocoa',
		'-framework IOKit',
		'-framework CoreVideo',
		'-lchipmunk', 
		'-lglfw3', 
		'-lspine-c', 
		'-lstb',
	)
}

@extern {
	abort fn()
}


Load fn(file str, scene ref Scene)
{    
    archive Archive = Unarchive(file)
   	Println('Size:' + String(archive.array.length))

    for i64(0) .. archive.array.length {

        entity Entity = CreateEntity()
        entity.Editable()

        Println('Entity ' + String(entity.id))

        {
            arch Archive = archive.array[it]['Sprite']
            if arch.Type != ArchiveNone {
                sprite Sprite^ = entity.Sprite(^scene.renderer, arch['Texture'].string)
                sprite.material.shader = scene.renderer.Shader(arch['Vertex'].string, arch['Fragment'].string)
                Load(arch['Color'], sprite.color)
                sprite.Color(sprite.color)
            }
        }

        {
            arch Archive = archive.array[it]['Transform']
            if arch.Type != ArchiveNone {

                transform Transform^ = entity.Transform()
                arch['Position'].Load(transform.position)
                arch['Scale'].Load(transform.scale)  
                Recalculate(^transform)
            }       
        }
    }
}

Scene struct {
    renderer Renderer^
    window Window^
    camera Camera^
}

Resized fn(glfwwindow GLFWwindow^, x u32, y  u32){
    window Window^ = cast(Window^, glfwGetWindowUserPointer(glfwwindow))
    window.Size = Vec2(f32(x), f32(y))
}

Mouses fn(glfwwindow GLFWwindow^, button u32, action u32, mods u32){
    window Window^ = cast(Window^, glfwGetWindowUserPointer(glfwwindow))
    x f64
    y f64
    glfwGetCursorPos(glfwwindow, &x, &y)
    window.Mouse(Vec2(f32((x / window.size.x.f64() - 0.5) * 2.0), f32((0.5 - y / window.size.y.f64()) * 2.0)), i8(action))
}

Moved fn(glfwwindow GLFWwindow^, x f64, y f64) {
    window Window^ = cast(Window^, glfwGetWindowUserPointer(glfwwindow))
    //In range -1 to 1, flip y top is 1 bottom is -1
    glfwGetCursorPos(glfwwindow, &x, &y)
    window.mouse = Vec2(f32((x / window.size.x.f64() - 0.5) * 2.0), f32((0.5 - y / window.size.y.f64()) * 2.0))
}

Key fn (glfwwindow GLFWwindow^, key u32, scancode u32, action u32, mods u32)
{
    window Window^ = cast(Window^, glfwGetWindowUserPointer(glfwwindow))
    window.Key(key.i64(), action.i8())
}

Main fn() i32 {

	glfwInit()
	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3)
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3)
    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, 1)
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE)

	glfwwindow GLFWwindow^ = glfwCreateWindow(1280, 720, 'Min'.chars, cast(GLFWmonitor^,0), cast(GLFWwindow^, 0))
    glfwMakeContextCurrent(glfwwindow)
    glfwSetWindowSizeCallback(glfwwindow, Resized)
    glfwSetMouseButtonCallback(glfwwindow, Mouses)
    glfwSetCursorPosCallback(glfwwindow, Moved)
    glfwSetKeyCallback(glfwwindow, Key)

	if chdir('/Users/David/Desktop/Resources'.chars) != 0 {
        Assert(0, 'Couldnt set resource directory')
    }

    Init(world)
    
  	window Window
    window.size = Vec2(1280, 720)
    window.glfwwindow = glfwwindow
    glfwSetWindowUserPointer(glfwwindow, cast(voidptr, &window))

    renderer Renderer = Renderer()
    camera Camera = Camera()

    theScene Scene
    theScene.window= &window
    theScene.renderer = &renderer
    theScene.camera = &camera
    
	scene Texture = Texture(window.FrameBufferSize())
    occlusion Texture = Texture(window.FrameBufferSize())
    sceneLighted Texture = Texture(window.FrameBufferSize())
    sceneDownSample Texture = Texture(window.FrameBufferSize()/2.0)
    sceneBluredX Texture = Texture(window.FrameBufferSize()/2.0)
    sceneBluredY Texture = Texture(window.FrameBufferSize()/2.0)

    scenePass ShadingPass = ShadingPass()
    scenePass.clear = 1
    scenePass.out.Push(&scene)
    scenePass.out.Push(&occlusion)
    scenePass.Refresh()
    renderer.passes.Push(scenePass)

    {   
        post Shader = renderer.Shader('shaders/PostProcess.vs', 'shaders/Lighting.fs')
        sprite Sprite = Sprite(renderer, 'images/GrassSmall.png')
        sprite.material.texture = occlusion
        sprite.material.shader = post

        pass ShadingPass = PostProcess(sprite)
        pass.in.Push(&scene)
        pass.in.Push(&occlusion)
        pass.out.Push(&sceneLighted)

        pass.Refresh()
        renderer.passes.Push(pass)
    }

    {   
        post Shader = renderer.Shader('Shaders/PostProcess.vs', 'Shaders/SampleDown.fs')

        sprite Sprite = Sprite(renderer, 'images/GrassSmall.png')
        sprite.material.texture = scene
        sprite.material.shader = post

        pass ShadingPass = PostProcess(sprite)
        pass.in.Push(&sceneLighted)
        pass.out.Push(&sceneDownSample)
        pass.clear = 1
        pass.Refresh()
        renderer.passes.Push(pass)
    } 
    {   
        post Shader = renderer.Shader('Shaders/PostProcess.vs', 'Shaders/BlurX.fs')

        sprite Sprite = Sprite(renderer, 'images/GrassSmall.png')
        sprite.material.texture = scene
        sprite.material.shader = post

        pass ShadingPass = PostProcess(sprite)
        pass.in.Push(&sceneDownSample)
        pass.out.Push(&sceneBluredX)
        pass.clear = 1
        pass.Refresh()
        renderer.passes.Push(pass)
    } 
    {   
        post Shader = renderer.Shader('Shaders/PostProcess.vs', 'Shaders/BlurY.fs')

        sprite Sprite = Sprite(renderer, 'images/GrassSmall.png')
        sprite.material.texture = scene
        sprite.material.shader = post

        pass ShadingPass = PostProcess(sprite)
        pass.in.Push(&sceneBluredX)
        pass.out.Push(&sceneBluredY)
        pass.clear = 1
        pass.Refresh()
        renderer.passes.Push(pass)
    } 
    {   
        post Shader = renderer.Shader('Shaders/PostProcess.vs', 'Shaders/Combine.fs')

        sprite Sprite = Sprite(renderer, 'images/GrassSmall.png')
        sprite.material.texture = scene
        sprite.material.shader = post

        pass ShadingPass = PostProcess(sprite)
        pass.in.Push(&sceneLighted)
        pass.in.Push(&sceneBluredY)
        pass.clear = 1
        pass.Refresh()
        renderer.passes.Push(pass)
    } 

    Load('lights', theScene)
    physics Physics = Physics()


    entity Entity = CreateEntity()

    transform Transform^ = entity.Transform()
    transform.Position = Vec3(1, 25, 0)
    transform.Scale = Vec3(.01)  

    mesh Mesh^ = entity.Mesh(renderer)
    mesh.material.shader = renderer.Shader('shaders/Position.vs', 'shaders/Character.fs')
    spine Spine = Spine(renderer, mesh, 'Character.json','Character.atlas')

    body Body^ = entity.Body(physics)
    shape Shape^ = entity.Shape(physics)
    shape.Circle(100)
    shape.Friction(5)
    body.LockRotation()
    entity.Character()
    entity.Editable()

    Load('data', theScene)

    {
        entity Entity = CreateEntity()
        transform Transform^ = entity.Transform()
        transform.Position = Vec3(0, 0, 0)

        shape Shape^ = entity.Shape(physics)

        array Array(Vec2)
        array.Init(3)
        array[0] = Vec2(-25, -30)
        array[1] = Vec2(0, -10)
        array[2] = Vec2(25, -30)


        shape.Segments(array, 5)
        shape.Friction(25)
        entity.Editable()
    }

    glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA)
    glBlendFuncSeparatei(1, GL_ONE, GL_ONE, GL_ONE, GL_ONE_MINUS_SRC_ALPHA)
    glEnable(GL_BLEND)

    editor Editor = Editor(&world, &camera)
    editor.AddEditables(world, renderer, window)


    step f32 = f32(1)/(f32(60) * f32(2))
    accum f32

    for !glfwWindowShouldClose(glfwwindow)
    {
        delta f32 = glfwGetTime()
        glfwSetTime(0)

        glClear(GL_COLOR_BUFFER_BIT)
        glClearColor(0, 0, 0, 0)

        window.time = window.time + delta
        theScene.camera.projection = Perspective(theScene.camera.fieldOfView, theScene.window.size.x/theScene.window.size.y, theScene.camera.near, theScene.camera.far)
        theScene.camera.viewProjection = theScene.camera.projection * theScene.camera.view

        editor.Update(window.mouse)
        spine.Update(delta)
        Update(Character, world, window)
        accum = accum + delta

        for accum > step
        {
            physics.Update(world, step)
            accum = accum - step
        }

        renderer.Render(world, camera, window)

        glfwSwapBuffers(glfwwindow)
        glfwPollEvents()
    }

	return 0
}
