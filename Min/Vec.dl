@import {
    "Math.dl",
}
struct Vec4 {
    float32 x
    float32 y
    float32 z
    float32 w
}
struct Vec3 {
    float32 x
    float32 y
    float32 z
}
struct Vec2 {
    float32 x
    float32 y
}
struct Mat4 {
    Vec4 x
    Vec4 y
    Vec4 z
    Vec4 w
}

fn String(Vec4 v) str
{
    return "(" + String(v.x) + "," + String(v.y) + "," + String(v.z) + "," + String(v.w) + ")";
}
fn String(Vec3 v) str
{
    return "(" + String(v.x) + "," + String(v.y) + "," + String(v.z) + ")";
}
fn String(Vec2 v) str
{
    return "(" + String(v.x) + "," + String(v.y) + ")";
}
fn opArray(ref Mat4 matrix, int index) ref Vec4 {
    return ^(cast(&matrix, Vec4^) + index)
}
fn opArray(ref Vec4 v, int index) ref float32
{
    return ^(cast(&v, float32^) + index)
}


fn Mat4(float32 v) Mat4 {
    Mat4 r
    r.x = Vec4(v, 0, 0, 0)
    r.y = Vec4(0, v, 0, 0)
    r.z = Vec4(0, 0, v, 0)
    r.w = Vec4(0, 0, 0, 1)
    return r
}

fn Mat4Scale(Vec3 scale) Mat4{
    Mat4 r
    r.x = Vec4(scale.x, 0, 0, 0)
    r.y = Vec4(0, scale.y, 0, 0)
    r.z = Vec4(0, 0, scale.z, 0)
    r.w = Vec4(0, 0, 0, 1)
    return r
}

fn Mat4Transform(Vec3 v) Mat4{
    Mat4 r
    r.x = Vec4(1, 0, 0, 0)
    r.y = Vec4(0, 1, 0, 0)
    r.z = Vec4(0, 0, 1, 0)
    r.w = Vec4(v.x, v.y, v.z, 1)
    return r
}

fn mul(Mat4 lhs, Mat4 rhs) Mat4{
    Mat4 v
    int r
    for(r < 4)
    {
        int c
        for (c < 4)
        {
            int k
            v[c][r] = 0
            for(k < 4)
            {
                v[c][r] = v[c][r] + lhs[k][r] * rhs[c][k]
                k = k + 1
            }
            c = c + 1
        }
        r = r + 1
    }
    return v
}

fn Vec4(float32 x, float32 y, float32 z, float32 w) Vec4{
    Vec4 v
    v.x = x
    v.y = y
    v.z = z
    v.w = w
    return v
}
fn Vec4(Vec3 v, float32 w) Vec4{
    Vec4 r
    r.x = v.x
    r.y = v.y
    r.z = v.z
    r.w = w
    return r
}
fn Vec4(float32 v) Vec4{
    return Vec4(v, v, v, v)
}
fn Vec3(float32 x, float32 y, float32 z) Vec3{
    Vec3 v
    v.x = x
    v.y = y
    v.z = z
    return v
}

fn Vec3(float32 value) Vec3{
    Vec3 v
    v.x = value
    v.y = value
    v.z = value
    return v
}

fn Vec3(Vec2 v) Vec3{
    Vec3 r
    r.x = v.x
    r.y = v.y
    r.z = 0
    return r
}

fn Vec2(Vec3 v) Vec2{
    Vec2 r
    r.x = v.x
    r.y = v.y
    return r
}
fn Vec2(float32 x, float32 y) Vec2{
    Vec2 v
    v.x = x
    v.y = y
    return v
}

fn Vec2(float32 v) Vec2
{
    return Vec2(v, v)
}
fn sub(Vec3 lhs, Vec3 rhs) Vec3{
    Vec3 v
    v.x = lhs.x - rhs.x
    v.y = lhs.y - rhs.y
    v.z = lhs.z - rhs.z
    return v
}
fn sub(Vec3 lhs, Vec2 rhs) Vec3{
    Vec3 v
    v.x = lhs.x - rhs.x
    v.y = lhs.y - rhs.y
    v.z = lhs.z
    return v
}
fn sub(Vec2 lhs, Vec2 rhs) Vec2{
    Vec2 v
    v.x = lhs.x - rhs.x
    v.y = lhs.y - rhs.y
    return v
}
fn add(Vec3 lhs, Vec3 rhs) Vec3{
    Vec3 v
    v.x = lhs.x + rhs.x
    v.y = lhs.y + rhs.y
    v.z = lhs.z + rhs.z
    return v
}
fn add(Vec3 lhs, Vec2 rhs) Vec3{
    Vec3 v
    v.x = lhs.x + rhs.x
    v.y = lhs.y + rhs.y
    v.z = lhs.z
    return v
}
fn add(Vec2 lhs, Vec2 rhs) Vec2{
    Vec2 v
    v.x = lhs.x + rhs.x
    v.y = lhs.y + rhs.y
    return v
}
fn mul(Vec3 lhs, Vec3 rhs) Vec3{
    Vec3 v
    v.x = lhs.x * rhs.x
    v.y = lhs.y * rhs.y
    v.z = lhs.z * rhs.z
    return v
}

fn mul(float32 l, Vec4 r) Vec4 { return mul(r, l) }
fn mul(Vec4 l, float32 r) Vec4{
    Vec4 v
    v.x = l.x * r
    v.y = l.y * r
    v.z = l.z * r
    v.w = l.w * r
    return v
}
fn mul(float32 l, Vec3 r) Vec3 { return mul(r, l) }
fn mul(Vec3 l, float32 r) Vec3{
    Vec3 v
    v.x = l.x * r
    v.y = l.y * r
    v.z = l.z * r
    return v
}

fn mul(float32 l, Vec2 r) Vec2 { return mul(r, l) }
fn mul(Vec2 l, float32 r) Vec2{
    Vec2 v
    v.x = l.x * r
    v.y = l.y * r
    return v
}

fn div(Vec2 l, float32 r) Vec2{
    return l * (1.0/r)
}
fn div(Vec3 l, float32 r) Vec3{
    return l * (1.0/r)
}
fn div(Vec4 l, float32 r) Vec4{
    return l * (1.0/r)
}

fn Dot(Vec3 l, Vec3 r) float32
{
    return l.x*r.x + l.y*r.y + l.z*r.z
}
fn Dot(Vec2 l, Vec2 r) float32
{
    return l.x*r.x + l.y*r.y
}
fn Cross(Vec3 l, Vec3 r) Vec3
{
    return Vec3(l.y*r.z - l.z*r.y, l.z*r.x - l.x*r.z, l.x*r.y - l.y*r.x)
}

fn Length(Vec3 v) float32
{
    return sqrt(v.x*v.x + v.y*v.y + v.z*v.z)
}
fn Length(Vec2 v) float32
{
    return sqrt(v.x*v.x + v.y*v.y)
}

fn Normalize(Vec3 v) Vec3
{
    return v * 1.0/Length(v)
}
fn Normalize(Vec2 v) Vec2
{
    return v * 1.0/Length(v)
}