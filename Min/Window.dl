@import
{
	'Vec.dl',
	'Libs/glfw.dl',
}

Callback struct(T?)
{
	self voidptr
	func fn(self voidptr, data T)
}

//struct Key
//{
//	int key
//	int modifiers
//}
//struct KeyCallback :T?
//{
//	voidptr self
//	// fn down(T, Key);
//	// fn up(T, Key);
//}

//// enum Button
//// {
//// 	Left
//// 	Right
//// 	Middle
//// }

MouseCallback struct
{
	self voidptr
	Up fn(self voidptr, at Vec2)
	Down fn(self voidptr, at Vec2) i8
}

RegisterMouse fn(window ref Window, self ref T?, Down fn(self ref T, at Vec2), Up fn(self ref T, at Vec2))
{
	mouse MouseCallback
	mouse.self = cast(voidptr, &self)
	mouse.Down = cast(fn(self voidptr, at Vec2)i8, Down)
	mouse.Up = cast(fn(self voidptr, at Vec2), Up)
	window.mouseCallbacks.Push(mouse)
}

KeyCallback struct
{
	self voidptr
	Up fn(self voidptr, at i64)
	Down fn(self voidptr, at i64)
}

RegisterKey fn(window ref Window, self ref T?, Down fn(self ref T, key i64), Up fn(self ref T, key i64))
{
	key KeyCallback
	key.self = cast(voidptr, &self)
	key.Down = cast(fn(self voidptr, key i64), Down)
	key.Up = cast(fn(self voidptr, key i64), Up)
	window.keyCallbacks.Push(key)
}

//struct Void {
//}

//@TODO: Fix returned value is potentially invalidated after next Register call use dynamic memory
//@TODO: Compiler can fix this type erasure for us with language supported captures
// fn Register(mut DynamicArray:(mut MouseCallback:(Void))! callbacks, Self?! self) mut MouseCallback:(Self)!
// {
// 	mut MouseCallback:(Self) call
// 	call.self = &self
// 	push(callbacks, 'cast(mut MouseCallback:(Void)', &call))
// 	return 'cast(mut MouseCallback:(Self)', &callbacks[callbacks.length - 1])
// }

// fn Register(mut DynamicArray:(mut KeyCallback:(Void))! callbacks, Self?! self) mut KeyCallback:(Self)!
// {
// 	mut KeyCallback:(Self) call
// 	call.self = &self
// 	push(callbacks, 'cast(mut KeyCallback:(Void)', &call))
// 	return 'cast(mut KeyCallback:(Self)', &callbacks[callbacks.length - 1])
// }

Call fn(callback Callback(T?), data T)
{
	callback.func(callback.self, data)
}

Window struct
{
	size Vec2
	time f32
	mouse Vec2
	glfwwindow GLFWwindow^
	//DynamicArray:(Callback:(Vec2)) resized

	// DynamicArray:(MouseCallback:(Void)) mouseCallbacks
	// DynamicArray:(KeyCallback:(Void)) keyCallbacks

	resized DynamicArray(Callback(Vec2))
	mouseCallbacks DynamicArray(MouseCallback)
	keyCallbacks DynamicArray(KeyCallback)
}

FrameBufferSize fn(window ref Window) Vec2
{
	x u32
	y u32
	glfwGetFramebufferSize(window.glfwwindow, &x, &y)
	return Vec2(x.f32(), y.f32())
}
GetKey fn(window ref Window, key i64) i64
{
	return glfwGetKey(window.glfwwindow, key.u32()).i64()
}

Mouse fn(window ref Window, mouse Vec2, down i8)
{
	window.mouse = mouse
	if down
	{
		Println('Mouse Down: ' + String(mouse))
		for i64(0) .. window.mouseCallbacks.length
	    {
	    	window.mouseCallbacks[it].Down(window.mouseCallbacks[it].self, mouse)
	    }
	}
	else
	{
		Println('Mouse Up: ' + String(mouse))
		for i64(0) .. window.mouseCallbacks.length
	    {
	    	window.mouseCallbacks[it].Up(window.mouseCallbacks[it].self, mouse)
	    }
	}
}

Key fn(window ref Window, key i64, down i8)
{
	if down
	{
		Println('Mouse Down: ' + String(key))
		for i64(0) .. window.keyCallbacks.length
	    {
	    	window.keyCallbacks[it].Down(window.keyCallbacks[it].self, key)
	    }
	}
	else
	{
		Println('Mouse Up: ' + String(key))
		for i64(0) .. window.keyCallbacks.length
	    {
	    	window.keyCallbacks[it].Up(window.keyCallbacks[it].self, key)
	    }
	}
}
Size fn(window ref Window, size Vec2)
{
	window.size = size
    Println('Resized: ' + String(window.size))
    for i64(0) .. window.resized.length
    {
        Call(window.resized[it], window.size)
    }
}