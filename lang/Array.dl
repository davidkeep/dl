
@import {
    "c.dl",
    "Conversions.dl",
    "Memory.dl",
   	"String.dl",
}

int8 false = 0
int8 true = 1

fn Assert(int condition, str detail) {
    if !condition {
        //StackTracePrint()
        Print(detail)
        abort()
    }
}

struct Array : T? {
    int length
    T^ elements
}

struct DynamicArray : T?
{
    int capacity
    int length
    T^ elements
}

fn Init(ref Array:(T?) array, int length){
    AllocPtrZeroed(array.elements, length)
    array.length = length
}

fn opArray(ref Array:(T?) array, int index) ref T {
    if(index >= array.length){
        Assert(0, "Array access out of bounds [" + String(index) + "]"+" length is " + String(array.length))
    }
    return ^(array.elements + index)
}

fn opArray(ref DynamicArray:(T?) array, int index) ref T {
    if(index >= array.length){
        Assert(0, "Array access out of bounds ["+String(index) + "]"+" length is "+String(array.length))
    }
    return ^(array.elements + index)
}

fn Init(ref DynamicArray:(T?) array)
{
    array.capacity = 0
    array.length = 0
    array.elements = cast(0, T^)
}

fn push(ref DynamicArray:(T?) array, T value)
{
    if array.capacity < array.length + 1
    {
        int capacity = array.capacity * 2
        if capacity < 10 {
            Reserve(array, 10)
        }
        else {
            Reserve(array, capacity)
        }
    }
    ^(array.elements + array.length) = value
    array.length = array.length + 1
}

fn Reserve(ref DynamicArray:(T?) array, int size)
{
    if array.capacity < size
    {
        int bytes = T.size * size
        array.elements = cast(realloc(cast(array.elements, voidptr), uint(bytes)), T^)
        memset(cast(array.elements + array.capacity, voidptr), 0, uint(T.size * (size - array.capacity)))
        array.capacity = size
    }
}

fn Resize(ref DynamicArray:(T?) array, int size)
{
    if array.capacity < size
    {
        int bytes = T.size * size
        array.elements = cast(realloc(cast(array.elements, voidptr), uint(bytes)), T^)
        memset(cast(array.elements + array.capacity, voidptr), 0, uint(T.size * (size - array.capacity)))
        array.capacity = size
    }
    array.length = size
}

fn pop(ref DynamicArray:(T?) array)
{
    array.length = array.length - 1
}

fn remove(ref DynamicArray:(T?) array, T value) int
{
    int count
    int i
    for i < array.length {
        array[i - count] = array[i]
        if array[i] == value
        {
            count = count + 1
        }
        i = i + 1
    }
    array.length = array.length - count
    return count
}

struct TableNode : Key?, Value?
{
    int hash
    Key key
    Value value
}

struct Table : Key?, Value?
{
    int length
    int capacity
    DynamicArray:(TableNode:(Key, Value)) data
}

fn Init(ref Table:(Key?, Value?) table)
{
    table.length = 0
    table.capacity = 16
    Init(table.data)
    Resize(table.data, 16)
}

fn Resize(ref Table:(Key?, Value?) table)
{
    DynamicArray:(TableNode:(Key, Value)) data
    Resize(data, table.capacity * 2)
    int i
    for i < table.data.length
    {
        int index = (((table.data)[i]).hash) % data.length
        data[index] = table.data[i]
    }
    table.data = data;
}


fn opArray(ref Table:(Key?, Value?) table, Key key) ref Value
{

    if table.length + table.length/2 > table.capacity
    {
        Resize(table)
    }
    int length = table.capacity
    int hash = Hash(key)
    int at = (hash % (length - 1)) + 1

    for 1 {
        if table.data[at].hash == 0 {
            table.data[at].key = key
            table.data[at].hash = 1
            return table.data[at].value
        }
        else {
            if equal(key, table.data[at].key)
            {
                return table.data[at].value
            }
            at = at + 1
        }
    }
}
